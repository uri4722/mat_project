/*! @hebcal/core v5.1.0 */
/** @private */
const lengths = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
/** @private */
const monthLengths = [
    lengths,
    lengths.slice(),
];
monthLengths[1][2] = 29;
/**
 * @private
 */
function mod$1(x, y) {
    return x - y * Math.floor(x / y);
}
/**
 * @private
 */
function quotient(x, y) {
    return Math.floor(x / y);
}
/*
const ABS_14SEP1752 = 639797;
const ABS_2SEP1752 = 639785;
*/
/**
 * Gregorian date helper functions.
 */
var greg;
(function (greg) {
    /**
     * Returns true if the Gregorian year is a leap year
     * @param {number} year Gregorian year
     * @return {boolean}
     */
    function isLeapYear(year) {
        return !(year % 4) && (!!(year % 100) || !(year % 400));
    }
    greg.isLeapYear = isLeapYear;
    /**
     * Number of days in the Gregorian month for given year
     * @param {number} month Gregorian month (1=January, 12=December)
     * @param {number} year Gregorian year
     * @return {number}
     */
    function daysInMonth(month, year) {
        // 1 based months
        return monthLengths[+isLeapYear(year)][month];
    }
    greg.daysInMonth = daysInMonth;
    /**
     * Returns true if the object is a Javascript Date
     * @param {Object} obj
     * @return {boolean}
     */
    function isDate(obj) {
        return typeof obj === 'object' && Date.prototype.isPrototypeOf(obj);
    }
    greg.isDate = isDate;
    /**
     * @private
     * @param abs - R.D. number of days
     */
    function yearFromFixed(abs) {
        const l0 = abs - 1;
        const n400 = quotient(l0, 146097);
        const d1 = mod$1(l0, 146097);
        const n100 = quotient(d1, 36524);
        const d2 = mod$1(d1, 36524);
        const n4 = quotient(d2, 1461);
        const d3 = mod$1(d2, 1461);
        const n1 = quotient(d3, 365);
        const year = 400 * n400 + 100 * n100 + 4 * n4 + n1;
        return n100 != 4 && n1 != 4 ? year + 1 : year;
    }
    /**
     * @private
     * @param year
     * @param month (1-12)
     * @param day (1-31)
     */
    function toFixed(year, month, day) {
        const py = year - 1;
        return 365 * py +
            quotient(py, 4) -
            quotient(py, 100) +
            quotient(py, 400) +
            quotient((367 * month - 362), 12) +
            (month <= 2 ? 0 : (isLeapYear(year) ? -1 : -2)) +
            day;
    }
    /**
     * Converts Gregorian date to absolute R.D. (Rata Die) days
     * @param {Date} date Gregorian date
     * @return {number}
     */
    function greg2abs(date) {
        if (!isDate(date)) {
            throw new TypeError(`Argument not a Date: ${date}`);
        }
        const abs = toFixed(date.getFullYear(), date.getMonth() + 1, date.getDate());
        /*
        if (abs < ABS_14SEP1752 && abs > ABS_2SEP1752) {
          throw new RangeError(`Invalid Date: ${date}`);
        }
        */
        return abs;
    }
    greg.greg2abs = greg2abs;
    /**
     * Converts from Rata Die (R.D. number) to Gregorian date.
     * See the footnote on page 384 of ``Calendrical Calculations, Part II:
     * Three Historical Calendars'' by E. M. Reingold,  N. Dershowitz, and S. M.
     * Clamen, Software--Practice and Experience, Volume 23, Number 4
     * (April, 1993), pages 383-404 for an explanation.
     * @param {number} abs - R.D. number of days
     * @return {Date}
     */
    function abs2greg(abs) {
        if (typeof abs !== 'number') {
            throw new TypeError(`Argument not a Number: ${abs}`);
        }
        abs = Math.trunc(abs);
        /*
        if (abs < ABS_14SEP1752 && abs > ABS_2SEP1752) {
          throw new RangeError(`Invalid Date: ${abs}`);
        }
        */
        const year = yearFromFixed(abs);
        const priorDays = abs - toFixed(year, 1, 1);
        const correction = abs < toFixed(year, 3, 1) ? 0 : (isLeapYear(year) ? 1 : 2);
        const month = quotient((12 * (priorDays + correction) + 373), 367);
        const day = abs - toFixed(year, month, 1) + 1;
        const dt = new Date(year, month - 1, day);
        if (year < 100 && year >= 0) {
            dt.setFullYear(year);
        }
        return dt;
    }
    greg.abs2greg = abs2greg;
})(greg || (greg = {}));

/*
 * More minimal HDate
 */
const NISAN$4 = 1;
const IYYAR$1 = 2;
// const SIVAN = 3;
const TAMUZ$1 = 4;
// const AV = 5;
const ELUL$1 = 6;
const TISHREI$2 = 7;
const CHESHVAN$1 = 8;
const KISLEV$2 = 9;
const TEVET$2 = 10;
// const SHVAT = 11;
const ADAR_I$2 = 12;
const ADAR_II$2 = 13;
/**
 * Hebrew months of the year (NISAN=1, TISHREI=7)
 * @readonly
 * @enum {number}
 */
const months = {
    /** Nissan / ניסן */
    NISAN: 1,
    /** Iyyar / אייר */
    IYYAR: 2,
    /** Sivan / סיון */
    SIVAN: 3,
    /** Tamuz (sometimes Tammuz) / תמוז */
    TAMUZ: 4,
    /** Av / אב */
    AV: 5,
    /** Elul / אלול */
    ELUL: 6,
    /** Tishrei / תִּשְׁרֵי */
    TISHREI: 7,
    /** Cheshvan / חשון */
    CHESHVAN: 8,
    /** Kislev / כסלו */
    KISLEV: 9,
    /** Tevet / טבת */
    TEVET: 10,
    /** Sh'vat / שבט */
    SHVAT: 11,
    /** Adar or Adar Rishon / אדר */
    ADAR_I: 12,
    /** Adar Sheini (only on leap years) / אדר ב׳ */
    ADAR_II: 13,
};
const monthNames0 = [
    '',
    'Nisan',
    'Iyyar',
    'Sivan',
    'Tamuz',
    'Av',
    'Elul',
    'Tishrei',
    'Cheshvan',
    'Kislev',
    'Tevet',
    'Sh\'vat',
];
/**
 * Transliterations of Hebrew month names.
 * Regular years are index 0 and leap years are index 1.
 * @private
 */
const monthNames = [
    monthNames0.concat([
        'Adar',
        'Nisan',
    ]),
    monthNames0.concat([
        'Adar I',
        'Adar II',
        'Nisan',
    ]),
];
const edCache = new Map();
const EPOCH = -1373428;
// Avg year length in the cycle (19 solar years with 235 lunar months)
const AVG_HEBYEAR_DAYS = 365.24682220597794;
/**
 * @private
 */
function assertNumber(n, name) {
    if (typeof n !== 'number' || isNaN(n)) {
        throw new TypeError(`invalid parameter '${name}' not a number: ${n}`);
    }
}
/**
 * Converts Hebrew date to R.D. (Rata Die) fixed days.
 * R.D. 1 is the imaginary date Monday, January 1, 1 on the Gregorian
 * Calendar.
 * @param {number} year Hebrew year
 * @param {number} month Hebrew month
 * @param {number} day Hebrew date (1-30)
 * @return {number}
 */
function hebrew2abs(year, month, day) {
    assertNumber(year, 'year');
    assertNumber(month, 'month');
    assertNumber(day, 'day');
    if (year < 1) {
        throw new RangeError(`hebrew2abs: invalid year ${year}`);
    }
    let tempabs = day;
    if (month < TISHREI$2) {
        for (let m = TISHREI$2; m <= monthsInYear(year); m++) {
            tempabs += daysInMonth(m, year);
        }
        for (let m = NISAN$4; m < month; m++) {
            tempabs += daysInMonth(m, year);
        }
    }
    else {
        for (let m = TISHREI$2; m < month; m++) {
            tempabs += daysInMonth(m, year);
        }
    }
    return EPOCH + elapsedDays(year) + tempabs - 1;
}
/**
 * @private
 */
function newYear(year) {
    return EPOCH + elapsedDays(year);
}
/**
 * Converts absolute R.D. days to Hebrew date
 * @param {number} abs absolute R.D. days
 * @return {SimpleHebrewDate}
 */
function abs2hebrew(abs) {
    assertNumber(abs, 'abs');
    abs = Math.trunc(abs);
    if (abs <= EPOCH) {
        throw new RangeError(`abs2hebrew: ${abs} is before epoch`);
    }
    // first, quickly approximate year
    let year = Math.floor((abs - EPOCH) / AVG_HEBYEAR_DAYS);
    while (newYear(year) <= abs) {
        ++year;
    }
    --year;
    let month = abs < hebrew2abs(year, 1, 1) ? 7 : 1;
    while (abs > hebrew2abs(year, month, daysInMonth(month, year))) {
        ++month;
    }
    const day = 1 + abs - hebrew2abs(year, month, 1);
    return { yy: year, mm: month, dd: day };
}
/**
 * Returns true if Hebrew year is a leap year
 * @param {number} year Hebrew year
 * @return {boolean}
 */
function isLeapYear(year) {
    return (1 + year * 7) % 19 < 7;
}
/**
 * Number of months in this Hebrew year (either 12 or 13 depending on leap year)
 * @param {number} year Hebrew year
 * @return {number}
 */
function monthsInYear(year) {
    return 12 + +(isLeapYear(year)); // boolean is cast to 1 or 0
}
/**
 * Number of days in Hebrew month in a given year (29 or 30)
 * @param {number} month Hebrew month (e.g. months.TISHREI)
 * @param {number} year Hebrew year
 * @return {number}
 */
function daysInMonth(month, year) {
    switch (month) {
        case IYYAR$1:
        case TAMUZ$1:
        case ELUL$1:
        case TEVET$2:
        case ADAR_II$2:
            return 29;
    }
    if ((month === ADAR_I$2 && !isLeapYear(year)) ||
        (month === CHESHVAN$1 && !longCheshvan(year)) ||
        (month === KISLEV$2 && shortKislev(year))) {
        return 29;
    }
    else {
        return 30;
    }
}
/**
 * Returns a transliterated string name of Hebrew month in year,
 * for example 'Elul' or 'Cheshvan'.
 * @param {number} month Hebrew month (e.g. months.TISHREI)
 * @param {number} year Hebrew year
 */
function getMonthName(month, year) {
    assertNumber(month, 'month');
    assertNumber(year, 'year');
    if (month < 1 || month > 14) {
        throw new TypeError(`bad month argument ${month}`);
    }
    return monthNames[+isLeapYear(year)][month];
}
/**
 * Days from sunday prior to start of Hebrew calendar to mean
 * conjunction of Tishrei in Hebrew YEAR
 * @param {number} year Hebrew year
 * @return {number}
 */
function elapsedDays(year) {
    const n = edCache.get(year);
    if (typeof n === 'number') {
        return n;
    }
    const elapsed = elapsedDays0(year);
    edCache.set(year, elapsed);
    return elapsed;
}
/**
 * Days from sunday prior to start of Hebrew calendar to mean
 * conjunction of Tishrei in Hebrew YEAR
 * @private
 * @param year Hebrew year
 */
function elapsedDays0(year) {
    const prevYear = year - 1;
    const mElapsed = 235 * Math.floor(prevYear / 19) + // Months in complete 19 year lunar (Metonic) cycles so far
        12 * (prevYear % 19) + // Regular months in this cycle
        Math.floor(((prevYear % 19) * 7 + 1) / 19); // Leap months this cycle
    const pElapsed = 204 + 793 * (mElapsed % 1080);
    const hElapsed = 5 +
        12 * mElapsed +
        793 * Math.floor(mElapsed / 1080) +
        Math.floor(pElapsed / 1080);
    const parts = (pElapsed % 1080) + 1080 * (hElapsed % 24);
    const day = 1 + 29 * mElapsed + Math.floor(hElapsed / 24);
    let altDay = day;
    if (parts >= 19440 ||
        (2 === day % 7 && parts >= 9924 && !isLeapYear(year)) ||
        (1 === day % 7 && parts >= 16789 && isLeapYear(prevYear))) {
        altDay++;
    }
    if (altDay % 7 === 0 || altDay % 7 === 3 || altDay % 7 === 5) {
        return altDay + 1;
    }
    else {
        return altDay;
    }
}
/**
 * Number of days in the hebrew YEAR.
 * A common Hebrew calendar year can have a length of 353, 354 or 355 days
 * A leap Hebrew calendar year can have a length of 383, 384 or 385 days
 * @param {number} year Hebrew year
 * @return {number}
 */
function daysInYear(year) {
    return elapsedDays(year + 1) - elapsedDays(year);
}
/**
 * true if Cheshvan is long in Hebrew year
 * @param {number} year Hebrew year
 * @return {boolean}
 */
function longCheshvan(year) {
    return daysInYear(year) % 10 === 5;
}
/**
 * true if Kislev is short in Hebrew year
 * @param {number} year Hebrew year
 * @return {boolean}
 */
function shortKislev(year) {
    return daysInYear(year) % 10 === 3;
}
/**
 * Converts Hebrew month string name to numeric
 * @param {string} monthName monthName
 * @return {number}
 */
function monthFromName(monthName) {
    if (typeof monthName === 'number') {
        if (isNaN(monthName) || monthName < 1 || monthName > 14) {
            throw new RangeError(`Invalid month name: ${monthName}`);
        }
        return monthName;
    }
    let c = monthName.trim().toLowerCase();
    // If Hebrew month starts with a bet (for example `בתמוז`) then ignore it
    if (c[0] === 'ב') {
        c = c.substring(1);
    }
    /*
    the Hebrew months are unique to their second letter
    N         Nisan  (November?)
    I         Iyyar
    E        Elul
    C        Cheshvan
    K        Kislev
    1        1Adar
    2        2Adar
    Si Sh     Sivan, Shvat
    Ta Ti Te Tamuz, Tishrei, Tevet
    Av Ad    Av, Adar
  
    אב אד אי אל   אב אדר אייר אלול
    ח            חשון
    ט            טבת
    כ            כסלו
    נ            ניסן
    ס            סיון
    ש            שבט
    תמ תש        תמוז תשרי
    */
    switch (c[0]) {
        case 'n':
        case 'נ':
            if (c[1] == 'o') {
                break; /* this catches "november" */
            }
            return months.NISAN;
        case 'i':
            return months.IYYAR;
        case 'e':
            return months.ELUL;
        case 'c':
        case 'ח':
            return months.CHESHVAN;
        case 'k':
        case 'כ':
            return months.KISLEV;
        case 's':
            switch (c[1]) {
                case 'i':
                    return months.SIVAN;
                case 'h':
                    return months.SHVAT;
            }
            break;
        case 't':
            switch (c[1]) {
                case 'a':
                    return months.TAMUZ;
                case 'i':
                    return months.TISHREI;
                case 'e':
                    return months.TEVET;
            }
            break;
        case 'a':
            switch (c[1]) {
                case 'v':
                    return months.AV;
                case 'd':
                    if (/(1|[^i]i|a|א)$/i.test(monthName)) {
                        return months.ADAR_I;
                    }
                    return months.ADAR_II; // else assume sheini
            }
            break;
        case 'ס':
            return months.SIVAN;
        case 'ט':
            return months.TEVET;
        case 'ש':
            return months.SHVAT;
        case 'א':
            switch (c[1]) {
                case 'ב':
                    return months.AV;
                case 'ד':
                    if (/(1|[^i]i|a|א)$/i.test(monthName)) {
                        return months.ADAR_I;
                    }
                    return months.ADAR_II; // else assume sheini
                case 'י':
                    return months.IYYAR;
                case 'ל':
                    return months.ELUL;
            }
            break;
        case 'ת':
            switch (c[1]) {
                case 'מ':
                    return months.TAMUZ;
                case 'ש':
                    return months.TISHREI;
            }
            break;
    }
    throw new RangeError(`Unable to parse month name: ${monthName}`);
}

const NISAN$3 = months.NISAN;
const CHESHVAN = months.CHESHVAN;
const KISLEV$1 = months.KISLEV;
const TEVET$1 = months.TEVET;
const SHVAT = months.SHVAT;
const ADAR_I$1 = months.ADAR_I;
const ADAR_II$1 = months.ADAR_II;
/**
 * Returns true if the object is a Javascript Date
 * @private
 * @param {Object} obj
 */
function isSimpleHebrewDate(obj) {
    return typeof obj === 'object' && obj !== null &&
        typeof obj.yy === 'number' &&
        typeof obj.mm === 'number' &&
        typeof obj.dd === 'number';
}
/**
 * @private
 */
function toSimpleHebrewDate(obj) {
    if (isSimpleHebrewDate(obj)) {
        return obj;
    }
    else if (typeof obj === 'number') {
        return abs2hebrew(obj);
    }
    else if (greg.isDate(obj)) {
        const abs = greg.greg2abs(obj);
        return abs2hebrew(abs);
    }
    else {
        throw new TypeError(`Argument not a Date: ${obj}`);
    }
}
function getYahrzeitHD(hyear, date) {
    let hDeath = toSimpleHebrewDate(date);
    if (hyear <= hDeath.yy) {
        // Hebrew year ${hyear} occurs on or before original date in ${hDeath.yy}
        return undefined;
    }
    if (hDeath.mm == CHESHVAN && hDeath.dd == 30 && !longCheshvan(hDeath.yy + 1)) {
        // If it's Heshvan 30 it depends on the first anniversary;
        // if that was not Heshvan 30, use the day before Kislev 1.
        hDeath = abs2hebrew(hebrew2abs(hyear, KISLEV$1, 1) - 1);
    }
    else if (hDeath.mm == KISLEV$1 && hDeath.dd == 30 && shortKislev(hDeath.yy + 1)) {
        // If it's Kislev 30 it depends on the first anniversary;
        // if that was not Kislev 30, use the day before Teveth 1.
        hDeath = abs2hebrew(hebrew2abs(hyear, TEVET$1, 1) - 1);
    }
    else if (hDeath.mm == ADAR_II$1) {
        // If it's Adar II, use the same day in last month of year (Adar or Adar II).
        hDeath.mm = monthsInYear(hyear);
    }
    else if (hDeath.mm == ADAR_I$1 && hDeath.dd == 30 && !isLeapYear(hyear)) {
        // If it's the 30th in Adar I and year is not a leap year
        // (so Adar has only 29 days), use the last day in Shevat.
        hDeath.dd = 30;
        hDeath.mm = SHVAT;
    }
    // In all other cases, use the normal anniversary of the date of death.
    // advance day to rosh chodesh if needed
    if (hDeath.mm == CHESHVAN && hDeath.dd == 30 && !longCheshvan(hyear)) {
        hDeath.mm = KISLEV$1;
        hDeath.dd = 1;
    }
    else if (hDeath.mm == KISLEV$1 && hDeath.dd == 30 && shortKislev(hyear)) {
        hDeath.mm = TEVET$1;
        hDeath.dd = 1;
    }
    hDeath.yy = hyear;
    return hDeath;
}
function getBirthdayHD(hyear, date) {
    const orig = toSimpleHebrewDate(date);
    const origYear = orig.yy;
    if (hyear === origYear) {
        return orig;
    }
    else if (hyear < origYear) {
        // Hebrew year ${hyear} occurs on or before original date in ${origYear}
        return undefined;
    }
    const isOrigLeap = isLeapYear(origYear);
    let month = orig.mm;
    let day = orig.dd;
    if ((month == ADAR_I$1 && !isOrigLeap) || (month == ADAR_II$1 && isOrigLeap)) {
        month = monthsInYear(hyear);
    }
    else if (month == CHESHVAN && day == 30 && !longCheshvan(hyear)) {
        month = KISLEV$1;
        day = 1;
    }
    else if (month == KISLEV$1 && day == 30 && shortKislev(hyear)) {
        month = TEVET$1;
        day = 1;
    }
    else if (month == ADAR_I$1 && day == 30 && isOrigLeap && !isLeapYear(hyear)) {
        month = NISAN$3;
        day = 1;
    }
    return { yy: hyear, mm: month, dd: day };
}

const GERESH = '׳';
const GERSHAYIM = '״';
const alefbet = {
    'א': 1,
    'ב': 2,
    'ג': 3,
    'ד': 4,
    'ה': 5,
    'ו': 6,
    'ז': 7,
    'ח': 8,
    'ט': 9,
    'י': 10,
    'כ': 20,
    'ל': 30,
    'מ': 40,
    'נ': 50,
    'ס': 60,
    'ע': 70,
    'פ': 80,
    'צ': 90,
    'ק': 100,
    'ר': 200,
    'ש': 300,
    'ת': 400,
};
const heb2num = new Map();
const num2heb = new Map();
for (const [key, val] of Object.entries(alefbet)) {
    heb2num.set(key, val);
    num2heb.set(val, key);
}
function num2digits(num) {
    const digits = [];
    while (num > 0) {
        if (num === 15 || num === 16) {
            digits.push(9);
            digits.push(num - 9);
            break;
        }
        let incr = 100;
        let i;
        for (i = 400; i > num; i -= incr) {
            if (i === incr) {
                incr = incr / 10;
            }
        }
        digits.push(i);
        num -= i;
    }
    return digits;
}
/**
 * Converts a numerical value to a string of Hebrew letters.
 *
 * When specifying years of the Hebrew calendar in the present millennium,
 * we omit the thousands (which is presently 5 [ה]).
 * @example
 * gematriya(5774) // 'תשע״ד' - cropped to 774
 * gematriya(25) // 'כ״ה'
 * gematriya(60) // 'ס׳'
 * gematriya(3761) // 'ג׳תשס״א'
 * gematriya(1123) // 'א׳קכ״ג'
 * @param {number} num
 * @return {string}
 */
function gematriya(num) {
    const num0 = num;
    const num1 = parseInt(num0, 10);
    if (!num1) {
        throw new TypeError(`invalid parameter to gematriya ${num}`);
    }
    let str = '';
    const thousands = Math.floor(num1 / 1000);
    if (thousands > 0 && thousands !== 5) {
        const tdigits = num2digits(thousands);
        for (const tdig of tdigits) {
            str += num2heb.get(tdig);
        }
        str += GERESH;
    }
    const digits = num2digits(num1 % 1000);
    if (digits.length == 1) {
        return str + num2heb.get(digits[0]) + GERESH;
    }
    for (let i = 0; i < digits.length; i++) {
        if (i + 1 === digits.length) {
            str += GERSHAYIM;
        }
        str += num2heb.get(digits[i]);
    }
    return str;
}
/**
 * Converts a string of Hebrew letters to a numerical value.
 *
 * Only considers the value of Hebrew letters `א` through `ת`.
 * Ignores final Hebrew letters such as `ך` (kaf sofit) or `ם` (mem sofit)
 * and vowels (nekudot).
 *
 * @param {string} str
 * @return {number}
 */
function gematriyaStrToNum(str) {
    let num = 0;
    const gereshIdx = str.indexOf(GERESH);
    if (gereshIdx !== -1 && gereshIdx !== str.length - 1) {
        const thousands = str.substring(0, gereshIdx);
        num += gematriyaStrToNum(thousands) * 1000;
        str = str.substring(gereshIdx);
    }
    for (const ch of str) {
        const n = heb2num.get(ch);
        if (typeof n === 'number') {
            num += n;
        }
    }
    return num;
}

const noopLocale = {
  headers: {
    'plural-forms': 'nplurals=2; plural=(n!=1);'
  },
  contexts: {
    '': {}
  }
};
const alias = {
  'h': 'he',
  'a': 'ashkenazi',
  's': 'en',
  '': 'en'
};

/** @private */
const locales = new Map();
/** @private */
let activeLocale = null;
/** @private */
let activeName = null;

/**
 * A locale in Hebcal is used for translations/transliterations of
 * holidays. `@hebcal/core` supports four locales by default
 * * `en` - default, Sephardic transliterations (e.g. "Shabbat")
 * * `ashkenazi` - Ashkenazi transliterations (e.g. "Shabbos")
 * * `he` - Hebrew (e.g. "שַׁבָּת")
 * * `he-x-NoNikud` - Hebrew without nikud (e.g. "שבת")
 */
class Locale {
  /**
   * Returns translation only if `locale` offers a non-empty translation for `id`.
   * Otherwise, returns `undefined`.
   * @param {string} id Message ID to translate
   * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   * @return {string}
   */
  static lookupTranslation(id, locale) {
    const locale0 = locale === null || locale === void 0 ? void 0 : locale.toLowerCase();
    const loc = typeof locale == 'string' && locales.get(locale0) || activeLocale;
    const array = loc[id];
    if (array !== null && array !== void 0 && array.length && array[0].length) {
      return array[0];
    }
    return undefined;
  }

  /**
   * By default, if no translation was found, returns `id`.
   * @param {string} id Message ID to translate
   * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   * @return {string}
   */
  static gettext(id, locale) {
    const text = this.lookupTranslation(id, locale);
    if (typeof text == 'undefined') {
      return id;
    }
    return text;
  }

  /**
   * Register locale translations.
   * @param {string} locale Locale name (i.e.: `'he'`, `'fr'`)
   * @param {LocaleData} data parsed data from a `.po` file.
   */
  static addLocale(locale, data) {
    if (typeof locale !== 'string') {
      throw new TypeError(`Invalid locale name: ${locale}`);
    }
    if (typeof data.contexts !== 'object' || typeof data.contexts[''] !== 'object') {
      throw new TypeError(`Locale '${locale}' invalid compact format`);
    }
    locales.set(locale.toLowerCase(), data.contexts['']);
  }

  /**
   * Adds a translation to `locale`, replacing any previous translation.
   * @param {string} locale Locale name (i.e: `'he'`, `'fr'`).
   * @param {string} id Message ID to translate
   * @param {string} translation Translation text
   */
  static addTranslation(locale, id, translation) {
    if (typeof locale !== 'string') {
      throw new TypeError(`Invalid locale name: ${locale}`);
    }
    const locale0 = locale.toLowerCase();
    const loc = locales.get(locale0);
    if (!loc) {
      throw new TypeError(`Unknown locale: ${locale}`);
    }
    if (typeof id !== 'string' || id.length === 0) {
      throw new TypeError(`Invalid id: ${id}`);
    }
    const isArray = Array.isArray(translation);
    if (isArray) {
      const t0 = translation[0];
      if (typeof t0 !== 'string' || t0.length === 0) {
        throw new TypeError(`Invalid translation array: ${translation}`);
      }
    } else if (typeof translation !== 'string') {
      throw new TypeError(`Invalid translation: ${translation}`);
    }
    loc[id] = isArray ? translation : [translation];
  }
  /**
   * Adds multiple translations to `locale`, replacing any previous translations.
   * @param {string} locale Locale name (i.e: `'he'`, `'fr'`).
   * @param {LocaleData} data parsed data from a `.po` file.
   */
  static addTranslations(locale, data) {
    if (typeof locale !== 'string') {
      throw new TypeError(`Invalid locale name: ${locale}`);
    }
    const locale0 = locale.toLowerCase();
    const loc = locales.get(locale0);
    if (!loc) {
      throw new TypeError(`Unknown locale: ${locale}`);
    }
    if (typeof data.contexts !== 'object' || typeof data.contexts[''] !== 'object') {
      throw new TypeError(`Locale '${locale}' invalid compact format`);
    }
    const ctx = data.contexts[''];
    Object.assign(loc, ctx);
  }
  /**
   * Activates a locale. Throws an error if the locale has not been previously added.
   * After setting the locale to be used, all strings marked for translations
   * will be represented by the corresponding translation in the specified locale.
   * @param {string} locale Locale name (i.e: `'he'`, `'fr'`)
   * @return {LocaleData}
   */
  static useLocale(locale) {
    const locale0 = locale.toLowerCase();
    const obj = locales.get(locale0);
    if (!obj) {
      throw new RangeError(`Locale '${locale}' not found`);
    }
    activeName = alias[locale0] || locale0;
    activeLocale = obj;
    return activeLocale;
  }

  /**
   * Returns the name of the active locale (i.e. 'he', 'ashkenazi', 'fr')
   * @return {string}
   */
  static getLocaleName() {
    return activeName;
  }

  /**
   * Returns the names of registered locales
   * @return {string[]}
   */
  static getLocaleNames() {
    const keys = Array.from(locales.keys());
    return keys.sort((a, b) => a.localeCompare(b));
  }

  /**
   * @param {number} n
   * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   * @return {string}
   */
  static ordinal(n, locale) {
    const locale1 = locale === null || locale === void 0 ? void 0 : locale.toLowerCase();
    const locale0 = locale1 || activeName;
    if (!locale0) {
      return this.getEnOrdinal(n);
    }
    switch (locale0) {
      case 'en':
      case 's':
      case 'a':
      case 'ashkenazi':
      case 'ashkenazi_litvish':
      case 'ashkenazi_poylish':
      case 'ashkenazi_standard':
        return this.getEnOrdinal(n);
      case 'es':
        return n + 'º';
      case 'h':
      case 'he':
      case 'he-x-nonikud':
        return String(n);
      default:
        return n + '.';
    }
  }

  /**
   * @private
   * @param {number} n
   * @return {string}
   */
  static getEnOrdinal(n) {
    const s = ['th', 'st', 'nd', 'rd'];
    const v = n % 100;
    return n + (s[(v - 20) % 10] || s[v] || s[0]);
  }

  /**
   * Removes nekudot from Hebrew string
   * @param {string} str
   * @return {string}
   */
  static hebrewStripNikkud(str) {
    return str.replace(/[\u0590-\u05bd]/g, '').replace(/[\u05bf-\u05c7]/g, '');
  }
}
Locale.addLocale('en', noopLocale);
Locale.addLocale('s', noopLocale);
Locale.addLocale('', noopLocale);
Locale.useLocale('en');

/**
 * @private
 * @param {string} msg
 */
function throwTypeError(msg) {
  throw new TypeError(msg);
}

/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

// eslint-disable-next-line require-jsdoc
function mod(x, y) {
  return x - y * Math.floor(x / y);
}
const UNITS_DAY = 'day';
const UNITS_WEEK = 'week';
const UNITS_MONTH = 'month';
const UNITS_YEAR = 'year';
const UNITS_SINGLE = {
  d: UNITS_DAY,
  w: UNITS_WEEK,
  M: UNITS_MONTH,
  y: UNITS_YEAR
};
const UNITS_VALID = {
  day: UNITS_DAY,
  week: UNITS_WEEK,
  month: UNITS_MONTH,
  year: UNITS_YEAR
};

/**
 * A simple Hebrew date object with numeric fields `yy`, `mm`, and `dd`
 * @typedef {Object} SimpleHebrewDate
 * @property {number} yy Hebrew year
 * @property {number} mm Hebrew month of year (1=NISAN, 7=TISHREI)
 * @property {number} dd Day of month (1-30)
 * @private
 */

/** Represents a Hebrew date */
class HDate {
  /**
   * Create a Hebrew date. There are 3 basic forms for the `HDate()` constructor.
   *
   * 1. No parameters - represents the current Hebrew date at time of instantiation
   * 2. One parameter
   *    * `Date` - represents the Hebrew date corresponding to the Gregorian date using
   *       local time. Hours, minutes, seconds and milliseconds are ignored.
   *    * `HDate` - clones a copy of the given Hebrew date
   *    * `number` - Converts absolute R.D. days to Hebrew date.
   *       R.D. 1 == the imaginary date January 1, 1 (Gregorian)
   * 3. Three parameters: Hebrew day, Hebrew month, Hebrew year. Hebrew day should
   *    be a number between 1-30, Hebrew month can be a number or string, and
   *    Hebrew year is always a number.
   * @example
   * import {HDate, months} from '@hebcal/core';
   *
   * const hd1 = new HDate();
   * const hd2 = new HDate(new Date(2008, 10, 13));
   * const hd3 = new HDate(15, 'Cheshvan', 5769);
   * const hd4 = new HDate(15, months.CHESHVAN, 5769);
   * const hd5 = new HDate(733359); // ==> 15 Cheshvan 5769
   * const monthName = 'אייר';
   * const hd6 = new HDate(5, monthName, 5773);
   * @param {number|Date|HDate} [day] - Day of month (1-30) if a `number`.
   *   If a `Date` is specified, represents the Hebrew date corresponding to the
   *   Gregorian date using local time.
   *   If an `HDate` is specified, clones a copy of the given Hebrew date.
   * @param {number|string} [month] - Hebrew month of year (1=NISAN, 7=TISHREI)
   * @param {number} [year] - Hebrew year
   */
  constructor(day, month, year) {
    if (arguments.length == 2 || arguments.length > 3) {
      throw new TypeError('HDate constructor requires 0, 1 or 3 arguments');
    }
    if (arguments.length == 3) {
      // Hebrew day, Hebrew month, Hebrew year
      /**
       * @private
       * @type {number}
       */
      this.dd = this.mm = 1;
      /**
       * @private
       * @type {number}
       */
      year = parseInt(year, 10);
      if (isNaN(year)) {
        throw new TypeError(`HDate called with bad year argument: ${year}`);
      }
      this.yy = year;
      this.setMonth(month); // will throw if we can't parse
      day = parseInt(day, 10);
      if (isNaN(day)) {
        throw new TypeError(`HDate called with bad day argument: ${day}`);
      }
      this.setDate(day);
    } else {
      // 0 arguments
      if (typeof day === 'undefined' || day === null) {
        day = new Date();
      }
      // 1 argument
      const abs0 = typeof day === 'number' && !isNaN(day) ? day : greg.isDate(day) ? greg.greg2abs(day) : typeof day.yy === 'number' && typeof day.mm === 'number' && typeof day.dd === 'number' ? day : throwTypeError(`HDate called with bad argument: ${day}`);
      const isNumber = typeof abs0 === 'number';
      const d = isNumber ? abs2hebrew(abs0) : abs0;
      /**
       * @private
       * @type {number}
       */
      this.dd = d.dd;
      /**
       * @private
       * @type {number}
       */
      this.mm = d.mm;
      /**
       * @private
       * @type {number}
       */
      this.yy = d.yy;
      if (isNumber) {
        /**
         * @private
         * @type {number}
         */
        this.rd = abs0;
      }
    }
  }

  /**
   * Gets the Hebrew year of this Hebrew date
   * @return {number}
   */
  getFullYear() {
    return this.yy;
  }

  /**
   * Tests if this date occurs during a leap year
   * @return {boolean}
   */
  isLeapYear() {
    return isLeapYear(this.yy);
  }

  /**
   * Gets the Hebrew month (1=NISAN, 7=TISHREI) of this Hebrew date
   * @return {number}
   */
  getMonth() {
    return this.mm;
  }

  /**
   * The Tishrei-based month of the date. 1 is Tishrei, 7 is Nisan, 13 is Elul in a leap year
   * @return {number}
   */
  getTishreiMonth() {
    const nummonths = monthsInYear(this.getFullYear());
    return (this.getMonth() + nummonths - 6) % nummonths || nummonths;
  }

  /**
   * Number of days in the month of this Hebrew date
   * @return {number}
   */
  daysInMonth() {
    return daysInMonth(this.getMonth(), this.getFullYear());
  }

  /**
   * Gets the day within the month (1-30)
   * @return {number}
   */
  getDate() {
    return this.dd;
  }

  /**
   * Gets the day of the week. 0=Sunday, 6=Saturday
   * @return {number}
   */
  getDay() {
    return mod(this.abs(), 7);
  }

  /**
   * Sets the day of the month of the date. Returns the object it was called upon
   * @private
   * @param {number|string} month A number, or Hebrew month name string
   * @return {HDate}
   */
  setMonth(month) {
    this.mm = HDate.monthNum(month);
    fix(this);
    return this;
  }

  /**
   * @private
   * @param {number} date
   * @return {HDate}
   */
  setDate(date) {
    this.dd = date;
    fix(this);
    return this;
  }

  /**
   * Converts to Gregorian date
   * @return {Date}
   */
  greg() {
    return greg.abs2greg(this.abs());
  }

  /**
   * Returns R.D. (Rata Die) fixed days.
   * R.D. 1 == Monday, January 1, 1 (Gregorian)
   * Note also that R.D. = Julian Date − 1,721,424.5
   * https://en.wikipedia.org/wiki/Rata_Die#Dershowitz_and_Reingold
   * @return {number}
   */
  abs() {
    if (typeof this.rd !== 'number') {
      this.rd = hebrew2abs(this.yy, this.mm, this.dd);
    }
    return this.rd;
  }

  /**
   * Converts Hebrew date to R.D. (Rata Die) fixed days.
   * R.D. 1 is the imaginary date Monday, January 1, 1 on the Gregorian
   * Calendar.
   * @param {number} year Hebrew year
   * @param {number} month Hebrew month
   * @param {number} day Hebrew date (1-30)
   * @return {number}
   */
  static hebrew2abs(year, month, day) {
    return hebrew2abs(year, month, day);
  }

  /**
   * Returns a transliterated Hebrew month name, e.g. `'Elul'` or `'Cheshvan'`.
   * @return {string}
   */
  getMonthName() {
    return getMonthName(this.getMonth(), this.getFullYear());
  }

  /**
   * Renders this Hebrew date as a translated or transliterated string,
   * including ordinal e.g. `'15th of Cheshvan, 5769'`.
   * @example
   * import {HDate, months} from '@hebcal/core';
   *
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * console.log(hd.render('en')); // '15th of Cheshvan, 5769'
   * console.log(hd.render('he')); // '15 חֶשְׁוָן, 5769'
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @param {boolean} [showYear=true] Display year (defaults to true).
   * @return {string}
   */
  render(locale = null, showYear = true) {
    const locale0 = locale || Locale.getLocaleName();
    const day = this.getDate();
    const monthName0 = Locale.gettext(this.getMonthName(), locale0);
    const monthName = monthName0.replace(/'/g, '’');
    const nth = Locale.ordinal(day, locale0);
    const dayOf = HDate.getDayOfTranslation(locale0);
    const dateStr = `${nth}${dayOf} ${monthName}`;
    if (showYear) {
      const fullYear = this.getFullYear();
      return `${dateStr}, ${fullYear}`;
    } else {
      return dateStr;
    }
  }

  /**
   * @private
   * @param {string} locale
   * @return {string}
   */
  static getDayOfTranslation(locale) {
    switch (locale) {
      case 'en':
      case 's':
      case 'a':
      case 'ashkenazi':
        return ' of';
    }
    const ofStr = Locale.lookupTranslation('of', locale);
    if (ofStr) {
      return ' ' + ofStr;
    }
    if (locale.startsWith('ashkenazi')) {
      return ' of';
    }
    return '';
  }

  /**
   * Renders this Hebrew date in Hebrew gematriya, regardless of locale.
   * @example
   * import {HDate, months} from '@hebcal/core';
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * console.log(hd.renderGematriya()); // 'ט״ו חֶשְׁוָן תשס״ט'
   * @param {boolean} [suppressNikud]
   * @return {string}
   */
  renderGematriya(suppressNikud = false) {
    const d = this.getDate();
    const locale = suppressNikud ? 'he-x-NoNikud' : 'he';
    const m = Locale.gettext(this.getMonthName(), locale);
    const y = this.getFullYear();
    return gematriya(d) + ' ' + m + ' ' + gematriya(y);
  }

  /**
   * Returns an `HDate` representing the a dayNumber before the current date.
   * Sunday=0, Saturday=6
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).before(6).greg() // Sat Feb 15 2014
   * @param {number} day day of week
   * @return {HDate}
   */
  before(day) {
    return onOrBefore(day, this, -1);
  }

  /**
   * Returns an `HDate` representing the a dayNumber on or before the current date.
   * Sunday=0, Saturday=6
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).onOrBefore(6).greg() // Sat Feb 15 2014
   * new HDate(new Date('Saturday February 22, 2014')).onOrBefore(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Sunday February 23, 2014')).onOrBefore(6).greg() // Sat Feb 22 2014
   * @param {number} dow day of week
   * @return {HDate}
   */
  onOrBefore(dow) {
    return onOrBefore(dow, this, 0);
  }

  /**
   * Returns an `HDate` representing the nearest dayNumber to the current date
   * Sunday=0, Saturday=6
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).nearest(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Tuesday February 18, 2014')).nearest(6).greg() // Sat Feb 15 2014
   * @param {number} dow day of week
   * @return {HDate}
   */
  nearest(dow) {
    return onOrBefore(dow, this, 3);
  }

  /**
   * Returns an `HDate` representing the a dayNumber on or after the current date.
   * Sunday=0, Saturday=6
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).onOrAfter(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Saturday February 22, 2014')).onOrAfter(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Sunday February 23, 2014')).onOrAfter(6).greg() // Sat Mar 01 2014
   * @param {number} dow day of week
   * @return {HDate}
   */
  onOrAfter(dow) {
    return onOrBefore(dow, this, 6);
  }

  /**
   * Returns an `HDate` representing the a dayNumber after the current date.
   * Sunday=0, Saturday=6
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).after(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Saturday February 22, 2014')).after(6).greg() // Sat Mar 01 2014
   * new HDate(new Date('Sunday February 23, 2014')).after(6).greg() // Sat Mar 01 2014
   * @param {number} day day of week
   * @return {HDate}
   */
  after(day) {
    return onOrBefore(day, this, 7);
  }

  /**
   * Returns the next Hebrew date
   * @return {HDate}
   */
  next() {
    return new HDate(this.abs() + 1);
  }

  /**
   * Returns the previous Hebrew date
   * @return {HDate}
   */
  prev() {
    return new HDate(this.abs() - 1);
  }

  /**
   * Returns a cloned `HDate` object with a specified amount of time added
   *
   * Units are case insensitive, and support plural and short forms.
   * Note, short forms are case sensitive.
   *
   * | Unit | Shorthand | Description
   * | --- | --- | --- |
   * | `day` | `d` | days |
   * | `week` | `w` | weeks |
   * | `month` | `M` | months |
   * | `year` | `y` | years |
   * @param {number} number
   * @param {string} [units]
   * @return {HDate}
   */
  add(number, units = 'd') {
    number = parseInt(number, 10);
    if (!number) {
      return new HDate(this);
    }
    units = HDate.standardizeUnits(units);
    if (units === UNITS_DAY) {
      return new HDate(this.abs() + number);
    } else if (units === UNITS_WEEK) {
      return new HDate(this.abs() + 7 * number);
    } else if (units === UNITS_YEAR) {
      return new HDate(this.getDate(), this.getMonth(), this.getFullYear() + number);
    } else if (units === UNITS_MONTH) {
      let hd = new HDate(this);
      const sign = number > 0 ? 1 : -1;
      number = Math.abs(number);
      for (let i = 0; i < number; i++) {
        hd = new HDate(hd.abs() + sign * hd.daysInMonth());
      }
      return hd;
    }
  }

  /**
   * @private
   * @param {string} units
   * @return {string}
   */
  static standardizeUnits(units) {
    const full = UNITS_SINGLE[units] || String(units || '').toLowerCase().replace(/s$/, '');
    return UNITS_VALID[full] || throwTypeError(`Invalid units '${units}'`);
  }

  /**
   * Returns a cloned `HDate` object with a specified amount of time subracted
   *
   * Units are case insensitive, and support plural and short forms.
   * Note, short forms are case sensitive.
   *
   * | Unit | Shorthand | Description
   * | --- | --- | --- |
   * | `day` | `d` | days |
   * | `week` | `w` | weeks |
   * | `month` | `M` | months |
   * | `year` | `y` | years |
   * @example
   * import {HDate, months} from '@hebcal/core';
   *
   * const hd1 = new HDate(15, months.CHESHVAN, 5769);
   * const hd2 = hd1.add(1, 'weeks'); // 7 Kislev 5769
   * const hd3 = hd1.add(-3, 'M'); // 30 Av 5768
   * @param {number} number
   * @param {string} [units]
   * @return {HDate}
   */
  subtract(number, units = 'd') {
    return this.add(number * -1, units);
  }

  /**
   * Returns the difference in days between the two given HDates.
   *
   * The result is positive if `this` date is comes chronologically
   * after the `other` date, and negative
   * if the order of the two dates is reversed.
   *
   * The result is zero if the two dates are identical.
   * @example
   * import {HDate, months} from '@hebcal/core';
   *
   * const hd1 = new HDate(25, months.KISLEV, 5770);
   * const hd2 = new HDate(15, months.CHESHVAN, 5769);
   * const days = hd1.deltaDays(hd2); // 394
   * @param {HDate} other Hebrew date to compare
   * @return {number}
   */
  deltaDays(other) {
    if (!HDate.isHDate(other)) {
      throw new TypeError(`Bad argument: ${other}`);
    }
    return this.abs() - other.abs();
  }

  /**
   * Compares this date to another date, returning `true` if the dates match.
   * @param {HDate} other Hebrew date to compare
   * @return {boolean}
   */
  isSameDate(other) {
    if (HDate.isHDate(other)) {
      return this.yy == other.yy && this.mm == other.mm && this.dd == other.dd;
    }
    return false;
  }

  /** @return {string} */
  toString() {
    const day = this.getDate();
    const fullYear = this.getFullYear();
    const monthName = this.getMonthName();
    return `${day} ${monthName} ${fullYear}`;
  }

  /**
   * Returns true if Hebrew year is a leap year
   * @param {number} year Hebrew year
   * @return {boolean}
   */
  static isLeapYear(year) {
    return isLeapYear(year);
  }

  /**
   * Number of months in this Hebrew year (either 12 or 13 depending on leap year)
   * @param {number} year Hebrew year
   * @return {number}
   */
  static monthsInYear(year) {
    return monthsInYear(year);
  }

  /**
   * Number of days in Hebrew month in a given year (29 or 30)
   * @param {number} month Hebrew month (e.g. months.TISHREI)
   * @param {number} year Hebrew year
   * @return {number}
   */
  static daysInMonth(month, year) {
    return daysInMonth(month, year);
  }

  /**
   * Returns a transliterated string name of Hebrew month in year,
   * for example 'Elul' or 'Cheshvan'.
   * @param {number} month Hebrew month (e.g. months.TISHREI)
   * @param {number} year Hebrew year
   * @return {string}
   */
  static getMonthName(month, year) {
    return getMonthName(month, year);
  }

  /**
   * Returns the Hebrew month number (NISAN=1, TISHREI=7)
   * @param {number|string} month A number, or Hebrew month name string
   * @return {number}
   */
  static monthNum(month) {
    if (typeof month === 'number') {
      if (isNaN(month) || month > 14) {
        throw new RangeError(`Invalid month number: ${month}`);
      }
      return month;
    }
    return month.charCodeAt(0) >= 48 && month.charCodeAt(0) <= 57 ? /* number */
    parseInt(month, 10) : HDate.monthFromName(month);
  }

  /**
   * Number of days in the hebrew YEAR
   * @param {number} year Hebrew year
   * @return {number}
   */
  static daysInYear(year) {
    return daysInYear(year);
  }

  /**
   * true if Cheshvan is long in Hebrew year
   * @param {number} year Hebrew year
   * @return {boolean}
   */
  static longCheshvan(year) {
    return longCheshvan(year);
  }

  /**
   * true if Kislev is short in Hebrew year
   * @param {number} year Hebrew year
   * @return {boolean}
   */
  static shortKislev(year) {
    return shortKislev(year);
  }

  /**
   * Converts Hebrew month string name to numeric
   * @param {string|number} monthName monthName
   * @return {number}
   */
  static monthFromName(monthName) {
    if (typeof monthName === 'number') {
      if (isNaN(monthName) || monthName < 1 || monthName > 14) {
        throw new RangeError(`Invalid month name: ${monthName}`);
      }
      return monthName;
    }
    const name = Locale.hebrewStripNikkud(monthName);
    return monthFromName(name);
  }

  /**
   * Note: Applying this function to d+6 gives us the DAYNAME on or after an
   * absolute day d. Similarly, applying it to d+3 gives the DAYNAME nearest to
   * absolute date d, applying it to d-1 gives the DAYNAME previous to absolute
   * date d, and applying it to d+7 gives the DAYNAME following absolute date d.
   * @param {number} dayOfWeek
   * @param {number} absdate
   * @return {number}
   */
  static dayOnOrBefore(dayOfWeek, absdate) {
    return absdate - (absdate - dayOfWeek) % 7;
  }

  /**
   * Tests if the object is an instance of `HDate`
   * @param {any} obj
   * @return {boolean}
   */
  static isHDate(obj) {
    return obj !== null && typeof obj === 'object' && typeof obj.yy === 'number' && typeof obj.mm === 'number' && typeof obj.dd === 'number' && typeof obj.greg === 'function' && typeof obj.abs === 'function';
  }

  /**
   * Construct a new instance of `HDate` from a Gematriya-formatted string
   * @example
   *  HDate.fromGematriyaString('כ״ז בְּתַמּוּז תשפ״ג') // 27 Tamuz 5783
   *  HDate.fromGematriyaString('כ׳ סיון תש״ד') // 20 Sivan 5704
   *  HDate.fromGematriyaString('ה׳ אִיָיר תש״ח') // 5 Iyyar 5708
   * @param {string} str
   * @param {number} currentThousands
   * @return {HDate}
   */
  static fromGematriyaString(str, currentThousands = 5000) {
    const parts = str.split(' ');
    const day = gematriyaStrToNum(parts[0]);
    const month = HDate.monthFromName(parts[1]);
    let year = gematriyaStrToNum(parts[2]);
    if (year < 1000) {
      year += currentThousands;
    }
    return new HDate(day, month, year);
  }
}

/**
 * @private
 * @param {HDate} date
 */
function fix(date) {
  fixMonth(date);
  fixDate(date);
}

/**
 * @private
 * @param {HDate} date
 */
function fixDate(date) {
  if (date.dd < 1) {
    if (date.mm == months.TISHREI) {
      date.yy -= 1;
    }
    date.dd += daysInMonth(date.mm, date.yy);
    date.mm -= 1;
    fix(date);
  }
  if (date.dd > daysInMonth(date.mm, date.yy)) {
    if (date.mm === months.ELUL) {
      date.yy += 1;
    }
    date.dd -= daysInMonth(date.mm, date.yy);
    date.mm += 1;
    fix(date);
  }
  fixMonth(date);
}

/**
 * @private
 * @param {HDate} date
 */
function fixMonth(date) {
  if (date.mm === months.ADAR_II && !date.isLeapYear()) {
    date.mm -= 1; // to Adar I
    fix(date);
  } else if (date.mm < 1) {
    date.mm += monthsInYear(date.yy);
    date.yy -= 1;
    fix(date);
  } else if (date.mm > monthsInYear(date.yy)) {
    date.mm -= monthsInYear(date.yy);
    date.yy += 1;
    fix(date);
  }
  delete date.rd;
}

/**
 * @private
 * @param {number} day
 * @param {HDate} t
 * @param {number} offset
 * @return {HDate}
 */
function onOrBefore(day, t, offset) {
  return new HDate(HDate.dayOnOrBefore(day, t.abs() + offset));
}

/**
 * Holiday flags for Event
 * @readonly
 * @enum {number}
 */
const flags = {
  /** Chag, yontiff, yom tov */
  CHAG: 0x000001,
  /** Light candles 18 minutes before sundown */
  LIGHT_CANDLES: 0x000002,
  /** End of holiday (end of Yom Tov)  */
  YOM_TOV_ENDS: 0x000004,
  /** Observed only in the Diaspora (chutz l'aretz)  */
  CHUL_ONLY: 0x000008,
  /** Observed only in Israel */
  IL_ONLY: 0x000010,
  /** Light candles in the evening at Tzeit time (3 small stars) */
  LIGHT_CANDLES_TZEIS: 0x000020,
  /** Candle-lighting for Chanukah */
  CHANUKAH_CANDLES: 0x000040,
  /** Rosh Chodesh, beginning of a new Hebrew month */
  ROSH_CHODESH: 0x000080,
  /** Minor fasts like Tzom Tammuz, Ta'anit Esther, ... */
  MINOR_FAST: 0x000100,
  /** Shabbat Shekalim, Zachor, ... */
  SPECIAL_SHABBAT: 0x000200,
  /** Weekly sedrot on Saturdays */
  PARSHA_HASHAVUA: 0x000400,
  /** Daily page of Talmud (Bavli) */
  DAF_YOMI: 0x000800,
  /** Days of the Omer */
  OMER_COUNT: 0x001000,
  /** Yom HaShoah, Yom HaAtzma'ut, ... */
  MODERN_HOLIDAY: 0x002000,
  /** Yom Kippur and Tish'a B'Av */
  MAJOR_FAST: 0x004000,
  /** On the Saturday before Rosh Chodesh */
  SHABBAT_MEVARCHIM: 0x008000,
  /** Molad */
  MOLAD: 0x010000,
  /** Yahrzeit or Hebrew Anniversary */
  USER_EVENT: 0x020000,
  /** Daily Hebrew date ("11th of Sivan, 5780") */
  HEBREW_DATE: 0x040000,
  /** A holiday that's not major, modern, rosh chodesh, or a fast day */
  MINOR_HOLIDAY: 0x080000,
  /** Evening before a major or minor holiday */
  EREV: 0x100000,
  /** Chol haMoed, intermediate days of Pesach or Sukkot */
  CHOL_HAMOED: 0x200000,
  /** Mishna Yomi */
  MISHNA_YOMI: 0x400000,
  /** Yom Kippur Katan, minor day of atonement on the day preceeding each Rosh Chodesh */
  YOM_KIPPUR_KATAN: 0x800000,
  /** Daily page of Jerusalem Talmud (Yerushalmi) */
  YERUSHALMI_YOMI: 0x1000000,
  /** Nach Yomi */
  NACH_YOMI: 0x2000000
};
const flagToCategory = [[flags.MAJOR_FAST, 'holiday', 'major', 'fast'], [flags.CHANUKAH_CANDLES, 'holiday', 'major'], [flags.HEBREW_DATE, 'hebdate'], [flags.MINOR_FAST, 'holiday', 'fast'], [flags.MINOR_HOLIDAY, 'holiday', 'minor'], [flags.MODERN_HOLIDAY, 'holiday', 'modern'], [flags.MOLAD, 'molad'], [flags.OMER_COUNT, 'omer'], [flags.PARSHA_HASHAVUA, 'parashat'],
// backwards-compat
[flags.ROSH_CHODESH, 'roshchodesh'], [flags.SHABBAT_MEVARCHIM, 'mevarchim'], [flags.SPECIAL_SHABBAT, 'holiday', 'shabbat'], [flags.USER_EVENT, 'user']];

/** Represents an Event with a title, date, and flags */
class Event {
  /**
   * Constructs Event
   * @param {HDate} date Hebrew date event occurs
   * @param {string} desc Description (not translated)
   * @param {number} [mask=0] optional bitmask of holiday flags (see {@link flags})
   * @param {Object} [attrs={}] optional additional attributes (e.g. `eventTimeStr`, `cholHaMoedDay`)
   */
  constructor(date, desc, mask, attrs) {
    this.date = date;
    this.desc = desc;
    this.mask = +mask;
    if (typeof attrs === 'object' && attrs !== null) {
      Object.assign(this, attrs);
    }
  }
  /**
   * Hebrew date of this event
   * @return {HDate}
   */
  getDate() {
    return this.date;
  }
  /**
   * Untranslated description of this event
   * @return {string}
   */
  getDesc() {
    return this.desc;
  }
  /**
   * Bitmask of optional event flags. See {@link flags}
   * @return {number}
   */
  getFlags() {
    return this.mask;
  }
  /**
   * Returns (translated) description of this event
   * @example
   * const ev = new Event(new HDate(6, 'Sivan', 5749), 'Shavuot', flags.CHAG);
   * ev.render('en'); // 'Shavuot'
   * ev.render('he'); // 'שָׁבוּעוֹת'
   * ev.render('ashkenazi'); // 'Shavuos'
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    return Locale.gettext(this.desc, locale);
  }
  /**
   * Returns a brief (translated) description of this event.
   * For most events, this is the same as render(). For some events, it procudes
   * a shorter text (e.g. without a time or added description).
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    return this.render(locale);
  }
  /**
   * Optional holiday-specific Emoji or `null`.
   * @return {string}
   */
  getEmoji() {
    return this.emoji || null;
  }
  /**
   * Returns a simplified (untranslated) description for this event. For example,
   * the {@link HolidayEvent} class supports
   * "Erev Pesach" => "Pesach", and "Sukkot III (CH''M)" => "Sukkot".
   * For many holidays the basename and the event description are the same.
   * @return {string}
   */
  basename() {
    return this.getDesc();
  }
  /**
   * Returns a URL to hebcal.com or sefaria.org for more detail on the event.
   * Returns `undefined` for events with no detail page.
   * @return {string}
   */
  url() {
    return undefined;
  }
  /**
   * Is this event observed in Israel?
   * @example
   * const ev1 = new Event(new HDate(7, 'Sivan', 5749), 'Shavuot II', flags.CHAG | flags.CHUL_ONLY);
   * ev1.observedInIsrael(); // false
   * const ev2 = new Event(new HDate(26, 'Kislev', 5749), 'Chanukah: 3 Candles', 0);
   * ev2.observedInIsrael(); // true
   * @return {boolean}
   */
  observedInIsrael() {
    return !(this.mask & flags.CHUL_ONLY);
  }
  /**
   * Is this event observed in the Diaspora?
   * @example
   * const ev1 = new Event(new HDate(7, 'Sivan', 5749), 'Shavuot II', flags.CHAG | flags.CHUL_ONLY);
   * ev1.observedInDiaspora(); // true
   * const ev2 = new Event(new HDate(26, 'Kislev', 5749), 'Chanukah: 3 Candles', 0);
   * ev2.observedInDiaspora(); // true
   * @return {boolean}
   */
  observedInDiaspora() {
    return !(this.mask & flags.IL_ONLY);
  }
  /**
   * Is this event observed in Israel/Diaspora?
   * @example
   * const ev1 = new Event(new HDate(7, 'Sivan', 5749), 'Shavuot II', flags.CHAG | flags.CHUL_ONLY);
   * ev1.observedIn(false); // true
   * ev1.observedIn(true); // false
   * const ev2 = new Event(new HDate(26, 'Kislev', 5749), 'Chanukah: 3 Candles', 0);
   * ev2.observedIn(false); // true
   * ev2.observedIn(true); // true
   * @param {boolean} il
   * @return {boolean}
   */
  observedIn(il) {
    return il ? this.observedInIsrael() : this.observedInDiaspora();
  }
  /**
   * Makes a clone of this Event object
   * @return {Event}
   */
  clone() {
    const ev = new this.constructor();
    for (const property in this) {
      if (this.hasOwnProperty(property)) {
        ev[property] = this[property];
      }
    }
    return ev;
  }
  /**
   * Returns a list of event categories
   * @return {string[]}
   */
  getCategories() {
    const mask = this.getFlags();
    for (const attrs of flagToCategory) {
      if (mask & attrs[0]) {
        return attrs.slice(1);
      }
    }
    return ['unknown'];
  }
}

/** Daily Hebrew date ("11th of Sivan, 5780") */
class HebrewDateEvent extends Event {
  /**
   * @param {HDate} date
   */
  constructor(date) {
    super(date, date.toString(), flags.HEBREW_DATE);
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @example
   * import {HDate, HebrewDateEvent, months} from '@hebcal/core';
   *
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * const ev = new HebrewDateEvent(hd);
   * console.log(ev.render('en')); // '15th of Cheshvan, 5769'
   * console.log(ev.render('he')); // 'ט״ו חֶשְׁוָן תשס״ט'
   * @return {string}
   */
  render(locale) {
    const locale1 = locale === null || locale === void 0 ? void 0 : locale.toLowerCase();
    const locale0 = locale1 || Locale.getLocaleName();
    const hd = this.getDate();
    switch (locale0) {
      case 'h':
      case 'he':
        return hd.renderGematriya(false);
      case 'he-x-nonikud':
        return hd.renderGematriya(true);
      default:
        return hd.render(locale0, true);
    }
  }
  /**
   * @private
   * @param {string} locale
   * @return {string}
   */
  renderBriefHebrew(locale) {
    const hd = this.getDate();
    const dd = hd.getDate();
    const mm = Locale.gettext(hd.getMonthName(), locale);
    return gematriya(dd) + ' ' + mm;
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @example
   * import {HDate, HebrewDateEvent, months} from '@hebcal/core';
   *
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * const ev = new HebrewDateEvent(hd);
   * console.log(ev.renderBrief()); // '15th of Cheshvan'
   * console.log(ev.renderBrief('he')); // 'ט״ו חֶשְׁוָן'
   * @return {string}
   */
  renderBrief(locale) {
    const locale1 = locale === null || locale === void 0 ? void 0 : locale.toLowerCase();
    const locale0 = locale1 || Locale.getLocaleName();
    const hd = this.getDate();
    if (hd.getMonth() === months.TISHREI && hd.getDate() === 1) {
      return this.render(locale0);
    }
    switch (locale0) {
      case 'h':
      case 'he':
      case 'he-x-nonikud':
        return this.renderBriefHebrew(locale0);
      default:
        return hd.render(locale0, false);
    }
  }
}

const n=36e11,t=864e11,e=[1,1e3,1e6,1e9,6e10,n,t],o=[9,6,3];function r(n){return n<=6}function i(n){return n>=6}const s$1=a("overflow",{constrain:0,reject:1},0);function a(n,t,e){const o=function(n,t,e){return (o,r)=>{if(void 0===o){const t=null!=r?r:e;if(void 0===t)throw new RangeError(`Must specify a ${n}`);return t}if(void 0===t[o])throw new RangeError(`Invalid ${n}: ${o}`);return t[o]}}(n,t,e);return (t,e)=>{const r=d(t);return o(r[n],e)}}function c(n,t,e,o){if(void 0===n)return t;if(!Number.isFinite(n))throw new RangeError("Number must be finite");n=Math.trunc(n);const r=Math.min(Math.max(n,t),e);if(r!==n&&1===o)throw new RangeError("Invalid overflowed value "+n);return r}function u(n,t){const e={};for(const o in t)void 0!==n[o]&&(e[o]=t[o](n[o]));return e}function d(n,t){if(void 0===n&&!t)return {};if(!h(n))throw TypeError("options must be an object or undefined");return n}const l=/object|function/;function h(n){return null!==n&&l.test(typeof n)}const f=a("roundingMode",{halfExpand:Math.round,ceil:Math.ceil,trunc:Math.trunc,floor:Math.floor});function m$1(){const n=new WeakMap;return [n.get.bind(n),n.set.bind(n)]}function g(n,t){Object.defineProperties(n.prototype,y(t,(n=>({get:n}))));}function y(n,t){const e={};for(const o in n)e[o]=t(n[o],o);return e}function w(n,t,e){const o={};for(const r of t)o[r]=e(n[r]);return o}function p(n,t){const e={};return n.forEach(((n,o)=>{e[n]=t(n,o);})),e}const v=["nanosecond","microsecond","millisecond","second","minute","hour"],M=[...v,"day","week","month","year"],b=M.map((n=>n+"s")),S=p(M,((n,t)=>t)),I=p(b,((n,t)=>t));function F(n,t,e,o){var r;let i;if(void 0===n){if(void 0===t)throw new RangeError("Unit is required");i=t;}else if(i=null!=(r=S[n])?r:I[n],void 0===i||i<e||i>o)throw new RangeError("Invalid unit "+n);return i}function O(n,t,o,r,i,s){var a;const c=d(n),u=null!=(a=c.roundingIncrement)?a:1,l=F(c.smallestUnit,o,r,i),h=f(c,s?Math.round:Math.trunc);let m=c.largestUnit;"auto"===m&&(m=void 0);const g=F(m,t=Math.max(t,l),r,i);if(l>g)throw new RangeError("Bad smallestUnit/largestUnit");if(l<6){const n=e[l+1],t=e[l]*u;if(n===t)throw new RangeError("Must not equal larger unit");if(n%t)throw new RangeError("Must divide into larger unit")}return {smallestUnit:l,largestUnit:g,roundingFunc:h,roundingIncrement:u}}function T(n,o,r,i){var s;const a=d("string"==typeof n?{smallestUnit:n}:n,!0),c=null!=(s=a.roundingIncrement)?s:1,u=F(a.smallestUnit,void 0,o,r),l=f(a,Math.round),h=e[u]*c;if(6===u){if(1!==c)throw new RangeError("When smallestUnit is days, roundingIncrement must be 1")}else {const n=i?t:e[u+1];if(!i&&n===h)throw new RangeError("Must not equal larger unit");if(n%h)throw new RangeError("Must divide into larger unit")}return {smallestUnit:u,roundingFunc:l,incNano:h}}const D$1=Symbol();function N(n,t,...e){return t instanceof n?t:n.from(t,...e)}class Y{toJSON(){return this.toString()}}class E extends Y{valueOf(){throw new Error("Cannot convert object using valueOf")}}const[Z,C]=m$1();class U extends E{constructor(n){super(),C(this,Object.freeze(n));}getISOFields(){return Z(this)}}function P(n,t){return n<t?-1:n>t?1:0}function R(n){return P(n,0)}function k(n,t,e){return e(n/t)*t}function x(n){return k(n,6e10,j)}function j(n){return Math.round(Math.abs(n))*R(n)}function q(n,t,e){const o=n.div(t).mult(t),r=n.sub(o).toNumber();return o.add(e(r/t)*t)}function H(n,t){return (n%t+t)%t}function L(n,t){return $(e=String(n),t,"0")+e;var e;}function B(n,t,e){return n+$(n,t,e)}function $(n,t,e){return new Array(Math.max(0,t-n.length+1)).join(e)}function A(n){return n<0?"-":"+"}const z=Math.pow(10,8);class W{constructor(n,t){this.high=n,this.low=t;}sign(){return R(this.high)||R(this.low)}neg(){return new W(-this.high||0,-this.low||0)}abs(){return this.sign()<0?this.neg():this}add(n){const[t,e]=J(n);return Q(this.high+t,this.low+e)}sub(n){const[t,e]=J(n);return Q(this.high-t,this.low-e)}mult(n){return Q(this.high*n,this.low*n)}div(n){const t=this.high/n;let e=String(t);-1!==e.indexOf("e-")&&(e=t.toFixed(20));const o=e.indexOf(".");let r=0;if(-1!==o){let n=e.substr(o+1);n=B(n,8,"0"),n=n.substr(0,8),r=parseInt(n)*(R(t)||1);}return Q(Math.trunc(t)||0,Math.trunc(this.low/n)+r)}toNumber(){return this.high*z+this.low}toBigInt(){return BigInt(this.high)*BigInt(z)+BigInt(this.low)}}function K(n,t){let e,o;if(n instanceof W)e=n.high,o=n.low;else if("number"==typeof n){if(t)throw new TypeError("Must supply bigint, not number");e=Math.trunc(n/z),o=n%z||0;}else if("bigint"==typeof n){const t=BigInt(z);e=Number(n/t),o=Number(n%t||0);}else {if("string"!=typeof n)throw new Error("Invalid type of BigNano");{if((n=n.trim()).match(/\D/))throw new SyntaxError(`Cannot parse ${n} to a BigInt`);const t=n.length-8;e=Number(n.substr(t)),o=Number(n.substr(0,t));}}return new W(e,o)}function G(n,t){return P(n.high,t.high)||P(n.low,t.low)}function J(n){return "number"==typeof n?[0,n]:[n.high,n.low]}function Q(n,t){let e=t%z||0,o=n+Math.trunc(t/z);const r=R(o),i=R(e);return i&&r&&i!==r&&(o+=i,e-=z*i),new W(o,e)}const V=b.concat("sign");function X(n){return w(n,V,(n=>-n||0))}function _(n,t){var e,o,r,i,s,a,c,u,d,l;return nn({years:null!=(e=t.years)?e:n.years,months:null!=(o=t.months)?o:n.months,weeks:null!=(r=t.weeks)?r:n.weeks,days:null!=(i=t.days)?i:n.days,hours:null!=(s=t.hours)?s:n.hours,minutes:null!=(a=t.minutes)?a:n.minutes,seconds:null!=(c=t.seconds)?c:n.seconds,milliseconds:null!=(u=t.milliseconds)?u:n.milliseconds,microseconds:null!=(d=t.microseconds)?d:n.microseconds,nanoseconds:null!=(l=t.nanoseconds)?l:n.nanoseconds})}function nn(n){return {...n,sign:tn(n)}}function tn(n){let t=0;for(const e of b){if(n[e]){t=R(n[e]);break}}return t}function en(n){let t=9;for(;t>0&&!n[b[t]];)t--;return t}const on={isoHour:0,isoMinute:0,isoSecond:0,isoMillisecond:0,isoMicrosecond:0,isoNanosecond:0},rn={hours:0,minutes:0,seconds:0,milliseconds:0,microseconds:0,nanoseconds:0};function sn(n){return {isoHour:n.hour||0,isoMinute:n.minute||0,isoSecond:n.second||0,isoMillisecond:n.millisecond||0,isoMicrosecond:n.microsecond||0,isoNanosecond:n.nanosecond||0}}function an(n){return K(t).mult(n.days).add(cn(n))}function cn(t){return K(t.nanoseconds).add(K(t.microseconds).mult(1e3)).add(K(t.milliseconds).mult(1e6)).add(K(t.seconds).mult(1e9)).add(K(t.minutes).mult(6e10)).add(K(t.hours).mult(n))}function un(t){return t.isoHour*n+6e10*t.isoMinute+1e9*t.isoSecond+1e6*t.isoMillisecond+1e3*t.isoMicrosecond+t.isoNanosecond}function dn(e,o){let r,i=0,s=0,a=0,c=0,u=0,d=0;switch(o){case 6:r=e.div(t),i=r.toNumber(),e=e.sub(r.mult(t));case 5:r=e.div(n),s=r.toNumber(),e=e.sub(r.mult(n));case 4:r=e.div(6e10),a=r.toNumber(),e=e.sub(r.mult(6e10));case 3:r=e.div(1e9),c=r.toNumber(),e=e.sub(r.mult(1e9));case 2:r=e.div(1e6),u=r.toNumber(),e=e.sub(r.mult(1e6));case 1:r=e.div(1e3),d=r.toNumber(),e=e.sub(r.mult(1e3));}return nn({years:0,months:0,weeks:0,days:i,hours:s,minutes:a,seconds:c,milliseconds:u,microseconds:d,nanoseconds:e.toNumber()})}function ln(e){const o=Math.floor(e/t);e-=o*t;const r=Math.floor(e/n);e-=r*n;const i=Math.floor(e/6e10);e-=6e10*i;const s=Math.floor(e/1e9);e-=1e9*s;const a=Math.floor(e/1e6);e-=1e6*a;const c=Math.floor(e/1e3);return [{isoHour:r,isoMinute:i,isoSecond:s,isoMillisecond:a,isoMicrosecond:c,isoNanosecond:e-=1e3*c},o]}const hn={gregory:{bce:-1,ce:0},ethioaa:{era0:0},ethiopic:{era0:0,era1:5500},coptic:{era0:-1,era1:0},roc:{beforeroc:-1,minguo:0},buddhist:{be:0},islamic:{ah:0},indian:{saka:0},persian:{ap:0},japanese:{bce:-1,ce:0,meiji:1867,taisho:1911,showa:1925,heisei:1988,reiwa:2018}};class fn{constructor(n){this.id=n;}monthCode(n,t){return "M"+L(n,2)}convertMonthCode(n,t){const e=/L$/.test(n),o=parseInt(n.substr(1));if(e)throw new RangeError("Calendar system doesnt support leap months");return [o,!1]}}function mn(n,t,e,o){var r;let i=null==(r=hn[gn(n)])?void 0:r[e];if(void 0===i){if(!o)throw new Error("Unkown era "+e);i=0;}return (i+t)*(R(i)||1)}function gn(n){return n.split("-")[0]}class yn extends fn{computeFields(n){const t=Fn(n);return {era:void 0,eraYear:void 0,year:t.isoYear,month:t.isoMonth,day:t.isoDay}}epochMilliseconds(n,t,e){return Sn(n,t,e)}daysInMonth(n,t){return 2===t?this.inLeapYear(n)?29:28:4===t||6===t||9===t||11===t?30:31}monthsInYear(){return 12}inLeapYear(n){return n%4==0&&(n%100!=0||n%400==0)}guessYearForMonthDay(){return pn}normalizeISOYearForMonthDay(){return pn}}const wn=new yn("iso8601"),pn=1972,vn=Symbol();function Mn(n){return bn(n.isoYear,n.isoMonth,n.isoDay,n.isoHour,n.isoMinute,n.isoSecond,n.isoMillisecond,n.isoMicrosecond,n.isoNanosecond)}function bn(n,t,e,o,r,i,s,a,c){return K(Sn(n,t,e,o,r,i,s)).mult(1e6).add(1e3*(null!=a?a:0)+(null!=c?c:0))}function Sn(n,t,e,o,r,i,s){const a=R(n);let c,u,d=0;const l=n>=0&&n<1e3,h=l?n+1200:n;for(;d<31;d++){c=e-a*d;const n=Date.UTC(h,t-1,c,null!=o?o:0,null!=r?r:0,null!=i?i:0,null!=s?s:0);if(!En(n)){u=n+a*d*864e5;break}}return (void 0===u||c<1||c>wn.daysInMonth(n,t))&&Zn(),l&&(u=new Date(u).setUTCFullYear(n)),u}function In(n){let t=n.div(1e6),e=n.sub(t.mult(1e6)).toNumber();e<0&&(e+=1e6,t=t.sub(1));const o=Math.floor(e/1e3);return e-=1e3*o,{...Fn(t.toNumber()),isoMicrosecond:o,isoNanosecond:e}}function Fn(n){const[t,e]=Yn(n);return {isoYear:t.getUTCFullYear(),isoMonth:t.getUTCMonth()+1,isoDay:t.getUTCDate()+e,isoHour:t.getUTCHours(),isoMinute:t.getUTCMinutes(),isoSecond:t.getUTCSeconds(),isoMillisecond:t.getUTCMilliseconds()}}function On(n){var t;return null!=(t=n[vn])?t:Mn(n.getISOFields())}function Tn(n){return Math.floor(Sn(n,1,1)/1e3)}function Dn(n){return Yn(n.div(1e6).toNumber())[0].getUTCFullYear()}function Nn(n,t,e){const[o,r]=Yn(Sn(n,t,e));return H(o.getUTCDay()+r,7)||7}function Yn(n){const t=R(n);let e,o=0;for(;o<31;o++){const r=new Date(n-t*o*864e5);if(!En(r)){e=r;break}}return void 0===e&&Zn(),[e,t*o]}function En(n){return isNaN(n.valueOf())}function Zn(){throw new RangeError("Date outside of supported range")}function Cn(n,t){return Math.round((t-n)/864e5)}function Un(n,t){return n+864e5*t}function Pn(n,t){return !Rn(n,t)&&n.calendar.toString()===t.calendar.toString()}function Rn(n,t){return G(Mn(n.getISOFields()),Mn(t.getISOFields()))}function kn(n,t){return P(un(n.getISOFields()),un(t.getISOFields()))}function xn(n,t){return P(n.year,t.year)||P(n.month,t.month)||P(n.day,t.day)}function jn(n,t){return G(n[vn],t[vn])}function qn(n,t,e,o,r){return [n=Number(n),t=c(t,1,o.monthsInYear(n),r),e=c(e,1,o.daysInMonth(n,t),r)]}function Hn(n,t){const[e,o,r]=qn(n.isoYear,n.isoMonth,n.isoDay,wn,t);return {isoYear:e,isoMonth:o,isoDay:r}}function Ln(n,t){return {...Hn(n,t),...Bn(n,t)}}function Bn({isoHour:n,isoMinute:t,isoSecond:e,isoMillisecond:o,isoMicrosecond:r,isoNanosecond:i},s){return {isoHour:n=c(n,0,23,s),isoMinute:t=c(t,0,59,s),isoSecond:e=c(e,0,59,s),isoMillisecond:o=c(o,0,999,s),isoMicrosecond:r=c(r,0,999,s),isoNanosecond:i=c(i,0,999,s)}}const $n={era:String,eraYear:Number,year:Number,month:Number,monthCode:String},An={...$n,day:Number},zn={hour:Number,minute:Number,second:Number,millisecond:Number,microsecond:Number,nanosecond:Number},Wn={era:String,eraYear:Number,year:Number,month:Number,monthCode:String,day:Number},Kn=p(b,(()=>Number));class Gn extends yn{computeFields(n){const t=super.computeFields(n),{year:e}=t;return {...t,era:e<1?"bce":"ce",eraYear:e<1?-(e-1):e}}}const Jn=a("calendarName",{auto:0,never:1,always:2},0),Qn=a("disambiguation",{compatible:0,earlier:1,later:2,reject:3},0);function Vn(n,t=4){const r=d(n),i=r.smallestUnit,s=r.fractionalSecondDigits;let a,u=0,l=1;return void 0!==i?(u=F(i,void 0,0,t),l=e[u],a=o[u]||0):void 0!==s&&"auto"!==s&&(a=c(s,0,9,1),l=Math.pow(10,9-a)),{smallestUnit:u,fractionalSecondDigits:a,roundingFunc:f(n,Math.trunc),incNano:l}}const Xn=a("timeZoneName",{auto:0,never:1},0);function _n(n,t){return nt(n)+"T"+et(n,t)}function nt(n){return tt(n)+"-"+L(n.isoDay,2)}function tt(n){const{isoYear:t}=n;return (t<1e3||t>9999?A(t)+L(Math.abs(t),6):L(t,4))+"-"+L(n.isoMonth,2)}function et(n,t){const e=[L(n.isoHour,2)];return t.smallestUnit<=4&&(e.push(L(n.isoMinute,2)),t.smallestUnit<=3&&e.push(L(n.isoSecond,2)+st(n.isoMillisecond,n.isoMicrosecond,n.isoNanosecond,t.fractionalSecondDigits)[0])),e.join(":")}function ot(n){const[t,e]=ln(Math.abs(n)),o=st(t.isoMillisecond,t.isoMicrosecond,t.isoNanosecond,void 0)[0];return A(n)+L(t.isoHour+24*e,2)+":"+L(t.isoMinute,2)+(t.isoSecond||o?":"+L(t.isoSecond,2)+o:"")}function rt(n,t){return n&&(2===t||1!==t&&"iso8601"!==n)?`[u-ca=${n}]`:""}function it(n){return n.map((([n,t,e])=>{if(e||n){return Math.abs(n).toLocaleString("fullwide",{useGrouping:!1})+t}return ""})).join("")}function st(n,t,o,r,i,s){let a=K(n).mult(1e6).add(K(t).mult(1e3)).add(o);i&&(a=q(a,void 0===r?e[s]:Math.pow(10,9-r),i));const c=a.abs(),u=c.div(1e9);let d=L(c.sub(u.mult(1e9)).toNumber(),9);return d=void 0===r?d.replace(/0+$/,""):d.substr(0,r),[d?"."+d:"",u.toNumber()*(a.sign()||1)]}function at(n){g(n,{epochNanoseconds(){return this[vn].toBigInt()},epochMicroseconds(){return this[vn].div(1e3).toBigInt()},epochMilliseconds(){return this[vn].div(1e6).toNumber()},epochSeconds(){return this[vn].div(1e9).toNumber()}});}const ct={calendar:"calendar"};for(const n of M)ct[n]="iso"+((ut=n).charAt(0).toUpperCase()+ut.slice(1));var ut;function dt(n,t=[]){g(n,p(t.concat("calendar"),(n=>function(){return this.getISOFields()[ct[n]]})));}const lt=["era","eraYear","year","month","monthCode","daysInMonth","daysInYear","monthsInYear","inLeapYear"],ht=[...lt,"day","dayOfWeek","dayOfYear","weekOfYear","daysInWeek"];function ft(n,t){g(n,p(t,(n=>function(){const t=this.calendar[n](this);return Object.defineProperty(this,n,{value:t}),t})));}function mt(n,t){(n.prototype||n)[Symbol.toStringTag]="Temporal."+t;}const gt=a("offset",{prefer:0,use:1,ignore:2,reject:3});function yt(n,e,o=0){const r=n.getPossibleInstantsFor(e);if(1===r.length)return r[0];if(3===o)throw new RangeError("Ambiguous offset");if(r.length)return r[2===o?1:0];{const r=function(n,e){const o=On(e),r=n.getOffsetNanosecondsFor(new Yr(o.sub(t)));return n.getOffsetNanosecondsFor(new Yr(o.add(t)))-r}(n,e),i=n.getPossibleInstantsFor(e.add({nanoseconds:r*(1===o?-1:1)}));return i[1===o?0:i.length-1]}}function wt({year:n,month:t,day:e},o,r,i){n+=o;const s=c(t,1,r.monthsInYear(n),i);let a=t===s?e:1;return a=c(a,1,r.daysInMonth(n,s),i),{year:n,month:s,day:a}}function pt({year:n,month:t,day:e},o,r,i){if(o){if(t+=o,o<0)for(;t<1;)t+=r.monthsInYear(--n);else {let e;for(;t>(e=r.monthsInYear(n));)t-=e,n++;}e=c(e,1,r.daysInMonth(n,t),i);}return {year:n,month:t,day:e}}function vt({isoYear:n,isoMonth:t,isoDay:e},o){if(o){let r=Sn(n,t,e);r=Un(r,o),({isoYear:n,isoMonth:t,isoDay:e}=Fn(r));}return {isoYear:n,isoMonth:t,isoDay:e}}function Mt(n,t){if(en(t)>=6)throw new RangeError("Duration cant have units >= days");return n.add(cn(t))}function bt(n,t,e=3,o){const{offsetNanoseconds:r,timeZone:i,Z:s}=n;if(void 0!==r&&2!==e){if(1===e||s)return Mn(n).sub(r);{const o=St(n,r,i,t);if(void 0!==o)return o;if(3===e)throw new RangeError("Mismatching offset/timezone")}}return yt(i,Ho(n),Qn(o))[vn]}function St(n,t,e,o){const r=e.getPossibleInstantsFor(Ho(n)),i=Mn(n),s=o?x(t):t;for(const n of r){const t=n[vn],e=i.sub(t).toNumber();if((o?x(e):e)===s)return t}}function It(n){const{timeZone:t}=n,e={...n,...on,calendar:new mr("iso8601")},o={...vt(e,1),...on,calendar:new mr("iso8601")},r=yt(t,Ho(e))[vn];return yt(t,Ho(o))[vn].sub(r).toNumber()}const Ft="(\\d{2})(:?(\\d{2})(:?(\\d{2})([.,](\\d{1,9}))?)?)?",Ot="([+-])"+Ft,Tt="(Z|"+Ot+")?(\\[([^=\\]]+)\\])?(\\[u-ca=([^\\]]+)\\])?",Dt=Pt("([+-]\\d{6}|\\d{4})-?(\\d{2})"+Tt),Nt=Pt("(--)?(\\d{2})-?(\\d{2})"+Tt),Yt=Pt("([+-]\\d{6}|\\d{4})-?(\\d{2})-?(\\d{2})([T ](\\d{2})(:?(\\d{2})(:?(\\d{2})([.,](\\d{1,9}))?)?)?)?"+Tt),Et=Pt("T?"+Ft+Tt),Zt=Pt(Ot),Ct=/^([-+])?P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T((\d+)([.,](\d{1,9}))?H)?((\d+)([.,](\d{1,9}))?M)?((\d+)([.,](\d{1,9}))?S)?)?$/i,Ut=/\u2212/g;function Pt(n){return new RegExp(`^${n}$`,"i")}function Rt(n){return n.replace(Ut,"-")}function kt(n){const t=Lt(n);if(!t)throw _t("dateTime",n);return t}function xt(n){const t=Bt(n);if(!t)throw _t("dateTime",n);return t}function jt(n){const t=zt(n);if(void 0===t)throw _t("timeZone",n);return t}function qt(n){let t=function(n){const t=Et.exec(Rt(n));if(t)return Kt(t.slice(1))}(n);if(void 0!==t){if("T"!==n.charAt(0)){const e=$t(n)||At(n);e&&function(n){try{return Hn(n,1),!0}catch(n){return !1}}(e)&&(t=void 0);}}else t=Bt(n,!0);if(void 0===t)throw _t("time",n);return t}const Ht=/^Z$/i;function Lt(n){const t=Yt.exec(Rt(n));if(t)return function(n){const t=n[11];let e,o=!1;t&&(o=Ht.test(t),e=o?0:Gt(n.slice(12)));return {...Wt(n),timeZone:n[21],offsetNanoseconds:e,Z:o}}(t.slice(1))}function Bt(n,t,e){const o=Yt.exec(Rt(n));if(o&&(e||!Ht.test(o[12]))&&(!t||o[4]))return Wt(o.slice(1))}function $t(n){const t=Dt.exec(Rt(n));if(t)return {calendar:(e=t.slice(1))[14],isoYear:Vt(e[0]),isoMonth:Vt(e[1]),isoDay:1};var e;}function At(n){const t=Nt.exec(Rt(n));if(t)return {calendar:(e=t.slice(1))[15],isoYear:pn,isoMonth:Vt(e[1]),isoDay:Vt(e[2])};var e;}function zt(n){const t=Zt.exec(Rt(n));if(t)return Gt(t.slice(1))}function Wt(n){return {calendar:n[23],isoYear:Vt(n[0]),isoMonth:Vt(n[1]),isoDay:Vt(n[2]),...Kt(n.slice(4))}}function Kt(n){const t=Qt(n[4]);return {...ln(Jt(n[6]||""))[0],isoHour:Qt(n[0]),isoMinute:Qt(n[2]),isoSecond:60===t?59:t}}function Gt(t){return ("+"===t[0]?1:-1)*function(t){return Qt(t[0])*n+6e10*Qt(t[2])+1e9*Qt(t[4])+Jt(t[6]||"")}(t.slice(1))}function Jt(n){return parseInt(B(n,9,"0"))}function Qt(n){return parseInt(n||"0")}function Vt(n){return parseInt(n||"1")}function Xt(n){return void 0===n?void 0:parseInt(n)}function _t(n,t){throw new RangeError(`Cannot parse ${n} '${t}'`)}function ne(n){return {...n,calendar:void 0===n.calendar?gr():new mr(n.calendar)}}function te(n){return {...ne(n),timeZone:new we(n.timeZone)}}class ee{constructor(n){this.id=n;}}class oe extends ee{constructor(n,t){super(n),this.offsetNano=t;}getPossibleOffsets(){return [this.offsetNano]}getOffset(){return this.offsetNano}getTransition(){}}function re(n,t){const e={},o=n.formatToParts(t);for(const n of o)e[n.type]=n.value;return e}const ie={bc:"bce",ad:"ce"};function se(n){return n=n.toLowerCase().normalize("NFD").replace(/[^a-z0-9]/g,""),ie[n]||n}const ae=Intl.DateTimeFormat;function ce(n){return [].concat(n||[])}const ue={"Pacific/Apia":{2011:[[de(13017528e5),-36e12,-396e11],[de(13168728e5),-396e11,-36e12],[de(13252392e5),-36e12,504e11]]}};function de(n){return K(n).mult(1e6)}const le=(new Date).getUTCFullYear()+10,he=[182,91,273];class fe extends ee{constructor(n){const t=new ae("en-GB",{era:"short",year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric",timeZone:n});super(t.resolvedOptions().timeZone),this.format=t,this.yearEndOffsets={},this.transitionsInYear=ue[n]||{};}getPossibleOffsets(n){let t;const e=[this.getTransition(n,-1),this.getTransition(n.sub(1),1)].filter(Boolean);for(const o of e){const[e,r,i]=o,s=n.sub(r),a=n.sub(i);if(G(e,s)>0&&G(e,a)>0)return [r];if(!(G(e,s)<=0&&G(e,a)<=0))return r<i?[]:[r,i];t=i;}return void 0!==t?[t]:[1e9*this.getYearEndOffsetSec(Dn(n))]}getOffset(n){return 1e9*this.getOffsetForEpochSecs(n.div(1e9).toNumber())}getOffsetForEpochSecs(n){const t=re(this.format,1e3*n);let e=parseInt(t.year);"bce"===se(t.era)&&(e=-(e-1));const o=Sn(e,parseInt(t.month),parseInt(t.day),parseInt(t.hour),parseInt(t.minute),parseInt(t.second));return Math.floor(o/1e3)-n}getTransition(n,t){let e=Dn(n);if(e>le){const o=this.getTransitionFrom(e,e+t,t,n);if(o||t>0)return o;e=le;}return this.getTransitionFrom(Math.max(e,1847),t<0?1846:le,t,n)}getTransitionFrom(n,t,e,o){for(;n!==t;n+=e){let t=this.getTransitionsInYear(n);e<0&&(t=t.slice().reverse());for(const n of t)if(G(n[0],o)===e)return n}}getYearEndOffsetSec(n){const{yearEndOffsets:t}=this;return t[n]||(t[n]=this.getOffsetForEpochSecs(Tn(n+1)-1))}getTransitionsInYear(n){const{transitionsInYear:t}=this;return t[n]||(t[n]=this.computeTransitionsInYear(n))}computeTransitionsInYear(n){const t=this.getYearEndOffsetSec(n-1),e=this.getYearEndOffsetSec(n),o=Tn(n)-1,r=Tn(n+1)-1;if(t!==e)return [this.searchTransition(o,r,t,e)];const i=this.searchIsland(t,o);return void 0!==i?[this.searchTransition(o,i[0],t,i[1]),this.searchTransition(i[0],r,i[1],e)]:[]}searchTransition(n,t,e,o){for(;t-n>1;){const o=Math.floor(n+(t-n)/2);this.getOffsetForEpochSecs(o)===e?n=o:t=o;}return [K(t).mult(1e9),1e9*e,1e9*o]}searchIsland(n,t){for(const e of he){const o=t+86400*e,r=this.getOffsetForEpochSecs(o);if(r!==n)return [o,r]}}}const me={UTC:new oe("UTC",0)};const[ge,ye]=m$1();class we extends Y{constructor(n){if(!n)throw new RangeError("Invalid timezone ID");super(),ye(this,function(n){const e=(n=String(n)).toLocaleUpperCase();if(me[e])return me[e];const o=zt(n);if(void 0!==o){if(Math.abs(o)>t)throw new RangeError("Offset out of bounds");return new oe(ot(o),o)}return me[e]=new fe(n)}(n));}static from(n){if(h(n))return function(n){const t=n.timeZone;if(void 0===t)return n;if(h(t)&&void 0===t.timeZone)return t;return new we(t)}(n);const t=Lt(String(n));if(t){if(t.timeZone){const n=te(t);return function(n){const{offsetNanoseconds:t,timeZone:e,Z:o}=n;if(void 0!==t&&!o&&void 0===St(n,t,e,!0))throw new RangeError("Mismatching offset/timezone")}(n),n.timeZone}if(t.Z)return new we("UTC");if(void 0!==t.offsetNanoseconds)return new we(ot(t.offsetNanoseconds))}return new we(String(n))}get id(){return this.toString()}getOffsetStringFor(n){return ot(this.getOffsetNanosecondsFor(n))}getOffsetNanosecondsFor(n){const t=N(Yr,n);return ge(this).getOffset(t[vn])}getPlainDateTimeFor(n,t=gr()){const e=N(Yr,n);return Ho({...In(e[vn].add(this.getOffsetNanosecondsFor(e))),calendar:N(mr,t)})}getInstantFor(n,t){return yt(this,N(qo,n),Qn(t))}getPossibleInstantsFor(n){const t=Mn(N(qo,n).getISOFields());return ge(this).getPossibleOffsets(t).map((n=>new Yr(t.sub(n))))}getPreviousTransition(n){const t=N(Yr,n),e=ge(this).getTransition(t[vn],-1);return e?new Yr(e[0]):null}getNextTransition(n){const t=N(Yr,n),e=ge(this).getTransition(t[vn],1);return e?new Yr(e[0]):null}toString(){return ge(this).id}}function pe(n){if(void 0===n.timeZone)throw new TypeError("Must specify timeZone");return N(we,n.timeZone)}mt(we,"TimeZone");const ve=Le((function(n,t,e){const o=Ce(n,t,e);if(o)return {...o,timeZone:pe(n),offsetNanoseconds:void 0!==n.offset?jt(String(n.offset)):void 0}})),Me=Le(Ce),be=Le(Ue),Se=Le((function(n,t){const e=pr(n),o=je(n,$n,e);if(Be(o))return e.yearMonthFromFields(o,t)})),Ie=Le((function(n,t){const e=pr(n),o=je(n,Wn,e);if(Be(o))return void 0===n.year&&void 0===n.calendar&&(o.year=pn),e.monthDayFromFields(o,t)})),Fe=Le(Pe),Oe=Le((function(n,t,e,o){const r=Re(n,t,e,o),i=void 0!==t.offset;if(r||i)return {...r||n.getISOFields(),timeZone:n.timeZone,offsetNanoseconds:i?jt(String(t.offset)):n.offsetNanoseconds}}),!0),Te=Le(Re,!0),De=Le(ke,!0),Ne=Le((function(n,t,e){const o=n.calendar;if(Be(je(t,$n,o))){const r=He(n,t,$n,o);return o.yearMonthFromFields(r,e)}}),!0),Ye=Le((function(n,t,e){const o=n.calendar;if(Be(je(t,Wn,o))){const r=He(n,t,Wn,o);return o.monthDayFromFields(r,e)}}),!0),Ee=Le(xe,!0),Ze=Le((function(n){const t=u(n,Kn);if(Be(t))return t}));function Ce(n,t,e){const o=Ue(n,e),r=Pe(n,t);if(o)return {...o.getISOFields(),...r||on}}function Ue(n,t){const e=pr(n),o=je(n,An,e);if(Be(o))return e.dateFromFields(o,t)}function Pe(n,t){const e=u(n,zn);if(Be(e))return Bn(sn(e),t)}function Re(n,t,e,o){const r=ke(n,t,o),i=xe(n,t,e);if(r||i)return {...n.getISOFields(),...r?r.getISOFields():{},...i}}function ke(n,t,e){const o=n.calendar,r=je(t,An,o);if(Be(r)){const t=He(n,r,An,o);return o.dateFromFields(t,e)}}function xe(n,t,e){const o=u(t,zn);if(Be(o)){return Bn(sn((r=n,i=o,y(zn,((n,t)=>{var e;return null!=(e=i[t])?e:r[t]})))),e)}var r,i;}function je(n,t,e){let o=Object.keys(t);return o=e.fields?Array.prototype.slice.call(e.fields(o)):Object.keys(qe(e,o)),qe(n,o)}function qe(n,t){const e={};for(const o of t)void 0!==n[o]&&(e[o]=n[o]);return e}function He(n,t,e,o){const r=je(n,e,o);return o.mergeFields?o.mergeFields(r,t):yr(r,t)}function Le(n,t){return (...e)=>{if(t){const n=e[1];if(!h(n))throw new TypeError("must be object-like");if(void 0!==n.calendar)throw new TypeError("calendar not allowed");if(void 0!==n.timeZone)throw new TypeError("timeZone not allowed")}const o=n(...e);if(!o)throw new TypeError("No valid fields");return o}}function Be(n){return Object.keys(n).length>0}const $e=K(t).mult(1e8),Ae=$e.mult(-1),ze=$e.add(86399999999999),We=Ae.sub(86399999999999);function Ke(n,t){const e=Mn(n);Ge(e),cr(e,t);}function Ge(n){-1!==G(n,We)&&1!==G(n,ze)||Zn();}function Je(n,t){const e=Xe(un(n),t),[o,r]=ln(e);return {...vt(n,r),...o}}function Qe(n,t){const e=Xe(un(n),t),[o]=ln(e);return o}function Ve(n,t){const[e,o]=function(n){const t=In(n);return [bn(t.isoYear,t.isoMonth,t.isoDay),un(t)]}(n),r=Xe(o,t);return e.add(r)}function Xe(n,t){return k(n,t.incNano,t.roundingFunc)}function _e(n,t,e){return (o,r)=>{const i=io(n,r)?{}:{...n,...t};return {buildKey:ro(o,r,!1),buildFormat:function(n,t){return new ae(o,{calendar:n,timeZone:t||void 0,...i,...r,...e})},buildEpochMilli:no}}}function no(n){return n.epochMilliseconds}function to(n,t,e){return (o,r)=>{const i=io(n,r)?{}:n;return {buildKey:ro(o,r,e),buildFormat:function(n,e){return new ae(o,{calendar:n,...i,...r,...t,timeZone:e,timeZoneName:void 0})},buildEpochMilli:void 0!==r.timeZone?eo.bind(null,new we(r.timeZone)):oo}}}function eo(n,t){const e=Ho({...on,...t.getISOFields()});return n.getInstantFor(e).epochMilliseconds}function oo(n){return Sn((t=n.getISOFields()).isoYear,t.isoMonth,t.isoDay,t.isoHour,t.isoMinute,t.isoSecond,t.isoMillisecond);var t;}function ro(n,t,e){var o;const r=null!=(o=t.calendar)?o:function(n){for(const t of n){const n=t.match(/-u-ca-(.*)$/);if(n)return n[1]}return}(n),i=t.timeZone;return function(n,t){var o,s,a,c;const u=null==(o=n.calendar)?void 0:o.id,d=null==(s=n.timeZone)?void 0:s.id;if(t){if((null==(a=t.calendar)?void 0:a.id)!==u)throw new RangeError("Mismatching calendar");if((null==(c=t.timeZone)?void 0:c.id)!==d)throw new RangeError("Mismatching timeZone")}if((e||"iso8601"!==u)&&void 0!==u&&void 0!==r&&r!==u)throw new RangeError("Non-iso calendar mismatch");if(void 0!==d&&void 0!==i&&i!==d)throw new RangeError("Given timeZone must agree");return [r||u||"iso8601",i||d||"UTC"]}}function io(n,t){for(const e in n)if(void 0!==t[e])return !0;return !1}function so(n,t){n.prototype.toLocaleString=function(n,e){const o=t(ce(n),e||{});return o.buildFormat(...o.buildKey(this)).format(o.buildEpochMilli(this))},n.prototype[D$1]=t;}function ao(n){return null==n?void 0:n[D$1]}function co(n){const t=function(n){const t=Ct.exec(Rt(n));if(t){let n,e,o,r;[n,r]=uo(t[8],t[10],5,void 0),[e,r]=uo(t[12],t[14],4,r),[o,r]=uo(t[16],t[18],3,r);const i=function(n){const t={};for(const e in n)void 0!==n[e]&&(t[e]=n[e]);return t}({years:Xt(t[2]),months:Xt(t[3]),weeks:Xt(t[4]),days:Xt(t[5]),hours:n,minutes:e,seconds:o});if(!Object.keys(i).length)throw new RangeError("Duration string must have at least one field");const s=dn(K(r||0),2);i.milliseconds=s.milliseconds,i.microseconds=s.microseconds,i.nanoseconds=s.nanoseconds;let a=nn(i);return "-"===t[1]&&(a=X(a)),a}}(n);if(void 0===t)throw _t("duration",n);return t}function uo(n,t,o,r){if(void 0!==n){if(void 0!==r)throw new RangeError("Partial units must be last unit");return [parseInt(n),void 0!==t?Jt(t)*(e[o]/1e9):void 0]}if(void 0!==r){const n=Math.trunc(r/e[o]);return [n,r-n*e[o]]}return [void 0,void 0]}const lo=a("offset",{auto:0,never:1},0);class ho extends U{constructor(n=0,t=0,e=0,o=0,r=0,i=0){super({...Bn({isoHour:n,isoMinute:t,isoSecond:e,isoMillisecond:o,isoMicrosecond:r,isoNanosecond:i},1),calendar:gr()});}static from(n,t){const e=s$1(t);return fo(n instanceof ho?n.getISOFields():"object"==typeof n?Fe(n,e):qt(String(n)))}static compare(n,t){return kn(N(ho,n),N(ho,t))}with(n,t){return fo(Ee(this,n,s$1(t)))}add(n){return go(this,N(ko,n))}subtract(n){return go(this,X(N(ko,n)))}until(n,t){return yo(this,N(ho,n),t)}since(n,t){return yo(N(ho,n),this,t)}round(n){const t=T(n,0,5);return fo(Qe(this.getISOFields(),t))}equals(n){return !kn(this,N(ho,n))}toString(n){const t=Vn(n);return et(Qe(this.getISOFields(),t),t)}toZonedDateTime(n){const t=N(Sr,n.plainDate),e=N(we,n.timeZone);return Fo({...t.getISOFields(),...this.getISOFields(),timeZone:e})}toPlainDateTime(n){return N(Sr,n).toPlainDateTime(this)}}function fo(n){return new ho(n.isoHour,n.isoMinute,n.isoSecond,n.isoMillisecond,n.isoMicrosecond,n.isoNanosecond)}function mo(n){return N(ho,null!=n?n:{hour:0})}function go(n,t){return fo(function(n,t){const e=un(n)+cn(t).toNumber(),[o]=ln(e);return o}(n.getISOFields(),t))}function yo(n,t,o){const r=O(o,5,0,0,5);return xo(function(n,t,o){return dn(K(k(un(t)-un(n),e[o.smallestUnit]*o.roundingIncrement,o.roundingFunc)),o.largestUnit)}(n.getISOFields(),t.getISOFields(),r))}mt(ho,"PlainTime"),dt(ho,v),so(ho,(function(n,t){return {buildKey:()=>["",""],buildFormat:()=>new ae(n,{hour:"numeric",minute:"2-digit",second:"2-digit",...t,timeZone:"UTC",timeZoneName:void 0,year:void 0,month:void 0,day:void 0,weekday:void 0}),buildEpochMilli:n=>Math.trunc(un(n.getISOFields())/1e6)}}));const wo={day:1};class po extends U{constructor(n,t,e=gr(),o=1){const r=Hn({isoYear:n,isoMonth:t,isoDay:o},1),i=N(mr,e);var s,a;s=r,a=i.toString(),cr(Mn(s),a),super({...r,calendar:i});}static from(n,t){if(s$1(t),n instanceof po)return vo(n.getISOFields());if("object"==typeof n)return Se(n,t);const e=function(n){const t=$t(n)||Bt(n);if(!t)throw _t("yearMonth",n);return t}(String(n));return void 0===e.calendar&&(e.isoDay=1),vo(ne(e))}static compare(n,t){return Rn(N(po,n),N(po,t))}with(n,t){return Ne(this,n,t)}add(n,t){return Mo(this,N(ko,n),t)}subtract(n,t){return Mo(this,X(N(ko,n)),t)}until(n,t){return bo(this,N(po,n),!1,t)}since(n,t){return bo(this,N(po,n),!0,t)}equals(n){return !Rn(this,N(po,n))}toString(n){const t=this.getISOFields(),e=t.calendar.toString(),o=Jn(n);return ("iso8601"===e?tt(t):nt(t))+rt(e,o)}toPlainDate(n){return this.calendar.dateFromFields({year:this.year,month:this.month,day:n.day})}}function vo(n){return new po(n.isoYear,n.isoMonth,n.calendar,n.isoDay)}function Mo(n,t,e){return n.toPlainDate({day:t.sign<0?n.daysInMonth:1}).add(t,e).toPlainYearMonth()}function bo(n,t,e,o){return xo(Tr(n.toPlainDate(wo),t.toPlainDate(wo),vr(n,t),e,O(o,9,8,8,9)))}mt(po,"PlainYearMonth"),dt(po),ft(po,lt),so(po,to({year:"numeric",month:"numeric"},{weekday:void 0,day:void 0,hour:void 0,minute:void 0,second:void 0},!0));const So=Symbol();class Io extends U{constructor(n,t,e=gr()){const o=N(we,t),r=N(mr,e),i=K(n),[s,a]=Oo(i,o);Ke(s,r.toString()),super({...s,calendar:r,timeZone:o,offset:ot(a)}),this[vn]=i,this[So]=a;}static from(n,t){const e=gt(t,3),o=s$1(t);if(n instanceof Io)return new Io(n.epochNanoseconds,n.timeZone,n.calendar);const r="object"==typeof n;return Fo(r?ve(n,o,t):te(kt(String(n))),!r,e,t)}static compare(n,t){return jn(N(Io,n),N(Io,t))}get timeZone(){return this.getISOFields().timeZone}get offsetNanoseconds(){return this[So]}get offset(){return this.getISOFields().offset}with(n,t){Qn(t);const e=s$1(t),o=gt(t,0);return Fo(Oe(this,n,e,t),!1,o,t)}withPlainDate(n){const t=N(Sr,n),e=t.toPlainDateTime(this),{timeZone:o}=this,r=yt(o,e);return new Io(r.epochNanoseconds,o,Mr(this,t))}withPlainTime(n){return Fo({...this.getISOFields(),...void 0===n?on:N(ho,n).getISOFields()})}withCalendar(n){return new Io(this.epochNanoseconds,this.timeZone,n)}withTimeZone(n){return new Io(this.epochNanoseconds,n,this.calendar)}add(n,t){return To(this,N(ko,n),t)}subtract(n,t){return To(this,X(N(ko,n)),t)}until(n,t){return No(this,N(Io,n),!1,t)}since(n,t){return No(this,N(Io,n),!0,t)}round(n){return Do(this,T(n,0,6))}equals(n){return t=this,e=N(Io,n),Pn(t,e)&&t.timeZone.toString()===e.timeZone.toString();var t,e;}startOfDay(){return Fo({...this.getISOFields(),...on,offsetNanoseconds:this.offsetNanoseconds},!1,0)}get hoursInDay(){return It(this.getISOFields())/n}toString(n){const t=Vn(n),e=lo(n),o=Xn(n),r=Jn(n),i=Do(this,t);return _n(i.getISOFields(),t)+(0===e?ot(x(i.offsetNanoseconds)):"")+(s=this.timeZone.toString(),1!==o?`[${s}]`:"")+rt(this.calendar.toString(),r);var s;}toPlainYearMonth(){return vo(this.getISOFields())}toPlainMonthDay(){return this.calendar.monthDayFromFields(this)}toPlainDateTime(){return Ho(this.getISOFields())}toPlainDate(){return Ir(this.getISOFields())}toPlainTime(){return fo(this.getISOFields())}toInstant(){return new Yr(this.epochNanoseconds)}}function Fo(n,t,e,o){const r=bt(n,t,e,o);return new Io(r,n.timeZone,n.calendar)}function Oo(n,t){const e=new Yr(n),o=t.getOffsetNanosecondsFor(e);return [In(n.add(o)),o]}function To(n,t,e){const o=n.getISOFields(),r=function(n,t,e){const{calendar:o,timeZone:r}=n,i=o.dateAdd(Ir(n),_(t,rn),e);return yt(r,Ho({...n,...i.getISOFields()}))[vn].add(cn(t))}(o,t,e);return new Io(r,o.timeZone,o.calendar)}function Do(n,t){const e=n.getISOFields(),o=function(n,t,e){const{calendar:o,timeZone:r}=n;let i,s,a=un(n);return 6===e.smallestUnit?(i=on,s=e.roundingFunc(a/It(n))):(a=Xe(a,e),[i,s]=ln(a)),bt({...vt(n,s),...i,offsetNanoseconds:t,calendar:o,timeZone:r},!1,0)}(e,n.offsetNanoseconds,t);return new Io(o,e.timeZone,e.calendar)}function No(n,t,e,o){const r=O(o,5,0,0,9),{largestUnit:i}=r;if(i>=6&&n.timeZone.id!==t.timeZone.id)throw new Error("Must be same timeZone");return xo(Or(n,t,vr(n,t),e,r))}function Yo(n){if(void 0===n)return;if(h(n))return n instanceof Io||n instanceof qo?n:N(void 0!==n.timeZone?Io:qo,n);if("symbol"==typeof n)throw new TypeError("Incorrect relativeTo type");const t=Lt(String(n));if(t)return void 0!==t.timeZone?Fo(te(t),!0):Ho(ne(t));throw new RangeError("Invalid value of relativeTo")}function Eo(n,t,e,o){return (e instanceof Sr?function(n,t,e,o){const r=e.add(n);return [o.dateUntil(e,r,{largestUnit:M[t]}),r]}(n,Math.max(6,t),e,o):Zo(n,t,e,o))[0]}function Zo(n,t,e,o,r){const i=!0!==r&&t>7&&n.weeks;i&&(n=_(n,{weeks:0}));let s=e.add(n),a=Dr(e,s,o,t);return i&&(a=_(a,{weeks:i}),s=s.add({weeks:i})),[a,s]}function Co(n,t,e,o){const r=b[t],{sign:i}=n;if(!i)return n;const s={};for(let e=9;e>=t;e--){const t=b[e];s[t]=n[t];}const a={[r]:i},c=e.add(s),u=c.add(a),d=On(c),l=On(u),h=On(o).sub(d).toNumber()/l.sub(d).toNumber()*i;return s[r]+=h,s}function Uo(n,t,o,r,s,a){const{largestUnit:c,smallestUnit:u,roundingIncrement:d,roundingFunc:l}=a;if(!i(c)){return dn(q(On(o).sub(On(t)).mult(s?-1:1),e[u]*d,l),c)}let h=Co(n,u,t,o);const f=b[u];function m(){const n=h[f];h[f]=k(n,d,l);}return l===Math.round&&m(),s&&(h=X(h)),l!==Math.round&&m(),u>0&&(h=s?X(Eo(X(h),c,t,r)):Eo(h,c,t,r)),h}mt(Io,"ZonedDateTime"),dt(Io,v),ft(Io,ht),at(Io),so(Io,_e({year:"numeric",month:"numeric",day:"numeric",weekday:void 0,hour:"numeric",minute:"2-digit",second:"2-digit"},{timeZoneName:"short"},{}));const[Po,Ro]=m$1();class ko extends E{constructor(n=0,t=0,e=0,o=0,r=0,i=0,s=0,a=0,c=0,u=0){super();const d=Ze({years:n,months:t,weeks:e,days:o,hours:r,minutes:i,seconds:s,milliseconds:a,microseconds:c,nanoseconds:u});Ro(this,function(n){const t=nn(n),{sign:e}=t;for(const n of b){const o=t[n],r=R(t[n]);if(r&&r!==e)throw new RangeError("All fields must be same sign");if(!Number.isInteger(o))throw new RangeError("Duration fields must be integers")}return t}(d));}static from(n){return xo("object"==typeof n?Ze(n):co(n))}static compare(n,t,e){return function(n,t,e){if(void 0===e&&en(n)<=6&&en(t)<=6)return G(an(n),an(t));if(!e)throw new RangeError("Need relativeTo");const o=e.add(n),r=e.add(t);return void 0!==e[vn]?jn(o,r):Rn(o,r)}(N(ko,n),N(ko,t),Yo(d(e).relativeTo))}get years(){return Po(this).years}get months(){return Po(this).months}get weeks(){return Po(this).weeks}get days(){return Po(this).days}get hours(){return Po(this).hours}get minutes(){return Po(this).minutes}get seconds(){return Po(this).seconds}get milliseconds(){return Po(this).milliseconds}get microseconds(){return Po(this).microseconds}get nanoseconds(){return Po(this).nanoseconds}get sign(){return Po(this).sign}get blank(){return !this.sign}with(n){return xo({...Po(this),...Ze(n)})}negated(){return xo(X(Po(this)))}abs(){return xo(w(Po(this),V,(n=>Math.abs(n))))}add(n,t){return jo(this,N(ko,n),t)}subtract(n,t){return jo(this,X(N(ko,n)),t)}round(n){const t="string"==typeof n?{smallestUnit:n}:n;if(!h(t))throw new TypeError("Must specify options");if(void 0===t.largestUnit&&void 0===t.smallestUnit)throw new RangeError("Must specify either largestUnit or smallestUnit");const o=O(t,en(this),0,0,9,!0),i=Yo(t.relativeTo);return xo(function(n,t,o,i){const{largestUnit:s,smallestUnit:a,roundingIncrement:c,roundingFunc:u}=t;if(void 0===o&&en(n)<=6&&r(s)&&r(a))return dn(q(an(n),e[a]*c,u),s);if(!o)throw new RangeError("Need relativeTo");const[d,l]=Zo(n,s,o,i);return Uo(d,o,l,i,!1,t)}(this,o,i,i?i.calendar:void 0))}total(n){const t=function(n){let t,e;return "string"==typeof n?e=n:(e=d(n).unit,t=n.relativeTo),{unit:F(e,void 0,0,9),relativeTo:t}}(n),o=Yo(t.relativeTo);return function(n,t,o,i){if(void 0===o&&en(n)<=6&&r(t))return an(n).toNumber()/e[t];if(!o)throw new RangeError("Need relativeTo");const[s,a]=Zo(n,t,o,i,!0);return Co(s,t,o,a)[b[t]]}(this,t.unit,o,o?o.calendar:void 0)}toString(n){const t=Vn(n,3);return function(n,t){const{smallestUnit:e,fractionalSecondDigits:o,roundingFunc:r}=t,{sign:i}=n,s=n.hours,a=n.minutes;let c=n.seconds,u="";if(e<=3){const t=st(n.milliseconds,n.microseconds,n.nanoseconds,o,r,e);u=t[0],c+=t[1];}const d=void 0!==o||u||!i;return (i<0?"-":"")+"P"+it([[n.years,"Y"],[n.months,"M"],[n.weeks,"W"],[n.days,"D"]])+(s||a||c||d?"T"+it([[s,"H"],[a,"M"],[e<=3?c:0,u+"S",d]]):"")}(Po(this),t)}toLocaleString(n,t){return this.toString()}}function xo(n){return new ko(n.years,n.months,n.weeks,n.days,n.hours,n.minutes,n.seconds,n.milliseconds,n.microseconds,n.nanoseconds)}function jo(n,t,e){const o=Yo(d(e).relativeTo);return xo(function(n,t,e,o){const r=Math.max(en(n),en(t));if(void 0===e&&r<=6)return dn(an(n).add(an(t)),r);if(!e)throw new RangeError("Need relativeTo");const i=e.add(n).add(t);return Dr(e,i,o,r)}(n,t,o,o?o.calendar:void 0))}mt(ko,"Duration");class qo extends U{constructor(n,t,e,o=0,r=0,i=0,s=0,a=0,c=0,u=gr()){const d=Ln({isoYear:n,isoMonth:t,isoDay:e,isoHour:o,isoMinute:r,isoSecond:i,isoMillisecond:s,isoMicrosecond:a,isoNanosecond:c},1),l=N(mr,u);Ke(d,l.toString()),super({...d,calendar:l});}static from(n,t){const e=s$1(t);return Ho(n instanceof qo?n.getISOFields():"object"==typeof n?Me(n,e,t):ne(xt(String(n))))}static compare(n,t){return Rn(N(qo,n),N(qo,t))}with(n,t){const e=s$1(t);return Ho(Te(this,n,e,t))}withPlainDate(n){const t=N(Sr,n);return Ho({...this.getISOFields(),...t.getISOFields(),calendar:Mr(this,t)})}withPlainTime(n){return Ho({...this.getISOFields(),...mo(n).getISOFields()})}withCalendar(n){return Ho({...this.getISOFields(),calendar:N(mr,n)})}add(n,t){return Lo(this,N(ko,n),t)}subtract(n,t){return Lo(this,X(N(ko,n)),t)}until(n,t){return Bo(this,N(qo,n),!1,t)}since(n,t){return Bo(this,N(qo,n),!0,t)}round(n){const t=T(n,0,6);return Ho({...Je(this.getISOFields(),t),calendar:this.calendar})}equals(n){return Pn(this,N(qo,n))}toString(n){const t=Vn(n),e=Jn(n);return _n(Je(this.getISOFields(),t),t)+rt(this.calendar.toString(),e)}toZonedDateTime(n,t){const e=N(we,n),o=yt(e,this,Qn(t));return new Io(o.epochNanoseconds,e,this.calendar)}toPlainYearMonth(){return vo(this.getISOFields())}toPlainMonthDay(){return this.calendar.monthDayFromFields(this)}toPlainDate(){return Ir(this.getISOFields())}toPlainTime(){return fo(this.getISOFields())}}function Ho(n){return new qo(n.isoYear,n.isoMonth,n.isoDay,n.isoHour,n.isoMinute,n.isoSecond,n.isoMillisecond,n.isoMicrosecond,n.isoNanosecond,n.calendar)}function Lo(n,t,e){const o=function(n,t,e){const{calendar:o}=n;return In(Mn(o.dateAdd(Ir(n),_(t,rn),e).getISOFields()).add(un(n)).add(cn(t)))}(n.getISOFields(),t,e);return Ho({...o,calendar:n.calendar})}function Bo(n,t,e,o){const r=O(o,6,0,0,9);return xo(Or(n,t,vr(n,t),e,r))}mt(qo,"PlainDateTime"),dt(qo,v),ft(qo,ht),so(qo,to({year:"numeric",month:"numeric",day:"numeric",weekday:void 0,hour:"numeric",minute:"2-digit",second:"2-digit"},{}));class $o extends U{constructor(n,t,e=gr(),o=pn){super({...Hn({isoYear:o,isoMonth:n,isoDay:t},1),calendar:N(mr,e)});}static from(n,t){if(s$1(t),n instanceof $o)return Ao(n.getISOFields());if("object"==typeof n)return Ie(n,t);const e=function(n){const t=At(n)||Bt(n);if(!t)throw _t("monthDay",n);return t}(String(n));return void 0===e.calendar&&(e.isoYear=pn),Ao(ne(e))}with(n,t){return Ye(this,n,t)}equals(n){return !Rn(this,N($o,n))}toString(n){const t=this.getISOFields(),e=t.calendar.toString(),o=Jn(n);return ("iso8601"===e?function(n){return L(n.isoMonth,2)+"-"+L(n.isoDay,2)}(t):nt(t))+rt(e,o)}toPlainDate(n){return this.calendar.dateFromFields({year:n.year,monthCode:this.monthCode,day:this.day},{overflow:"reject"})}}function Ao(n){return new $o(n.isoMonth,n.isoDay,n.calendar,n.isoYear)}function zo(n){return n instanceof Sr||n instanceof qo||n instanceof Io||n instanceof po||n instanceof $o}function Wo(n,t,e){let o;if(n instanceof Sr)o=n;else if(zo(n)){if(e&&n instanceof $o)throw new TypeError("PlainMonthDay not allowed");o=Ir(n.getISOFields());}else o=Sr.from(n);return br(o.calendar,t),o}function Ko(n,t,e){if(zo(n))return n.getISOFields();let{era:o,eraYear:r,year:i,month:a,monthCode:c,day:u}=n;const d=void 0!==r&&void 0!==o?mn(t.id,r,o):void 0;if(void 0===i){if(void 0===d)throw new TypeError("Must specify either a year or an era & eraYear");i=d;}else if(void 0!==d&&d!==i)throw new RangeError("year and era/eraYear must match");if(void 0===u)throw new TypeError("Must specify day");const l=s$1(e);if(void 0!==c){const[n,e]=t.convertMonthCode(c,i);if(void 0!==a&&a!==n)throw new RangeError("Month doesnt match with monthCode");if(a=n,e){if(1===l)throw new RangeError("Month code out of range");u=t.daysInMonth(i,a);}}else if(void 0===a)throw new TypeError("Must specify either a month or monthCode");return [i,a,u]=qn(i,a,u,t,l),Fn(t.epochMilliseconds(i,a,u))}function Go(n,t){if(zo(n)){if(t&&n instanceof $o)throw new TypeError("PlainMonthDay not allowed");return n.getISOFields()}return Sr.from(n).getISOFields()}function Jo(n,t){return Cn(n.epochMilliseconds(t,1,1),n.epochMilliseconds(t+1,1,1))}function Qo(n,t,e,o){return Cn(n.epochMilliseconds(t,1,1),n.epochMilliseconds(t,e,o))+1}mt($o,"PlainMonthDay"),dt($o),ft($o,["monthCode","day"]),so($o,to({month:"numeric",day:"numeric"},{weekday:void 0,year:void 0,hour:void 0,minute:void 0,second:void 0},!0));const Vo={hebrew:6,chinese:0,dangi:0};class Xo extends fn{constructor(n){const t=_o(n);if(e=n,o=t.resolvedOptions().calendar,gn(e)!==gn(o))throw new RangeError("Invalid calendar: "+n);var e,o;super(n),this.format=t,this.yearCorrection=this.computeFieldsDumb(0).year-1970,this.monthCacheByYear={};}epochMilliseconds(n,t,e){return Un(this.queryMonthCache(n)[0][t-1],e-1)}daysInMonth(n,t){const e=this.queryMonthCache(n)[0],o=e[t-1];t>=e.length&&(n++,t=0);return Cn(o,this.queryMonthCache(n)[0][t])}monthsInYear(n){return this.queryMonthCache(n)[0].length}monthCode(n,t){const e=this.queryLeapMonthByYear(t);return !e||n<e?super.monthCode(n,t):super.monthCode(n-1,t)+(n===e?"L":"")}convertMonthCode(n,t){const e=this.queryLeapMonthByYear(t);let o=/L$/.test(n),r=parseInt(n.substr(1)),i=!1;if(o){const n=Vo[this.id];if(void 0===n)throw new RangeError("Calendar system doesnt support leap months");if(n){if(r!==n-1)throw new RangeError("Invalid leap-month month code")}else if(r<=1||r>=12)throw new RangeError("Invalid leap-month month code")}return !o||e&&r===e-1||(i=!0,o=!1),(o||e&&r>=e)&&r++,[r,i]}inLeapYear(n){const t=Jo(this,n);return t>Jo(this,n-1)&&t>Jo(this,n+1)}guessYearForMonthDay(n,t){let e=1970+this.yearCorrection;const o=e+100;for(;e<o;e++){const[o,r]=this.convertMonthCode(n,e);if(!r&&o<=this.monthsInYear(e)&&t<=this.daysInMonth(e,o))return e}throw new Error("Could not guess year")}normalizeISOYearForMonthDay(n){return n}computeFields(n){const t=this.computeFieldsDumb(n),e=this.queryMonthCache(t.year)[2];return {...t,month:e[t.month]}}computeFieldsDumb(n){const t=re(this.format,n);let e,o,r=parseInt(t.relatedYear||t.year);var i;return t.era&&(i=this.id,void 0!==hn[gn(i)])&&(e=se(t.era),o=r,r=mn(this.id,o,e,!0)),{era:e,eraYear:o,year:r,month:t.month,day:parseInt(t.day)}}queryLeapMonthByYear(n){const t=this.queryMonthCache(n),e=this.queryMonthCache(n-1),o=this.queryMonthCache(n+1);if(t[0].length>e[0].length&&t[0].length>o[0].length){const n=t[1],o=e[1];for(let t=0;t<o.length;t++)if(o[t]!==n[t])return t+1}}queryMonthCache(n){const{monthCacheByYear:t}=this;return t[n]||(t[n]=this.buildMonthCache(n))}buildMonthCache(n){const t=[],e=[],o={};let r=Sn(this.guessISOYear(n),1,1);for(r=Un(r,400);;){const o=this.computeFieldsDumb(r);if(o.year<n)break;r=Un(r,1-o.day),o.year===n&&(t.unshift(r),e.unshift(o.month)),r=Un(r,-1);}for(let n=0;n<e.length;n++)o[e[n]]=n+1;return [t,e,o]}guessISOYear(n){return n-this.yearCorrection}}function _o(n){return new ae("en-US",{calendar:n,era:"short",year:"numeric",month:"short",day:"numeric",timeZone:"UTC"})}const nr=Sn(1868,9,8);const tr={gregory:Gn,japanese:class extends Gn{constructor(){super(...arguments),this.format=_o("japanese");}computeFields(n){const t=super.computeFields(n);if(n>=nr){const e=re(this.format,n);t.era=se(e.era),t.eraYear=parseInt(e.relatedYear||e.year);}return t}},islamic:class extends Xo{guessISOYear(n){return Math.ceil(32*n/33+622)}}},er={iso8601:wn};function or(n){const t=(n=String(n)).toLocaleLowerCase();return er[t]||(er[t]=new(tr[gn(t)]||Xo)(n))}const rr=Sn(1582,10,15),ir=Sn(622,7,18),sr={buddhist:rr,japanese:rr,roc:rr,islamic:ir,"islamic-rgsa":ir,indian:0},ar={};function cr(n,t){return ur(n.div(1e6).toNumber(),t)}function ur(n,t){if(function(n,t){return function(n){let t=ar[n];if(void 0===t){const e=sr[n];if(void 0===e)t=!1;else {let o=or(n);o instanceof Xo||(o=new Xo(n));const r=e-864e5,i=o.computeFields(r);t=r!==o.epochMilliseconds(i.year,i.month,i.day);}ar[n]=t;}return t}(t)&&n<sr[t]}(n,t))throw new RangeError("Invalid timestamp for calendar")}function dr(n,t,e){const o=7+t-e;return -H(Nn(n,1,o)-t,7)+o-1}function lr(n,t,e){const o=dr(n,t,e),r=dr(n+1,t,e);return (Jo(wn,n)-o+r)/7}const[hr,fr]=m$1();class mr extends Y{constructor(n){super(),"islamicc"===n&&(n="islamic-civil"),fr(this,or(n));}static from(n){if(h(n))return function(n){const t=n.calendar;if(void 0===t)return n;if(h(t)&&void 0===t.calendar)return t;return new mr(t)}(n);const t=Bt(String(n),!1,!0);return new mr(t?t.calendar||"iso8601":String(n))}get id(){return this.toString()}era(n){const t=Go(n,!0);return wr(hr(this),t.isoYear,t.isoMonth,t.isoDay).era}eraYear(n){const t=Go(n,!0);return wr(hr(this),t.isoYear,t.isoMonth,t.isoDay).eraYear}year(n){const t=Go(n,!0);return wr(hr(this),t.isoYear,t.isoMonth,t.isoDay).year}month(n){const t=Go(n,!0);return wr(hr(this),t.isoYear,t.isoMonth,t.isoDay).month}monthCode(n){const t=Wo(n,this);return hr(this).monthCode(t.month,t.year)}day(n){const t=Go(n);return wr(hr(this),t.isoYear,t.isoMonth,t.isoDay).day}dayOfWeek(n){const t=Go(n,!0);return Nn(t.isoYear,t.isoMonth,t.isoDay)}dayOfYear(n){const t=Wo(n,this,!0);return Qo(hr(this),t.year,t.month,t.day)}weekOfYear(n){const t=Go(n,!0);return function(n,t,e,o,r){const i=dr(n,o,r),s=Math.floor((Qo(wn,n,t,e)-i-1)/7)+1;if(s<1)return s+lr(n-1,o,r);const a=lr(n,o,r);return s>a?s-a:s}(t.isoYear,t.isoMonth,t.isoDay,1,4)}daysInWeek(n){return Go(n,!0),7}daysInMonth(n){const t=Wo(n,this,!0);return hr(this).daysInMonth(t.year,t.month)}daysInYear(n){const t=Wo(n,this,!0);return Jo(hr(this),t.year)}monthsInYear(n){const t=Wo(n,this,!0);return hr(this).monthsInYear(t.year)}inLeapYear(n){return hr(this).inLeapYear(this.year(n))}dateFromFields(n,t){const e=Ko(u(n,An),hr(this),t);return new Sr(e.isoYear,e.isoMonth,e.isoDay,this)}yearMonthFromFields(n,t){const e=Ko({...u(n,$n),day:1},hr(this),t);return new po(e.isoYear,e.isoMonth,this,e.isoDay)}monthDayFromFields(n,t){const e=hr(this);let{era:o,eraYear:r,year:i,month:s,monthCode:a,day:c}=u(n,Wn);if(void 0===c)throw new TypeError("required property 'day' missing or undefined");if(void 0!==a?i=pn:void 0!==o&&void 0!==r&&(i=mn(e.id,r,o)),void 0===i){if(void 0===a)throw new TypeError("either year or monthCode required with month");i=e.guessYearForMonthDay(a,c);}const d=Ko({year:i,month:s,monthCode:a,day:c},e,t);return new $o(d.isoMonth,d.isoDay,this,e.normalizeISOYearForMonthDay(d.isoYear))}dateAdd(n,e,o){const r=hr(this),i=function(n,e,o,r){n=pt(n=wt(n,e.years,o,r),e.months,o,r);let i=o.epochMilliseconds(n.year,n.month,n.day);const s=Math.trunc(cn(e).div(t).toNumber());return i=Un(i,7*e.weeks+e.days+s),Fn(i)}(N(Sr,n,o),N(ko,e),r,s$1(o));return new Sr(i.isoYear,i.isoMonth,i.isoDay,this)}dateUntil(n,t,e){const o=hr(this),r=N(Sr,n),i=N(Sr,t),s=d(e).largestUnit,a="auto"===s?6:F(s,6,6,9);return br(this,vr(r,i)),xo(function(n,t,e,o){let r=0,i=0,s=0,a=0;switch(o){case 9:r=function(n,t,e){const[,o,r]=qn(t.year,n.month,n.day,e,0),i=xn(t,n),s=P(t.month,o)||P(t.day,r);return t.year-n.year-(s&&i&&s!==i?i:0)}(n,t,e),n=wt(n,r,e,0);case 8:i=function(n,t,e){let o=0;const r=xn(t,n);if(r){let{year:i}=n;for(;i!==t.year;)o+=e.monthsInYear(i)*r,i+=r;const[,s,a]=qn(t.year,n.month,n.day,e,0);o+=t.month-s;const c=P(t.day,a);c&&r&&c!==r&&(o-=r);}return o}(n,t,e),n=pt(n,i,e,0);}a=Cn(e.epochMilliseconds(n.year,n.month,n.day),e.epochMilliseconds(t.year,t.month,t.day)),7===o&&(s=Math.trunc(a/7),a%=7);return nn({years:r,months:i,weeks:s,days:a,hours:0,minutes:0,seconds:0,milliseconds:0,microseconds:0,nanoseconds:0})}(r,i,o,a))}fields(n){return n.slice()}mergeFields(n,t){return yr(n,t)}toString(){return hr(this).id}}function gr(){return new mr("iso8601")}function yr(n,t){var e;const o={...n,...t};if(void 0!==n.year){delete o.era,delete o.eraYear,delete o.year;let e=!1;void 0===t.era&&void 0===t.eraYear||(o.era=t.era,o.eraYear=t.eraYear,e=!0),void 0!==t.year&&(o.year=t.year,e=!0),e||(o.year=n.year);}if(void 0!==n.monthCode){delete o.monthCode,delete o.month;let e=!1;void 0!==t.month&&(o.month=t.month,e=!0),void 0!==t.monthCode&&(o.monthCode=t.monthCode,e=!0),e||(o.monthCode=n.monthCode);}return void 0!==n.day&&(o.day=null!=(e=t.day)?e:n.day),o}function wr(n,t,e,o){const r=Sn(t,e,o);return ur(r,n.id),n.computeFields(r)}function pr(n){return void 0===n.calendar?gr():N(mr,n.calendar)}function vr(n,t){const{calendar:e}=n;return br(e,t.calendar),e}function Mr(n,t){const e=n.calendar,o=t.calendar;if("iso8601"===e.id)return o;if("iso8601"===o.id)return e;if(e.id!==o.id)throw new RangeError("Non-ISO calendars incompatible");return e}function br(n,t){if(n.toString()!==t.toString())throw new RangeError("Calendars must match")}mt(mr,"Calendar");class Sr extends U{constructor(n,t,e,o=gr()){const r=Hn({isoYear:n,isoMonth:t,isoDay:e},1),i=N(mr,o);!function(n,t){const e=Mn(n);Ge(e.add(e.sign()<0?86399999999999:0)),cr(e,t);}(r,i.toString()),super({...r,calendar:i});}static from(n,t){return s$1(t),n instanceof Sr?Ir(n.getISOFields()):"object"==typeof n?be(n,t):Ir(ne(xt(String(n))))}static compare(n,t){return Rn(N(Sr,n),N(Sr,t))}with(n,t){return De(this,n,t)}withCalendar(n){const t=this.getISOFields();return new Sr(t.isoYear,t.isoMonth,t.isoDay,n)}add(n,t){return this.calendar.dateAdd(this,n,t)}subtract(n,t){return this.calendar.dateAdd(this,N(ko,n).negated(),t)}until(n,t){return Fr(this,N(Sr,n),!1,t)}since(n,t){return Fr(this,N(Sr,n),!0,t)}equals(n){return !Rn(this,N(Sr,n))}toString(n){const t=Jn(n),e=this.getISOFields();return nt(e)+rt(e.calendar.toString(),t)}toZonedDateTime(n){const t=function(n){let t,e;if("string"==typeof n)e=n;else {if("object"!=typeof n)throw new TypeError("Invalid options/timeZone argument");if(void 0!==n.id?e=n:(e=n.timeZone,t=n.plainTime),void 0===e)throw new TypeError("Invalid timeZone argument")}return {plainTime:t,timeZone:e}}(n),e=N(we,t.timeZone),o=void 0===t.plainTime?void 0:N(ho,t.plainTime);return Fo({...this.getISOFields(),...o?o.getISOFields():on,timeZone:e})}toPlainDateTime(n){return Ho({...this.getISOFields(),...mo(n).getISOFields()})}toPlainYearMonth(){return vo(this.getISOFields())}toPlainMonthDay(){return this.calendar.monthDayFromFields(this)}}function Ir(n){return new Sr(n.isoYear,n.isoMonth,n.isoDay,n.calendar)}function Fr(n,t,e,o){return xo(Tr(n,t,vr(n,t),e,O(o,6,6,6,9)))}function Or(n,t,e,o,r){return Uo(Dr(n,t,e,r.largestUnit),n,t,e,o,r)}function Tr(n,t,e,o,r){return Uo(e.dateUntil(n,t,{largestUnit:M[r.largestUnit]}),n,t,e,o,r)}function Dr(n,t,e,o){if(!i(o))return Nr(n,t,o);const r=Ir({...n.getISOFields(),calendar:e});let s,a,c,u,d,l=Ir({...t.getISOFields(),calendar:e});do{a=e.dateUntil(r,l,{largestUnit:M[o]}),s=n.add(a),c=Nr(s,t,5),u=a.sign,d=c.sign;}while(u&&d&&u!==d&&(l=l.add({days:d})));return f=c,{sign:(h=a).sign||f.sign,years:h.years+f.years,months:h.months+f.months,weeks:h.weeks+f.weeks,days:h.days+f.days,hours:h.hours+f.hours,minutes:h.minutes+f.minutes,seconds:h.seconds+f.seconds,milliseconds:h.milliseconds+f.milliseconds,microseconds:h.microseconds+f.microseconds,nanoseconds:h.nanoseconds+f.nanoseconds};var h,f;}function Nr(n,t,e){return dn(On(t).sub(On(n)),e)}mt(Sr,"PlainDate"),dt(Sr),ft(Sr,ht),so(Sr,to({year:"numeric",month:"numeric",day:"numeric",weekday:void 0},{hour:void 0,minute:void 0,second:void 0}));class Yr extends E{constructor(n){super();const t=K(n,!0);!function(n){-1!==G(n,Ae)&&1!==G(n,$e)||Zn();}(t),this[vn]=t;}static from(n){if(n instanceof Yr)return new Yr(n.epochNanoseconds);const t=kt(String(n)),e=t.offsetNanoseconds;if(void 0===e)throw new RangeError("Must specify an offset");return new Yr(Mn(Ln(t,1)).sub(e))}static fromEpochSeconds(n){return new Yr(K(n).mult(1e9))}static fromEpochMilliseconds(n){return new Yr(K(n).mult(1e6))}static fromEpochMicroseconds(n){return new Yr(n*BigInt(1e3))}static fromEpochNanoseconds(n){return new Yr(n)}static compare(n,t){return jn(N(Yr,n),N(Yr,t))}add(n){return new Yr(Mt(this[vn],N(ko,n)))}subtract(n){return new Yr(Mt(this[vn],X(N(ko,n))))}until(n,t){return Er(this,N(Yr,n),t)}since(n,t){return Er(N(Yr,n),this,t)}round(n){const t=T(n,0,5,!0);return new Yr(Ve(this[vn],t))}equals(n){return !jn(this,N(Yr,n))}toString(n){const t=d(n).timeZone;return this.toZonedDateTimeISO(null!=t?t:"UTC").toString({...n,offset:void 0===t?"never":"auto",timeZoneName:"never"})+(void 0===t?"Z":"")}toZonedDateTimeISO(n){return new Io(this.epochNanoseconds,n)}toZonedDateTime(n){if(!h(n))throw new TypeError("Must specify options");if(void 0===n.calendar)throw new TypeError("Must specify a calendar");if(void 0===n.timeZone)throw new TypeError("Must specify a timeZone");return new Io(this.epochNanoseconds,n.timeZone,n.calendar)}}function Er(n,t,o){const r=O(o,3,0,0,5);return xo(function(n,t,o){return dn(q(t.sub(n),e[o.smallestUnit]*o.roundingIncrement,o.roundingFunc),o.largestUnit)}(n[vn],t[vn],r))}function Zr(){return Yr.fromEpochMilliseconds(this.valueOf())}mt(Yr,"Instant"),at(Yr),so(Yr,_e({year:"numeric",month:"numeric",day:"numeric",weekday:void 0,hour:"numeric",minute:"2-digit",second:"2-digit"},{timeZoneName:void 0},{}));const Cr=Symbol(),Ur=Symbol(),Pr=Symbol();class Rr extends Intl.DateTimeFormat{constructor(n,t){const e=ce(n),o=function(n){const t={};for(const e in n){let o=n[e];h(o)&&(o=o.toString()),t[e]=o;}return t}(t||{});super(e,o),this[Cr]=e,this[Ur]=o,this[Pr]=new Map;}format(n){const t=xr(this,n);return t[0]===this?super.format(t[1]):t[0].format(t[1])}formatToParts(n){return super.formatToParts.call(...xr(this,n))}formatRange(n,t){return super.formatRange.call(...jr(this,n,t))}formatRangeToParts(n,t){return super.formatRangeToParts.call(...jr(this,n,t))}}const kr=Rr;function xr(n,t){const e=ao(t);if(e){const o=qr(n,e);return [o.buildFormat(t),o.buildEpochMilli(t)]}return [n,t]}function jr(n,t,e){const o=ao(t);if(o!==ao(e))throw new TypeError("Mismatch of types");if(o){const r=qr(n,o);return [r.buildFormat(t,e),new Date(r.buildEpochMilli(t)),new Date(r.buildEpochMilli(e))]}return [n,t,e]}function qr(n,t){const e=n[Pr];let o=e.get(t);return o||(o=function(n){const t={};return {buildFormat:function(e,o){const r=n.buildKey(e,o),i=r.join("|");return t[i]||(t[i]=n.buildFormat(...r))},buildEpochMilli:n.buildEpochMilli}}(t(n[Cr],n[Ur])),e.set(t,o)),o}const Hr={zonedDateTimeISO:function(n){return Fo(Br("iso8601",n))},zonedDateTime:function(n,t){return Fo(Br(n,t))},plainDateTimeISO:function(n){return Ho(Br("iso8601",n))},plainDateTime:function(n,t){return Ho(Br(n,t))},plainDateISO:function(n){return Ir(Br("iso8601",n))},plainDate:function(n,t){return Ir(Br(n,t))},plainTimeISO:function(n){return fo(Br("iso8601",n))},instant:function(){return new Yr($r())},timeZone:Lr};mt(Hr,"Now");function Lr(){return new we((new ae).resolvedOptions().timeZone)}function Br(n,t=Lr()){const e=N(we,t);return {...Oo($r(),e)[0],timeZone:e,calendar:N(mr,n)}}function $r(){return K(Date.now()).mult(1e6)}const Ar={PlainYearMonth:po,PlainMonthDay:$o,PlainDate:Sr,PlainTime:ho,PlainDateTime:qo,ZonedDateTime:Io,Instant:Yr,Calendar:mr,TimeZone:we,Duration:ko,Now:Hr,[Symbol.toStringTag]:"Temporal"};function zr(){return "undefined"!=typeof globalThis?globalThis:window}

const s=Ar;

/**
 * java.lang.Math.toRadians
 * @private
 * @param degrees
 */
function degreesToRadians(degrees) {
    return (degrees * Math.PI) / 180;
}
/**
 * java.lang.Math.toDegrees
 * @private
 * @param radians
 */
function radiansToDegrees(radians) {
    return (radians * 180) / Math.PI;
}
/**
 * A class that contains location information such as latitude and longitude required for astronomical calculations. The
 * elevation field may not be used by some calculation engines and would be ignored if set.
 *
 * @author &copy; Eliyahu Hershfeld 2004 - 2016
 * @version 1.1
 */
class GeoLocation {
    /**
     * GeoLocation constructor with parameters for all required fields.
     *
     * @param {string} name
     *            The location name for display use such as &quot;Lakewood, NJ&quot;
     * @param {number} latitude
     *            the latitude in a double format such as 40.095965 for Lakewood, NJ.
     *            <b>Note: </b> For latitudes south of the equator, a negative value should be used.
     * @param {number} longitude
     *            double the longitude in a double format such as -74.222130 for Lakewood, NJ.
     *            <b>Note: </b> For longitudes west of the <a href="http://en.wikipedia.org/wiki/Prime_Meridian">Prime
     *            Meridian </a> (Greenwich), a negative value should be used.
     * @param {number} elevation
     *            the elevation above sea level in Meters. Elevation is not used in most algorithms used for calculating
     *            sunrise and set.
     * @param {string} timeZoneId
     *            the <code>TimeZone</code> for the location.
     */
    constructor(name, latitude, longitude, elevation, timeZoneId) {
        this.setLocationName(name);
        this.setLatitude(latitude);
        this.setLongitude(longitude);
        this.setElevation(elevation);
        this.setTimeZone(timeZoneId);
    }
    /**
     * @private
     */
    latitude;
    /**
     * @private
     */
    longitude;
    /**
     * @private
     */
    locationName = null;
    /**
     * @private
     */
    timeZoneId;
    /**
     * @private
     */
    elevation;
    /**
     * Method to get the elevation in Meters.
     *
     * @return {number} Returns the elevation in Meters.
     */
    getElevation() {
        return this.elevation;
    }
    /**
     * Method to set the elevation in Meters <b>above </b> sea level.
     *
     * @param {number} elevation
     *            The elevation to set in Meters. An Error will be thrown if the value is a negative.
     */
    setElevation(elevation) {
        if (typeof elevation !== 'number')
            throw new TypeError('Invalid elevation');
        if (elevation < 0) {
            throw new RangeError(`elevation ${elevation} must be zero or positive`);
        }
        this.elevation = elevation;
    }
    setLatitude(latitude) {
        if (typeof latitude !== 'number')
            throw new TypeError('Invalid latitude');
        if (latitude < -90 || latitude > 90) {
            throw new RangeError(`Latitude ${latitude} out of range [-90,90]`);
        }
        this.latitude = latitude;
    }
    /**
     * @return {number} Returns the latitude.
     */
    getLatitude() {
        return this.latitude;
    }
    setLongitude(longitude) {
        if (typeof longitude !== 'number')
            throw new TypeError('Invalid longitude');
        if (longitude < -180 || longitude > 180) {
            throw new RangeError(`Longitude ${longitude} out of range [-180,180]`);
        }
        this.longitude = longitude;
    }
    /**
     * @return {number} Returns the longitude.
     */
    getLongitude() {
        return this.longitude;
    }
    /**
     * @return {string|null} Returns the location name.
     */
    getLocationName() {
        return this.locationName;
    }
    /**
     * @param {string|null} name
     *            The setter method for the display name.
     */
    setLocationName(name) {
        this.locationName = name;
    }
    /**
     * @return {string} Returns the timeZone.
     */
    getTimeZone() {
        return this.timeZoneId;
    }
    /**
     * Method to set the TimeZone.
     * @param {string} timeZoneId
     *            The timeZone to set.
     */
    setTimeZone(timeZoneId) {
        this.timeZoneId = timeZoneId;
    }
}
/**
 * The commonly used average solar refraction. Calendrical Calculations lists a more accurate global average of
 * 34.478885263888294
 * @private
 */
const refraction = 34 / 60;
// private double refraction = 34.478885263888294 / 60d;
/**
 * The commonly used average solar radius in minutes of a degree.
 * @private
 */
const solarRadius = 16 / 60;
/**
 * The commonly used average earth radius in KM. At this time, this only affects elevation adjustment and not the
 * sunrise and sunset calculations. The value currently defaults to 6356.9 KM.
 * @private
 */
const earthRadius = 6356.9; // in KM
/**
 * Implementation of sunrise and sunset methods to calculate astronomical times based on the <a
 * href="http://noaa.gov">NOAA</a> algorithm. This calculator uses the Java algorithm based on the implementation by <a
 * href="http://noaa.gov">NOAA - National Oceanic and Atmospheric Administration</a>'s <a href =
 * "http://www.srrb.noaa.gov/highlights/sunrise/sunrise.html">Surface Radiation Research Branch</a>. NOAA's <a
 * href="http://www.srrb.noaa.gov/highlights/sunrise/solareqns.PDF">implementation</a> is based on equations from <a
 * href="http://www.willbell.com/math/mc1.htm">Astronomical Algorithms</a> by <a
 * href="http://en.wikipedia.org/wiki/Jean_Meeus">Jean Meeus</a>. Added to the algorithm is an adjustment of the zenith
 * to account for elevation. The algorithm can be found in the <a
 * href="http://en.wikipedia.org/wiki/Sunrise_equation">Wikipedia Sunrise Equation</a> article.
 *
 * @author &copy; Eliyahu Hershfeld 2011 - 2019
 */
class NOAACalculator {
    /**
     * A constructor that takes in <a href="http://en.wikipedia.org/wiki/Geolocation">geolocation</a> information as a
     * parameter.
     *
     * @param {GeoLocation} geoLocation
     *            The location information used for calculating astronomical sun times.
     * @param {Temporal.PlainDate} date
     */
    constructor(geoLocation, date) {
        this.date = date;
        this.geoLocation = geoLocation;
    }
    /**
     * The zenith of astronomical sunrise and sunset. The sun is 90&deg; from the vertical 0&deg;
     * @private
     */
    static GEOMETRIC_ZENITH = 90;
    /**
     * Default value for Sun's zenith and true rise/set Zenith (used in this class and subclasses) is the angle that the
     * center of the Sun makes to a line perpendicular to the Earth's surface. If the Sun were a point and the Earth
     * were without an atmosphere, true sunset and sunrise would correspond to a 90&deg; zenith. Because the Sun is not
     * a point, and because the atmosphere refracts light, this 90&deg; zenith does not, in fact, correspond to true
     * sunset or sunrise, instead the center of the Sun's disk must lie just below the horizon for the upper edge to be
     * obscured. This means that a zenith of just above 90&deg; must be used. The Sun subtends an angle of 16 minutes of
     * arc, and atmospheric refraction accounts for
     * 34 minutes or so, giving a total of 50
     * arcminutes. The total value for ZENITH is 90+(5/6) or 90.8333333&deg; for true sunrise/sunset.
     */
    // const ZENITH: number = GEOMETRIC_ZENITH + 5.0 / 6.0;
    /** Sun's zenith at civil twilight (96&deg;). */
    static CIVIL_ZENITH = 96;
    /** Sun's zenith at nautical twilight (102&deg;). */
    static NAUTICAL_ZENITH = 102;
    /** Sun's zenith at astronomical twilight (108&deg;). */
    static ASTRONOMICAL_ZENITH = 108;
    /**
     * The Java Calendar encapsulated by this class to track the current date used by the class
     * @private
     */
    date;
    /**
     * the {@link GeoLocation} used for calculations.
     * @private
     */
    geoLocation;
    /**
     * The getSunrise method Returns a `Date` representing the
     * {@link getElevationAdjustment elevation adjusted} sunrise time. The zenith used
     * for the calculation uses {@link GEOMETRIC_ZENITH geometric zenith} of 90&deg; plus
     * {@link getElevationAdjustment}. This is adjusted
     * to add approximately 50/60 of a degree to account for 34 archminutes of refraction
     * and 16 archminutes for the sun's radius for a total of {@link adjustZenith 90.83333&deg;}.
     *
     * @return {Temporal.ZonedDateTime | null} the `Date` representing the exact sunrise time. If the calculation can't be computed such as
     *         in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
     *         does not set, a null will be returned. See detailed explanation on top of the page.
     * @see adjustZenith
     * @see getSeaLevelSunrise()
     * @see getUTCSunrise
     */
    getSunrise() {
        const sunrise = this.getUTCSunrise0(NOAACalculator.GEOMETRIC_ZENITH);
        if (isNaN(sunrise))
            return null;
        return this.getDateFromTime(sunrise, true);
    }
    /**
     * A method that returns the sunrise without {@link getElevationAdjustment elevation
     * adjustment}. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible light,
     * something that is not affected by elevation. This method returns sunrise calculated at sea level. This forms the
     * base for dawn calculations that are calculated as a dip below the horizon before sunrise.
     *
     * @return {Temporal.ZonedDateTime | null} the `Date` representing the exact sea-level sunrise time. If the calculation can't be computed
     *         such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
     *         where it does not set, a null will be returned. See detailed explanation on top of the page.
     * @see getSunrise
     * @see getUTCSeaLevelSunrise
     * @see getSeaLevelSunset()
     */
    getSeaLevelSunrise() {
        const sunrise = this.getUTCSeaLevelSunrise(NOAACalculator.GEOMETRIC_ZENITH);
        if (isNaN(sunrise))
            return null;
        return this.getDateFromTime(sunrise, true);
    }
    /**
     * A method that returns the beginning of civil twilight (dawn) using a zenith of {@link CIVIL_ZENITH 96&deg;}.
     *
     * @return {Temporal.ZonedDateTime | null} The `Date` of the beginning of civil twilight using a zenith of 96&deg;. If the calculation
     *         can't be computed, null will be returned. See detailed explanation on top of the page.
     * @see CIVIL_ZENITH
     */
    getBeginCivilTwilight() {
        return this.getSunriseOffsetByDegrees(NOAACalculator.CIVIL_ZENITH);
    }
    /**
     * A method that returns the beginning of nautical twilight using a zenith of {@link NAUTICAL_ZENITH 102&deg;}.
     *
     * @return {Temporal.ZonedDateTime | null} The `Date` of the beginning of nautical twilight using a zenith of 102&deg;. If the
     *         calculation can't be computed null will be returned. See detailed explanation on top of the page.
     * @see NAUTICAL_ZENITH
     */
    getBeginNauticalTwilight() {
        return this.getSunriseOffsetByDegrees(NOAACalculator.NAUTICAL_ZENITH);
    }
    /**
     * A method that returns the beginning of astronomical twilight using a zenith of {@link ASTRONOMICAL_ZENITH
     * 108&deg;}.
     *
     * @return {Temporal.ZonedDateTime | null} The `Date` of the beginning of astronomical twilight using a zenith of 108&deg;. If the
     *         calculation can't be computed, null will be returned. See detailed explanation on top of the page.
     * @see ASTRONOMICAL_ZENITH
     */
    getBeginAstronomicalTwilight() {
        return this.getSunriseOffsetByDegrees(NOAACalculator.ASTRONOMICAL_ZENITH);
    }
    /**
     * The getSunset method Returns a `Date` representing the
     * {@link getElevationAdjustment elevation adjusted} sunset time. The zenith used for
     * the calculation uses {@link GEOMETRIC_ZENITH geometric zenith} of 90&deg; plus
     * {@link getElevationAdjustment}. This is adjusted
     * to add approximately 50/60 of a degree to account for 34 archminutes of refraction
     * and 16 archminutes for the sun's radius for a total of {@link adjustZenith 90.83333&deg;}.
     * Note:
     * In certain cases the calculates sunset will occur before sunrise. This will typically happen when a timezone
     * other than the local timezone is used (calculating Los Angeles sunset using a GMT timezone for example). In this
     * case the sunset date will be incremented to the following date.
     *
     * @return {Temporal.ZonedDateTime | null} The `Date` representing the exact sunset time. If the calculation can't be computed such as in
     *         the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
     *         does not set, a null will be returned. See detailed explanation on top of the page.
     * @see adjustZenith
     * @see getSeaLevelSunset()
     * @see getUTCSunset
     */
    getSunset() {
        const sunset = this.getUTCSunset0(NOAACalculator.GEOMETRIC_ZENITH);
        if (isNaN(sunset))
            return null;
        return this.getDateFromTime(sunset, false);
    }
    /**
     * A method that returns the sunset without {@link getElevationAdjustment elevation
     * adjustment}. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible light,
     * something that is not affected by elevation. This method returns sunset calculated at sea level. This forms the
     * base for dusk calculations that are calculated as a dip below the horizon after sunset.
     *
     * @return {Temporal.ZonedDateTime | null} The `Date` representing the exact sea-level sunset time. If the calculation can't be computed
     *         such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
     *         where it does not set, a null will be returned. See detailed explanation on top of the page.
     * @see getSunset
     * @see getUTCSeaLevelSunset
     */
    getSeaLevelSunset() {
        const sunset = this.getUTCSeaLevelSunset(NOAACalculator.GEOMETRIC_ZENITH);
        if (isNaN(sunset))
            return null;
        return this.getDateFromTime(sunset, false);
    }
    /**
     * A method that returns the end of civil twilight using a zenith of {@link CIVIL_ZENITH 96&deg;}.
     *
     * @return {Temporal.ZonedDateTime | null} The `Date` of the end of civil twilight using a zenith of {@link CIVIL_ZENITH 96&deg;}. If
     *         the calculation can't be computed, null will be returned. See detailed explanation on top of the page.
     * @see CIVIL_ZENITH
     */
    getEndCivilTwilight() {
        return this.getSunsetOffsetByDegrees(NOAACalculator.CIVIL_ZENITH);
    }
    /**
     * A method that returns the end of nautical twilight using a zenith of {@link NAUTICAL_ZENITH 102&deg;}.
     *
     * @return {Temporal.ZonedDateTime | null} The `Date` of the end of nautical twilight using a zenith of {@link NAUTICAL_ZENITH 102&deg;}
     *         . If the calculation can't be computed, null will be returned. See detailed explanation on top of the
     *         page.
     * @see NAUTICAL_ZENITH
     */
    getEndNauticalTwilight() {
        return this.getSunsetOffsetByDegrees(NOAACalculator.NAUTICAL_ZENITH);
    }
    /**
     * A method that returns the end of astronomical twilight using a zenith of {@link ASTRONOMICAL_ZENITH 108&deg;}.
     *
     * @return {Temporal.ZonedDateTime | null} The `Date` of the end of astronomical twilight using a zenith of {@link ASTRONOMICAL_ZENITH
     *         108&deg;}. If the calculation can't be computed, null will be returned. See detailed explanation on top
     *         of the page.
     * @see ASTRONOMICAL_ZENITH
     */
    getEndAstronomicalTwilight() {
        return this.getSunsetOffsetByDegrees(NOAACalculator.ASTRONOMICAL_ZENITH);
    }
    /**
     * A utility method that returns a date offset by the offset time passed in. Please note that the level of light
     * during twilight is not affected by elevation, so if this is being used to calculate an offset before sunrise or
     * after sunset with the intent of getting a rough "level of light" calculation, the sunrise or sunset time passed
     * to this method should be sea level sunrise and sunset.
     *
     * @param {Temporal.ZonedDateTime | null} time
     *            the start time
     * @param {number} offset
     *            the offset in milliseconds to add to the time.
     * @return {Temporal.ZonedDateTime | null} the `Date` with the offset in milliseconds added to it
     */
    static getTimeOffset(time, offset) {
        if (time === null || isNaN(offset)) {
            return null;
        }
        return time.add({ milliseconds: offset });
    }
    /**
     * A utility method that returns the time of an offset by degrees below or above the horizon of
     * {@link getSunrise() sunrise}. Note that the degree offset is from the vertical, so for a calculation of 14&deg;
     * before sunrise, an offset of 14 + {@link GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.
     *
     * @param {number} offsetZenith
     *            the degrees before {@link getSunrise} to use in the calculation. For time after sunrise use
     *            negative numbers. Note that the degree offset is from the vertical, so for a calculation of 14&deg;
     *            before sunrise, an offset of 14 + {@link GEOMETRIC_ZENITH} = 104 would have to be passed as a
     *            parameter.
     * @return {Temporal.ZonedDateTime | null} The `Date` of the offset after (or before) {@link getSunrise}. If the calculation
     *         can't be computed such as in the Arctic Circle where there is at least one day a year where the sun does
     *         not rise, and one where it does not set, a null will be returned. See detailed explanation on top of the
     *         page.
     */
    getSunriseOffsetByDegrees(offsetZenith) {
        const dawn = this.getUTCSunrise0(offsetZenith);
        if (isNaN(dawn))
            return null;
        return this.getDateFromTime(dawn, true);
    }
    /**
     * A utility method that returns the time of an offset by degrees below or above the horizon of {@link getSunset()
     * sunset}. Note that the degree offset is from the vertical, so for a calculation of 14&deg; after sunset, an
     * offset of 14 + {@link GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.
     *
     * @param {number} offsetZenith
     *            the degrees after {@link getSunset} to use in the calculation. For time before sunset use negative
     *            numbers. Note that the degree offset is from the vertical, so for a calculation of 14&deg; after
     *            sunset, an offset of 14 + {@link GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.
     * @return {Temporal.ZonedDateTime | null} The `Date`of the offset after (or before) {@link getSunset}. If the calculation can't
     *         be computed such as in the Arctic Circle where there is at least one day a year where the sun does not
     *         rise, and one where it does not set, a null will be returned. See detailed explanation on top of the
     *         page.
     */
    getSunsetOffsetByDegrees(offsetZenith) {
        const sunset = this.getUTCSunset0(offsetZenith);
        if (isNaN(sunset))
            return null;
        return this.getDateFromTime(sunset, false);
    }
    /**
     * A method that returns the sunrise in UTC time without correction for time zone offset from GMT and without using
     * daylight savings time.
     *
     * @param {number} zenith
     *            the degrees below the horizon. For time after sunrise use negative numbers.
     * @return {number} The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
     *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
     *         not set, `NaN` will be returned. See detailed explanation on top of the page.
     */
    getUTCSunrise0(zenith) {
        return this.getUTCSunrise(this.getAdjustedDate(), this.geoLocation, zenith, true);
    }
    /**
     * A method that returns the sunrise in UTC time without correction for time zone offset from GMT and without using
     * daylight savings time. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible
     * light, something that is not affected by elevation. This method returns UTC sunrise calculated at sea level. This
     * forms the base for dawn calculations that are calculated as a dip below the horizon before sunrise.
     *
     * @param {number} zenith
     *            the degrees below the horizon. For time after sunrise use negative numbers.
     * @return {number} The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
     *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
     *         not set, `NaN` will be returned. See detailed explanation on top of the page.
     * @see getUTCSunrise
     * @see getUTCSeaLevelSunset
     */
    getUTCSeaLevelSunrise(zenith) {
        return this.getUTCSunrise(this.getAdjustedDate(), this.geoLocation, zenith, false);
    }
    /**
     * A method that returns the sunset in UTC time without correction for time zone offset from GMT and without using
     * daylight savings time.
     *
     * @param {number} zenith
     *            the degrees below the horizon. For time after sunset use negative numbers.
     * @return {number} The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
     *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
     *         not set, `NaN` will be returned. See detailed explanation on top of the page.
     * @see getUTCSeaLevelSunset
     */
    getUTCSunset0(zenith) {
        return this.getUTCSunset(this.getAdjustedDate(), this.geoLocation, zenith, true);
    }
    /**
     * A method that returns the sunset in UTC time without correction for elevation, time zone offset from GMT and
     * without using daylight savings time. Non-sunrise and sunset calculations such as dawn and dusk, depend on the
     * amount of visible light, something that is not affected by elevation. This method returns UTC sunset calculated
     * at sea level. This forms the base for dusk calculations that are calculated as a dip below the horizon after
     * sunset.
     *
     * @param {number} zenith
     *            the degrees below the horizon. For time before sunset use negative numbers.
     * @return {number} The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
     *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
     *         not set, `NaN` will be returned. See detailed explanation on top of the page.
     * @see getUTCSunset
     * @see getUTCSeaLevelSunrise
     */
    getUTCSeaLevelSunset(zenith) {
        return this.getUTCSunset(this.getAdjustedDate(), this.geoLocation, zenith, false);
    }
    /**
     * Adjusts the <code>Calendar</code> to deal with edge cases where the location crosses the antimeridian.
     * @private
     * @see GeoLocation#getAntimeridianAdjustment()
     * @return the adjusted Calendar
     */
    getAdjustedDate() {
        return this.date;
    }
    /**
     * Method to return the adjustment to the zenith required to account for the elevation. Since a person at a higher
     * elevation can see farther below the horizon, the calculation for sunrise / sunset is calculated below the horizon
     * used at sea level. This is only used for sunrise and sunset and not times before or after it such as
     * {@link getBeginNauticalTwilight() nautical twilight} since those
     * calculations are based on the level of available light at the given dip below the horizon, something that is not
     * affected by elevation, the adjustment should only made if the zenith == 90&deg; {@link adjustZenith adjusted}
     * for refraction and solar radius. The algorithm used is
     *
     * <pre>
     * elevationAdjustment = Math.toDegrees(Math.acos(earthRadiusInMeters / (earthRadiusInMeters + elevationMeters)));
     * </pre>
     *
     * The source of this algorithm is <a href="http://www.calendarists.com">Calendrical Calculations</a> by Edward M.
     * Reingold and Nachum Dershowitz. An alternate algorithm that produces an almost identical (but not accurate)
     * result found in Ma'aglay Tzedek by Moishe Kosower and other sources is:
     *
     * <pre>
     * elevationAdjustment = 0.0347 * Math.sqrt(elevationMeters);
     * </pre>
     *
     * @param {number} elevation
     *            elevation in Meters.
     * @return {number} the adjusted zenith
     */
    getElevationAdjustment(elevation) {
        // double elevationAdjustment = 0.0347 * Math.sqrt(elevation);
        const elevationAdjustment = radiansToDegrees(Math.acos(earthRadius / (earthRadius + elevation / 1000)));
        return elevationAdjustment;
    }
    /**
     * Adjusts the zenith of astronomical sunrise and sunset to account for solar refraction, solar radius and
     * elevation. The value for Sun's zenith and true rise/set Zenith (used in this class and subclasses) is the angle
     * that the center of the Sun makes to a line perpendicular to the Earth's surface. If the Sun were a point and the
     * Earth were without an atmosphere, true sunset and sunrise would correspond to a 90&deg; zenith. Because the Sun
     * is not a point, and because the atmosphere refracts light, this 90&deg; zenith does not, in fact, correspond to
     * true sunset or sunrise, instead the centre of the Sun's disk must lie just below the horizon for the upper edge
     * to be obscured. This means that a zenith of just above 90&deg; must be used. The Sun subtends an angle of 16
     * minutes of arc, and atmospheric refraction
     * accounts for 34 minutes or so, giving a total
     * of 50 arcminutes. The total value for ZENITH is 90+(5/6) or 90.8333333&deg; for true sunrise/sunset. Since a
     * person at an elevation can see blow the horizon of a person at sea level, this will also adjust the zenith to
     * account for elevation if available. Note that this will only adjust the value if the zenith is exactly 90 degrees.
     * For values below and above this no correction is done. As an example, astronomical twilight is when the sun is
     * 18&deg; below the horizon or {@link ASTRONOMICAL_ZENITH 108&deg;
     * below the zenith}. This is traditionally calculated with none of the above mentioned adjustments. The same goes
     * for various <em>tzais</em> and <em>alos</em> times such as the
     * {@link ZmanimCalendar#ZENITH_16_POINT_1 16.1&deg;} dip used in
     * {@link ComplexZmanimCalendar#getAlos16Point1Degrees}.
     *
     * @param {number} zenith
     *            the azimuth below the vertical zenith of 90&deg;. For sunset typically the {@link adjustZenith
     *            zenith} used for the calculation uses geometric zenith of 90&deg; and {@link adjustZenith adjusts}
     *            this slightly to account for solar refraction and the sun's radius. Another example would be
     *            {@link getEndNauticalTwilight} that passes
     *            {@link NAUTICAL_ZENITH} to this method.
     * @param {number} elevation
     *            elevation in Meters.
     * @return {number} The zenith adjusted to include the sun's radius, refracton
     *         and {@link getElevationAdjustment elevation} adjustment. This will only be adjusted for
     *         sunrise and sunset (if the zenith == 90&deg;)
     * @see getElevationAdjustment
     */
    adjustZenith(zenith, elevation) {
        let adjustedZenith = zenith;
        if (zenith === NOAACalculator.GEOMETRIC_ZENITH) {
            // only adjust if it is exactly sunrise or sunset
            adjustedZenith =
                zenith +
                    (solarRadius + refraction + this.getElevationAdjustment(elevation));
        }
        return adjustedZenith;
    }
    /**
     * The <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> of January 1, 2000
     * @private
     */
    static JULIAN_DAY_JAN_1_2000 = 2451545;
    /**
     * Julian days per century
     * @private
     */
    static JULIAN_DAYS_PER_CENTURY = 36525;
    /**
     * A method that calculates UTC sunrise as well as any time based on an angle above or below sunrise.
     * @param date
     *            Used to calculate day of year.
     * @param geoLocation
     *            The location information used for astronomical calculating sun times.
     * @param zenith
     *            the azimuth below the vertical zenith of 90 degrees. for sunrise typically the {@link adjustZenith
     *            zenith} used for the calculation uses geometric zenith of 90&deg; and {@link adjustZenith adjusts}
     *            this slightly to account for solar refraction and the sun's radius. Another example would be
     *            {@link getBeginNauticalTwilight} that passes
     *            {@link NAUTICAL_ZENITH} to this method.
     * @param adjustForElevation
     *            Should the time be adjusted for elevation
     * @return The UTC time of sunrise in 24 hour format. 5:45:00 AM will return 5.75.0. If an error was encountered in
     *         the calculation (expected behavior for some locations such as near the poles,
     *         `NaN` will be returned.
     */
    getUTCSunrise(date, geoLocation, zenith, adjustForElevation) {
        const elevation = adjustForElevation
            ? geoLocation.getElevation()
            : 0;
        const adjustedZenith = this.adjustZenith(zenith, elevation);
        let sunrise = NOAACalculator.getSunriseUTC(NOAACalculator.getJulianDay(date), geoLocation.getLatitude(), -geoLocation.getLongitude(), adjustedZenith);
        sunrise = sunrise / 60;
        // ensure that the time is >= 0 and < 24
        while (sunrise < 0) {
            sunrise += 24;
        }
        while (sunrise >= 24) {
            sunrise -= 24;
        }
        return sunrise;
    }
    /**
     * A method that calculates UTC sunset as well as any time based on an angle above or below sunset.
     * @param date
     *            Used to calculate day of year.
     * @param geoLocation
     *            The location information used for astronomical calculating sun times.
     * @param zenith
     *            the azimuth below the vertical zenith of 90&deg;. For sunset typically the {@link adjustZenith
     *            zenith} used for the calculation uses geometric zenith of 90&deg; and {@link adjustZenith adjusts}
     *            this slightly to account for solar refraction and the sun's radius. Another example would be
     *            {@link getEndNauticalTwilight} that passes
     *            {@link NAUTICAL_ZENITH} to this method.
     * @param adjustForElevation
     *            Should the time be adjusted for elevation
     * @return The UTC time of sunset in 24 hour format. 5:45:00 AM will return 5.75.0. If an error was encountered in
     *         the calculation (expected behavior for some locations such as near the poles,
     *         `NaN` will be returned.
     */
    getUTCSunset(date, geoLocation, zenith, adjustForElevation) {
        const elevation = adjustForElevation
            ? geoLocation.getElevation()
            : 0;
        const adjustedZenith = this.adjustZenith(zenith, elevation);
        let sunset = NOAACalculator.getSunsetUTC(NOAACalculator.getJulianDay(date), geoLocation.getLatitude(), -geoLocation.getLongitude(), adjustedZenith);
        sunset = sunset / 60;
        // ensure that the time is >= 0 and < 24
        while (sunset < 0) {
            sunset += 24;
        }
        while (sunset >= 24) {
            sunset -= 24;
        }
        return sunset;
    }
    /**
     * A utility method that will allow the calculation of a temporal (solar) hour based on the sunrise and sunset
     * passed as parameters to this method. An example of the use of this method would be the calculation of a
     * non-elevation adjusted temporal hour by passing in {@link getSeaLevelSunrise() sea level sunrise} and
     * {@link getSeaLevelSunset() sea level sunset} as parameters.
     *
     * @param {Temporal.ZonedDateTime | null} startOfDay
     *            The start of the day.
     * @param {Temporal.ZonedDateTime | null} endOfDay
     *            The end of the day.
     *
     * @return {number} the <code>long</code> millisecond length of the temporal hour. If the calculation can't be computed a
     *         `NaN` will be returned. See detailed explanation on top of the page.
     *
     * @see getTemporalHour()
     */
    getTemporalHour(startOfDay = this.getSeaLevelSunrise(), endOfDay = this.getSeaLevelSunset()) {
        if (startOfDay === null || endOfDay === null) {
            return NaN;
        }
        const delta = endOfDay.epochMilliseconds - startOfDay.epochMilliseconds;
        return Math.floor(delta / 12);
    }
    /**
     * A method that returns sundial or solar noon. It occurs when the Sun is <a href
     * ="http://en.wikipedia.org/wiki/Transit_%28astronomy%29">transiting</a> the <a
     * href="http://en.wikipedia.org/wiki/Meridian_%28astronomy%29">celestial meridian</a>. In this class it is
     * calculated as halfway between the sunrise and sunset passed to this method. This time can be slightly off the
     * real transit time due to changes in declination (the lengthening or shortening day).
     *
     * @param {Temporal.ZonedDateTime | null} startOfDay
     *            the start of day for calculating the sun's transit. This can be sea level sunrise, visual sunrise (or
     *            any arbitrary start of day) passed to this method.
     * @param {Temporal.ZonedDateTime | null} endOfDay
     *            the end of day for calculating the sun's transit. This can be sea level sunset, visual sunset (or any
     *            arbitrary end of day) passed to this method.
     *
     * @return {Temporal.ZonedDateTime | null} The `Date` representing Sun's transit. If the calculation can't be computed such as in the
     *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
     *         not set, null will be returned. See detailed explanation on top of the page.
     */
    getSunTransit(startOfDay = this.getSeaLevelSunrise(), endOfDay = this.getSeaLevelSunset()) {
        const temporalHour = this.getTemporalHour(startOfDay, endOfDay);
        return NOAACalculator.getTimeOffset(startOfDay, temporalHour * 6);
    }
    /**
     * A method that returns a `Date` from the time passed in as a parameter.
     * @protected
     * @param {number} time
     *            The time to be set as the time for the `Date`. The time expected is in the format: 18.75
     *            for 6:45:00 PM.
     * @param {boolean} isSunrise true if the time is sunrise, and false if it is sunset
     * @return {Temporal.ZonedDateTime | null} The Date.
     */
    getDateFromTime(time, isSunrise) {
        if (isNaN(time)) {
            return null;
        }
        let calculatedTime = time;
        let cal = this.getAdjustedDate();
        //    let cal = new Temporal.PlainDate(adj.year, adj.month, adj.day);
        const hours = Math.trunc(calculatedTime); // retain only the hours
        calculatedTime -= hours;
        const minutes = Math.trunc((calculatedTime *= 60)); // retain only the minutes
        calculatedTime -= minutes;
        const seconds = Math.trunc((calculatedTime *= 60)); // retain only the seconds
        calculatedTime -= seconds; // remaining milliseconds
        // Check if a date transition has occurred, or is about to occur - this indicates the date of the event is
        // actually not the target date, but the day prior or after
        const localTimeHours = Math.trunc(this.geoLocation.getLongitude() / 15);
        if (isSunrise && localTimeHours + hours > 18) {
            cal = cal.add({ days: -1 });
            //      cal = cal.minus({days: 1});
        }
        else if (!isSunrise && localTimeHours + hours < 6) {
            cal = cal.add({ days: 1 });
        }
        return cal
            .toZonedDateTime({
            timeZone: 'UTC',
            plainTime: new s.PlainTime(hours, minutes, seconds, Math.trunc(calculatedTime * 1000)),
        })
            .withTimeZone(this.geoLocation.getTimeZone());
    }
    /**
     * Return the <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> from a Java Calendar
     * @private
     * @param {Temporal.ZonedDateTime} date
     *            The Java Calendar
     * @return the Julian day corresponding to the date Note: Number is returned for start of day. Fractional days
     *         should be added later.
     */
    static getJulianDay(date) {
        let { year, month } = date;
        const { day } = date;
        if (month <= 2) {
            year -= 1;
            month += 12;
        }
        const a = Math.trunc(year / 100);
        const b = Math.trunc(2 - a + a / 4);
        return (Math.floor(365.25 * (year + 4716)) +
            Math.floor(30.6001 * (month + 1)) +
            day +
            b -
            1524.5);
    }
    /**
     * Convert <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> to centuries since J2000.0.
     * @private
     * @param julianDay
     *            the Julian Day to convert
     * @return the centuries since 2000 Julian corresponding to the Julian Day
     */
    static getJulianCenturiesFromJulianDay(julianDay) {
        return ((julianDay - NOAACalculator.JULIAN_DAY_JAN_1_2000) /
            NOAACalculator.JULIAN_DAYS_PER_CENTURY);
    }
    /**
     * Convert centuries since J2000.0 to <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a>.
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @return the Julian Day corresponding to the Julian centuries passed in
     */
    static getJulianDayFromJulianCenturies(julianCenturies) {
        return (julianCenturies * NOAACalculator.JULIAN_DAYS_PER_CENTURY +
            NOAACalculator.JULIAN_DAY_JAN_1_2000);
    }
    /**
     * Returns the Geometric <a href="http://en.wikipedia.org/wiki/Mean_longitude">Mean Longitude</a> of the Sun.
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @return the Geometric Mean Longitude of the Sun in degrees
     */
    static getSunGeometricMeanLongitude(julianCenturies) {
        let longitude = 280.46646 + julianCenturies * (36000.76983 + 0.0003032 * julianCenturies);
        while (longitude > 360) {
            longitude -= 360;
        }
        while (longitude < 0) {
            longitude += 360;
        }
        return longitude; // in degrees
    }
    /**
     * Returns the Geometric <a href="http://en.wikipedia.org/wiki/Mean_anomaly">Mean Anomaly</a> of the Sun.
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @return the Geometric Mean Anomaly of the Sun in degrees
     */
    static getSunGeometricMeanAnomaly(julianCenturies) {
        return (357.52911 + julianCenturies * (35999.05029 - 0.0001537 * julianCenturies)); // in degrees
    }
    /**
     * Return the <a href="http://en.wikipedia.org/wiki/Eccentricity_%28orbit%29">eccentricity of earth's orbit</a>.
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @return the unitless eccentricity
     */
    static getEarthOrbitEccentricity(julianCenturies) {
        return (0.016708634 -
            julianCenturies * (0.000042037 + 0.0000001267 * julianCenturies)); // unitless
    }
    /**
     * Returns the <a href="http://en.wikipedia.org/wiki/Equation_of_the_center">equation of center</a> for the sun.
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @return the equation of center for the sun in degrees
     */
    static getSunEquationOfCenter(julianCenturies) {
        const m = NOAACalculator.getSunGeometricMeanAnomaly(julianCenturies);
        const mrad = degreesToRadians(m);
        const sinm = Math.sin(mrad);
        const sin2m = Math.sin(mrad + mrad);
        const sin3m = Math.sin(mrad + mrad + mrad);
        return (sinm *
            (1.914602 - julianCenturies * (0.004817 + 0.000014 * julianCenturies)) +
            sin2m * (0.019993 - 0.000101 * julianCenturies) +
            sin3m * 0.000289); // in degrees
    }
    /**
     * Return the true longitude of the sun
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @return the sun's true longitude in degrees
     */
    static getSunTrueLongitude(julianCenturies) {
        const sunLongitude = NOAACalculator.getSunGeometricMeanLongitude(julianCenturies);
        const center = NOAACalculator.getSunEquationOfCenter(julianCenturies);
        return sunLongitude + center; // in degrees
    }
    /**
     * Return the apparent longitude of the sun
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @return sun's apparent longitude in degrees
     */
    static getSunApparentLongitude(julianCenturies) {
        const sunTrueLongitude = NOAACalculator.getSunTrueLongitude(julianCenturies);
        const omega = 125.04 - 1934.136 * julianCenturies;
        const lambda = sunTrueLongitude - 0.00569 - 0.00478 * Math.sin(degreesToRadians(omega));
        return lambda; // in degrees
    }
    /**
     * Returns the mean <a href="http://en.wikipedia.org/wiki/Axial_tilt">obliquity of the ecliptic</a> (Axial tilt).
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @return the mean obliquity in degrees
     */
    static getMeanObliquityOfEcliptic(julianCenturies) {
        const seconds = 21.448 -
            julianCenturies *
                (46.815 + julianCenturies * (0.00059 - julianCenturies * 0.001813));
        return 23 + (26 + seconds / 60) / 60; // in degrees
    }
    /**
     * Returns the corrected <a href="http://en.wikipedia.org/wiki/Axial_tilt">obliquity of the ecliptic</a> (Axial
     * tilt).
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @return the corrected obliquity in degrees
     */
    static getObliquityCorrection(julianCenturies) {
        const obliquityOfEcliptic = NOAACalculator.getMeanObliquityOfEcliptic(julianCenturies);
        const omega = 125.04 - 1934.136 * julianCenturies;
        return obliquityOfEcliptic + 0.00256 * Math.cos(degreesToRadians(omega)); // in degrees
    }
    /**
     * Return the <a href="http://en.wikipedia.org/wiki/Declination">declination</a> of the sun.
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @return
     *            the sun's declination in degrees
     */
    static getSunDeclination(julianCenturies) {
        const obliquityCorrection = NOAACalculator.getObliquityCorrection(julianCenturies);
        const lambda = NOAACalculator.getSunApparentLongitude(julianCenturies);
        const sint = Math.sin(degreesToRadians(obliquityCorrection)) *
            Math.sin(degreesToRadians(lambda));
        const theta = radiansToDegrees(Math.asin(sint));
        return theta; // in degrees
    }
    /**
     * Return the <a href="http://en.wikipedia.org/wiki/Equation_of_time">Equation of Time</a> - the difference between
     * true solar time and mean solar time
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @return equation of time in minutes of time
     */
    static getEquationOfTime(julianCenturies) {
        const epsilon = NOAACalculator.getObliquityCorrection(julianCenturies);
        const geomMeanLongSun = NOAACalculator.getSunGeometricMeanLongitude(julianCenturies);
        const eccentricityEarthOrbit = NOAACalculator.getEarthOrbitEccentricity(julianCenturies);
        const geomMeanAnomalySun = NOAACalculator.getSunGeometricMeanAnomaly(julianCenturies);
        let y = Math.tan(degreesToRadians(epsilon) / 2);
        y *= y;
        const sin2l0 = Math.sin(2 * degreesToRadians(geomMeanLongSun));
        const sinm = Math.sin(degreesToRadians(geomMeanAnomalySun));
        const cos2l0 = Math.cos(2 * degreesToRadians(geomMeanLongSun));
        const sin4l0 = Math.sin(4 * degreesToRadians(geomMeanLongSun));
        const sin2m = Math.sin(2 * degreesToRadians(geomMeanAnomalySun));
        const equationOfTime = y * sin2l0 -
            2 * eccentricityEarthOrbit * sinm +
            4 * eccentricityEarthOrbit * y * sinm * cos2l0 -
            0.5 * y * y * sin4l0 -
            1.25 * eccentricityEarthOrbit * eccentricityEarthOrbit * sin2m;
        return radiansToDegrees(equationOfTime) * 4; // in minutes of time
    }
    /**
     * Return the <a href="http://en.wikipedia.org/wiki/Hour_angle">hour angle</a> of the sun at sunrise for the
     * latitude.
     * @private
     * @param {number} lat
     *            , the latitude of observer in degrees
     * @param solarDec
     *            the declination angle of sun in degrees
     * @param {number} zenith
     *            the zenith
     * @return hour angle of sunrise in radians
     */
    static getSunHourAngleAtSunrise(lat, solarDec, zenith) {
        const latRad = degreesToRadians(lat);
        const sdRad = degreesToRadians(solarDec);
        return Math.acos(Math.cos(degreesToRadians(zenith)) /
            (Math.cos(latRad) * Math.cos(sdRad)) -
            Math.tan(latRad) * Math.tan(sdRad)); // in radians
    }
    /**
     * Returns the <a href="http://en.wikipedia.org/wiki/Hour_angle">hour angle</a> of the sun at sunset for the
     * latitude.
     * @private
     * @param {number} lat
     *            the latitude of observer in degrees
     * @param solarDec
     *            the declination angle of sun in degrees
     * @param {number} zenith
     *            the zenith
     * @return the hour angle of sunset in radians
     */
    static getSunHourAngleAtSunset(lat, solarDec, zenith) {
        const latRad = degreesToRadians(lat);
        const sdRad = degreesToRadians(solarDec);
        const hourAngle = Math.acos(Math.cos(degreesToRadians(zenith)) /
            (Math.cos(latRad) * Math.cos(sdRad)) -
            Math.tan(latRad) * Math.tan(sdRad));
        return -hourAngle; // in radians
    }
    /**
     * Return the <a href="http://en.wikipedia.org/wiki/Celestial_coordinate_system">Solar Elevation</a> for the
     * horizontal coordinate system at the given location at the given time. Can be negative if the sun is below the
     * horizon. Not corrected for altitude.
     *
     * @param {Temporal.ZonedDateTime} date
     *            time of calculation
     * @param {number} lat
     *            latitude of location for calculation
     * @param {number} lon
     *            longitude of location for calculation
     * @return {number} solar elevation in degrees - horizon is 0 degrees, civil twilight is -6 degrees
     */
    static getSolarElevation(date, lat, lon) {
        const julianDay = NOAACalculator.getJulianDay(date.toPlainDate());
        const julianCenturies = NOAACalculator.getJulianCenturiesFromJulianDay(julianDay);
        const equationOfTime = NOAACalculator.getEquationOfTime(julianCenturies);
        let longitude = date.hour + 12 + (date.minute + equationOfTime + date.second / 60) / 60;
        longitude = -((longitude * 360) / 24) % 360;
        const hourAngleRad = degreesToRadians(lon - longitude);
        const declination = NOAACalculator.getSunDeclination(julianCenturies);
        const decRad = degreesToRadians(declination);
        const latRad = degreesToRadians(lat);
        return radiansToDegrees(Math.asin(Math.sin(latRad) * Math.sin(decRad) +
            Math.cos(latRad) * Math.cos(decRad) * Math.cos(hourAngleRad)));
    }
    /**
     * Return the <a href="http://en.wikipedia.org/wiki/Celestial_coordinate_system">Solar Azimuth</a> for the
     * horizontal coordinate system at the given location at the given time. Not corrected for altitude. True south is 0
     * degrees.
     *
     * @param {Temporal.ZonedDateTime} date
     *            time of calculation
     * @param {number} latitude
     *            latitude of location for calculation
     * @param {number} lon
     *            longitude of location for calculation
     * @return {number}
     */
    static getSolarAzimuth(date, latitude, lon) {
        const julianDay = NOAACalculator.getJulianDay(date.toPlainDate());
        const julianCenturies = NOAACalculator.getJulianCenturiesFromJulianDay(julianDay);
        const equationOfTime = NOAACalculator.getEquationOfTime(julianCenturies);
        let longitude = date.hour + 12 + (date.minute + equationOfTime + date.second / 60) / 60;
        longitude = -((longitude * 360) / 24) % 360;
        const hourAngleRad = degreesToRadians(lon - longitude);
        const declination = NOAACalculator.getSunDeclination(julianCenturies);
        const decRad = degreesToRadians(declination);
        const latRad = degreesToRadians(latitude);
        return (radiansToDegrees(Math.atan(Math.sin(hourAngleRad) /
            (Math.cos(hourAngleRad) * Math.sin(latRad) -
                Math.tan(decRad) * Math.cos(latRad)))) + 180);
    }
    /**
     * Return the <a href="http://en.wikipedia.org/wiki/Universal_Coordinated_Time">Universal Coordinated Time</a> (UTC)
     * of sunrise for the given day at the given location on earth
     * @private
     * @param julianDay
     *            the Julian day
     * @param {number} latitude
     *            the latitude of observer in degrees
     * @param {number} longitude
     *            the longitude of observer in degrees
     * @param {number} zenith
     *            the zenith
     * @return the time in minutes from zero UTC
     */
    static getSunriseUTC(julianDay, latitude, longitude, zenith) {
        const julianCenturies = NOAACalculator.getJulianCenturiesFromJulianDay(julianDay);
        // Find the time of solar noon at the location, and use that declination. This is better than start of the
        // Julian day
        const noonmin = NOAACalculator.getSolarNoonUTC(julianCenturies, longitude);
        const tnoon = NOAACalculator.getJulianCenturiesFromJulianDay(julianDay + noonmin / 1440);
        // First pass to approximate sunrise (using solar noon)
        let eqTime = NOAACalculator.getEquationOfTime(tnoon);
        let solarDec = NOAACalculator.getSunDeclination(tnoon);
        let hourAngle = NOAACalculator.getSunHourAngleAtSunrise(latitude, solarDec, zenith);
        let delta = longitude - radiansToDegrees(hourAngle);
        let timeDiff = 4 * delta; // in minutes of time
        let timeUTC = 720 + timeDiff - eqTime; // in minutes
        // Second pass includes fractional Julian Day in gamma calc
        const newt = NOAACalculator.getJulianCenturiesFromJulianDay(NOAACalculator.getJulianDayFromJulianCenturies(julianCenturies) +
            timeUTC / 1440);
        eqTime = NOAACalculator.getEquationOfTime(newt);
        solarDec = NOAACalculator.getSunDeclination(newt);
        hourAngle = NOAACalculator.getSunHourAngleAtSunrise(latitude, solarDec, zenith);
        delta = longitude - radiansToDegrees(hourAngle);
        timeDiff = 4 * delta;
        timeUTC = 720 + timeDiff - eqTime; // in minutes
        return timeUTC;
    }
    /**
     * Return the <a href="http://en.wikipedia.org/wiki/Universal_Coordinated_Time">Universal Coordinated Time</a> (UTC)
     * of <a href="http://en.wikipedia.org/wiki/Noon#Solar_noon">solar noon</a> for the given day at the given location
     * on earth.
     * @private
     * @param julianCenturies
     *            the number of Julian centuries since J2000.0
     * @param {number} longitude
     *            the longitude of observer in degrees
     * @return the time in minutes from zero UTC
     */
    static getSolarNoonUTC(julianCenturies, longitude) {
        // First pass uses approximate solar noon to calculate eqtime
        const tnoon = NOAACalculator.getJulianCenturiesFromJulianDay(NOAACalculator.getJulianDayFromJulianCenturies(julianCenturies) +
            longitude / 360);
        let eqTime = NOAACalculator.getEquationOfTime(tnoon);
        const solNoonUTC = 720 + longitude * 4 - eqTime; // min
        const newt = NOAACalculator.getJulianCenturiesFromJulianDay(NOAACalculator.getJulianDayFromJulianCenturies(julianCenturies) -
            0.5 +
            solNoonUTC / 1440);
        eqTime = NOAACalculator.getEquationOfTime(newt);
        return 720 + longitude * 4 - eqTime; // min
    }
    /**
     * Return the <a href="http://en.wikipedia.org/wiki/Universal_Coordinated_Time">Universal Coordinated Time</a> (UTC)
     * of sunset for the given day at the given location on earth
     * @private
     * @param julianDay
     *            the Julian day
     * @param {number} latitude
     *            the latitude of observer in degrees
     * @param {number} longitude
     *            : longitude of observer in degrees
     * @param {number} zenith
     *            the zenith
     * @return the time in minutes from zero Universal Coordinated Time (UTC)
     */
    static getSunsetUTC(julianDay, latitude, longitude, zenith) {
        const julianCenturies = NOAACalculator.getJulianCenturiesFromJulianDay(julianDay);
        // Find the time of solar noon at the location, and use that declination. This is better than start of the
        // Julian day
        const noonmin = NOAACalculator.getSolarNoonUTC(julianCenturies, longitude);
        const tnoon = NOAACalculator.getJulianCenturiesFromJulianDay(julianDay + noonmin / 1440);
        // First calculates sunrise and approx length of day
        let eqTime = NOAACalculator.getEquationOfTime(tnoon);
        let solarDec = NOAACalculator.getSunDeclination(tnoon);
        let hourAngle = NOAACalculator.getSunHourAngleAtSunset(latitude, solarDec, zenith);
        let delta = longitude - radiansToDegrees(hourAngle);
        let timeDiff = 4 * delta;
        let timeUTC = 720 + timeDiff - eqTime;
        // Second pass includes fractional Julian Day in gamma calc
        const newt = NOAACalculator.getJulianCenturiesFromJulianDay(NOAACalculator.getJulianDayFromJulianCenturies(julianCenturies) +
            timeUTC / 1440);
        eqTime = NOAACalculator.getEquationOfTime(newt);
        solarDec = NOAACalculator.getSunDeclination(newt);
        hourAngle = NOAACalculator.getSunHourAngleAtSunset(latitude, solarDec, zenith);
        delta = longitude - radiansToDegrees(hourAngle);
        timeDiff = 4 * delta;
        timeUTC = 720 + timeDiff - eqTime; // in minutes
        return timeUTC;
    }
}

/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
const classicCities0 = [['Ashdod', 'IL', 31.79213, 34.64966, 'Asia/Jerusalem', 27], ['Atlanta', 'US', 33.749, -84.38798, 'America/New_York', 336], ['Austin', 'US', 30.26715, -97.74306, 'America/Chicago', 165], ['Baghdad', 'IQ', 33.34058, 44.40088, 'Asia/Baghdad', 41], ['Beer Sheva', 'IL', 31.25181, 34.7913, 'Asia/Jerusalem', 285], ['Berlin', 'DE', 52.52437, 13.41053, 'Europe/Berlin', 43], ['Baltimore', 'US', 39.29038, -76.61219, 'America/New_York', 35], ['Bogota', 'CO', 4.60971, -74.08175, 'America/Bogota', 2582], ['Boston', 'US', 42.35843, -71.05977, 'America/New_York', 38], ['Budapest', 'HU', 47.49801, 19.03991, 'Europe/Budapest', 104], ['Buenos Aires', 'AR', -34.61315, -58.37723, 'America/Argentina/Buenos_Aires', 31], ['Buffalo', 'US', 42.88645, -78.87837, 'America/New_York', 191], ['Chicago', 'US', 41.85003, -87.65005, 'America/Chicago', 180], ['Cincinnati', 'US', 39.162, -84.45689, 'America/New_York', 267], ['Cleveland', 'US', 41.4995, -81.69541, 'America/New_York', 204], ['Dallas', 'US', 32.78306, -96.80667, 'America/Chicago', 139], ['Denver', 'US', 39.73915, -104.9847, 'America/Denver', 1636], ['Detroit', 'US', 42.33143, -83.04575, 'America/Detroit', 192], ['Eilat', 'IL', 29.55805, 34.94821, 'Asia/Jerusalem', 63], ['Gibraltar', 'GI', 36.14474, -5.35257, 'Europe/Gibraltar', 11], ['Haifa', 'IL', 32.81841, 34.9885, 'Asia/Jerusalem', 40], ['Hawaii', 'US', 21.30694, -157.85833, 'Pacific/Honolulu', 18], ['Helsinki', 'FI', 60.16952, 24.93545, 'Europe/Helsinki', 26], ['Houston', 'US', 29.76328, -95.36327, 'America/Chicago', 30], ['Jerusalem', 'IL', 31.76904, 35.21633, 'Asia/Jerusalem', 786], ['Johannesburg', 'ZA', -26.20227, 28.04363, 'Africa/Johannesburg', 1767], ['Kiev', 'UA', 50.45466, 30.5238, 'Europe/Kiev', 187], ['La Paz', 'BO', -16.5, -68.15, 'America/La_Paz', 3782], ['Livingston', 'US', 40.79593, -74.31487, 'America/New_York', 98], ['Las Vegas', 'US', 36.17497, -115.13722, 'America/Los_Angeles', 613], ['London', 'GB', 51.50853, -0.12574, 'Europe/London', 25], ['Los Angeles', 'US', 34.05223, -118.24368, 'America/Los_Angeles', 96], ['Marseilles', 'FR', 43.29695, 5.38107, 'Europe/Paris', 28], ['Miami', 'US', 25.77427, -80.19366, 'America/New_York', 25], ['Minneapolis', 'US', 44.97997, -93.26384, 'America/Chicago', 262], ['Melbourne', 'AU', -37.814, 144.96332, 'Australia/Melbourne', 25], ['Mexico City', 'MX', 19.42847, -99.12766, 'America/Mexico_City', 2240], ['Montreal', 'CA', 45.50884, -73.58781, 'America/Toronto', 216], ['Moscow', 'RU', 55.75222, 37.61556, 'Europe/Moscow', 144], ['New York', 'US', 40.71427, -74.00597, 'America/New_York', 57], ['Omaha', 'US', 41.25861, -95.93779, 'America/Chicago', 315], ['Ottawa', 'CA', 45.41117, -75.69812, 'America/Toronto', 71], ['Panama City', 'PA', 8.9936, -79.51973, 'America/Panama', 17], ['Paris', 'FR', 48.85341, 2.3488, 'Europe/Paris', 42], ['Pawtucket', 'US', 41.87871, -71.38256, 'America/New_York', 0],
// -11
['Petach Tikvah', 'IL', 32.08707, 34.88747, 'Asia/Jerusalem', 54], ['Philadelphia', 'US', 39.95233, -75.16379, 'America/New_York', 8], ['Phoenix', 'US', 33.44838, -112.07404, 'America/Phoenix', 366], ['Pittsburgh', 'US', 40.44062, -79.99589, 'America/New_York', 239], ['Providence', 'US', 41.82399, -71.41283, 'America/New_York', 0],
// -15
['Portland', 'US', 45.52345, -122.67621, 'America/Los_Angeles', 15], ['Saint Louis', 'US', 38.62727, -90.19789, 'America/Chicago', 149], ['Saint Petersburg', 'RU', 59.93863, 30.31413, 'Europe/Moscow', 11], ['San Diego', 'US', 32.71533, -117.15726, 'America/Los_Angeles', 20], ['San Francisco', 'US', 37.77493, -122.41942, 'America/Los_Angeles', 28], ['Sao Paulo', 'BR', -23.5475, -46.63611, 'America/Sao_Paulo', 769], ['Seattle', 'US', 47.60621, -122.33207, 'America/Los_Angeles', 56], ['Sydney', 'AU', -33.86785, 151.20732, 'Australia/Sydney', 58], ['Tel Aviv', 'IL', 32.08088, 34.78057, 'Asia/Jerusalem', 15], ['Tiberias', 'IL', 32.79221, 35.53124, 'Asia/Jerusalem', 0],
// -140
['Toronto', 'CA', 43.70011, -79.4163, 'America/Toronto', 175], ['Vancouver', 'CA', 49.24966, -123.11934, 'America/Vancouver', 70], ['White Plains', 'US', 41.03399, -73.76291, 'America/New_York', 82], ['Washington DC', 'US', 38.89511, -77.03637, 'America/New_York', 6], ['Worcester', 'US', 42.26259, -71.80229, 'America/New_York', 164]];
const classicCities = new Map();

// Zip-Codes.com TimeZone IDs
const ZIPCODES_TZ_MAP = {
  '0': 'UTC',
  '4': 'America/Puerto_Rico',
  // Atlantic (GMT -04:00)
  '5': 'America/New_York',
  //    Eastern  (GMT -05:00)
  '6': 'America/Chicago',
  //     Central  (GMT -06:00)
  '7': 'America/Denver',
  //      Mountain (GMT -07:00)
  '8': 'America/Los_Angeles',
  // Pacific  (GMT -08:00)
  '9': 'America/Anchorage',
  //   Alaska   (GMT -09:00)
  '10': 'Pacific/Honolulu',
  //   Hawaii-Aleutian Islands (GMT -10:00)
  '11': 'Pacific/Pago_Pago',
  //  American Samoa (GMT -11:00)
  '13': 'Pacific/Funafuti',
  //   Marshall Islands (GMT +12:00)
  '14': 'Pacific/Guam',
  //       Guam     (GMT +10:00)
  '15': 'Pacific/Palau',
  //      Palau    (GMT +9:00)
  '16': 'Pacific/Chuuk' //      Micronesia (GMT +11:00)
};

/** @private */
const timeFormatCache = new Map();

/**
 * Gets a 24-hour time formatter (e.g. 07:41 or 20:03) from cache
 * or makes a new one if needed
 * @private
 * @param {string} tzid
 * @return {Intl.DateTimeFormat}
 */
function getFormatter$1(tzid) {
  const fmt = timeFormatCache.get(tzid);
  if (fmt) return fmt;
  const f = new Intl.DateTimeFormat('en-US', {
    timeZone: tzid,
    hour: 'numeric',
    minute: 'numeric',
    hour12: false
  });
  timeFormatCache.set(tzid, f);
  return f;
}

/** Class representing Location */
class Location extends GeoLocation {
  /**
   * Initialize a Location instance
   * @param {number} latitude - Latitude as a decimal, valid range -90 thru +90 (e.g. 41.85003)
   * @param {number} longitude - Longitude as a decimal, valid range -180 thru +180 (e.g. -87.65005)
   * @param {boolean} il - in Israel (true) or Diaspora (false)
   * @param {string} tzid - Olson timezone ID, e.g. "America/Chicago"
   * @param {string} cityName - optional descriptive city name
   * @param {string} countryCode - ISO 3166 alpha-2 country code (e.g. "FR")
   * @param {string} [geoid] - optional string or numeric geographic ID
   * @param {number} [elevation] - in meters (default `0`)
   */
  constructor(latitude, longitude, il, tzid, cityName, countryCode, geoid, elevation) {
    const lat = typeof latitude === 'number' ? latitude : parseFloat(latitude);
    if (isNaN(lat) || lat < -90 || lat > 90) {
      throw new RangeError(`Latitude ${latitude} out of range [-90,90]`);
    }
    const long = typeof longitude === 'number' ? longitude : parseFloat(longitude);
    if (isNaN(long) || long < -180 || long > 180) {
      throw new RangeError(`Longitude ${longitude} out of range [-180,180]`);
    }
    const elev = typeof elevation === 'number' && elevation > 0 ? elevation : 0;
    super(cityName, lat, long, elev, tzid);
    this.il = Boolean(il);
    this.cc = countryCode;
    this.geoid = geoid;
  }

  /** @return {boolean} */
  getIsrael() {
    return this.il;
  }

  /** @return {string} */
  getName() {
    return this.getLocationName();
  }

  /**
   * Returns the location name, up to the first comma
   * @return {string}
   */
  getShortName() {
    const name = this.getLocationName();
    if (!name) return name;
    const comma = name.indexOf(', ');
    if (comma === -1) return name;
    if (this.cc === 'US' && name[comma + 2] === 'D') {
      if (name[comma + 3] === 'C') {
        return name.substring(0, comma + 4);
      } else if (name[comma + 3] === '.' && name[comma + 4] === 'C') {
        return name.substring(0, comma + 6);
      }
    }
    return name.substring(0, comma);
  }

  /** @return {string} */
  getCountryCode() {
    return this.cc;
  }

  /** @return {string} */
  getTzid() {
    return this.getTimeZone();
  }

  /**
   * Gets a 24-hour time formatter (e.g. 07:41 or 20:03) for this location
   * @return {Intl.DateTimeFormat}
   */
  getTimeFormatter() {
    return getFormatter$1(this.getTimeZone());
  }

  /** @return {string} */
  getGeoId() {
    return this.geoid;
  }

  /**
   * Creates a location object from one of 60 "classic" Hebcal city names.
   * The following city names are supported:
   * 'Ashdod', 'Atlanta', 'Austin', 'Baghdad', 'Beer Sheva',
   * 'Berlin', 'Baltimore', 'Bogota', 'Boston', 'Budapest',
   * 'Buenos Aires', 'Buffalo', 'Chicago', 'Cincinnati', 'Cleveland',
   * 'Dallas', 'Denver', 'Detroit', 'Eilat', 'Gibraltar', 'Haifa',
   * 'Hawaii', 'Helsinki', 'Houston', 'Jerusalem', 'Johannesburg',
   * 'Kiev', 'La Paz', 'Livingston', 'Las Vegas', 'London', 'Los Angeles',
   * 'Marseilles', 'Miami', 'Minneapolis', 'Melbourne', 'Mexico City',
   * 'Montreal', 'Moscow', 'New York', 'Omaha', 'Ottawa', 'Panama City',
   * 'Paris', 'Pawtucket', 'Petach Tikvah', 'Philadelphia', 'Phoenix',
   * 'Pittsburgh', 'Providence', 'Portland', 'Saint Louis', 'Saint Petersburg',
   * 'San Diego', 'San Francisco', 'Sao Paulo', 'Seattle', 'Sydney',
   * 'Tel Aviv', 'Tiberias', 'Toronto', 'Vancouver', 'White Plains',
   * 'Washington DC', 'Worcester'
   * @param {string} name
   * @return {Location}
   */
  static lookup(name) {
    return classicCities.get(name.toLowerCase());
  }

  /** @return {string} */
  toString() {
    return JSON.stringify(this);
  }

  /**
   * Converts legacy Hebcal timezone to a standard Olson tzid.
   * @param {number} tz integer, GMT offset in hours
   * @param {string} dst 'none', 'eu', 'usa', or 'israel'
   * @return {string}
   */
  static legacyTzToTzid(tz, dst) {
    tz = +tz;
    if (dst == 'none') {
      if (tz == 0) {
        return 'UTC';
      } else {
        const plus = tz > 0 ? '+' : '';
        return `Etc/GMT${plus}${tz}`;
      }
    } else if (tz == 2 && dst == 'israel') {
      return 'Asia/Jerusalem';
    } else if (dst == 'eu') {
      switch (tz) {
        case -2:
          return 'Atlantic/Cape_Verde';
        case -1:
          return 'Atlantic/Azores';
        case 0:
          return 'Europe/London';
        case 1:
          return 'Europe/Paris';
        case 2:
          return 'Europe/Athens';
      }
    } else if (dst == 'usa') {
      return ZIPCODES_TZ_MAP[String(tz * -1)];
    }
    return undefined;
  }

  /**
   * Converts timezone info from Zip-Codes.com to a standard Olson tzid.
   * @example
   * Location.getUsaTzid('AZ', 7, 'Y') // 'America/Denver'
   * @param {string} state two-letter all-caps US state abbreviation like 'CA'
   * @param {number} tz positive number, 5=America/New_York, 8=America/Los_Angeles
   * @param {string} dst single char 'Y' or 'N'
   * @return {string}
   */
  static getUsaTzid(state, tz, dst) {
    if (tz == 10 && state == 'AK') {
      return 'America/Adak';
    } else if (tz == 7 && state == 'AZ') {
      return dst == 'Y' ? 'America/Denver' : 'America/Phoenix';
    } else {
      return ZIPCODES_TZ_MAP[tz];
    }
  }

  /**
   * Adds a location name for `Location.lookup()` only if the name isn't
   * already being used. Returns `false` if the name is already taken
   * and `true` if successfully added.
   * @param {string} cityName
   * @param {Location} location
   * @return {boolean}
   */
  static addLocation(cityName, location) {
    const name = cityName.toLowerCase();
    if (classicCities.has(name)) {
      return false;
    }
    classicCities.set(name, location);
    return true;
  }
}
for (const city of classicCities0) {
  const location = new Location(city[2], city[3], city[1] == 'IL', city[4], city[0], city[1], undefined, city[5]);
  Location.addLocation(location.getName(), location);
}

const _formatters = new Map();

/**
 * @private
 * @param {string} tzid
 * @return {Intl.DateTimeFormat}
 */
function getFormatter(tzid) {
  const fmt = _formatters.get(tzid);
  if (fmt) return fmt;
  const f = new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false,
    timeZone: tzid
  });
  _formatters.set(tzid, f);
  return f;
}
const dateFormatRegex = /^(\d+).(\d+).(\d+),?\s+(\d+).(\d+).(\d+)/;

/**
 * @private
 * @param {string} tzid
 * @param {Date} date
 * @return {string}
 */
function getPseudoISO(tzid, date) {
  const str = getFormatter(tzid).format(date);
  const m = dateFormatRegex.exec(str);
  let hour = m[4];
  if (hour == '24') hour = '00';
  m[3] = pad4(m[3]);
  return `${m[3]}-${m[1]}-${m[2]}T${hour}:${m[5]}:${m[6]}Z`;
}

/**
 * @private
 * @param {string} tzid
 * @param {Date} date
 * @return {number}
 */
function getTimezoneOffset(tzid, date) {
  const utcStr = getPseudoISO('UTC', date);
  const localStr = getPseudoISO(tzid, date);
  const diffMs = new Date(utcStr).getTime() - new Date(localStr).getTime();
  return Math.ceil(diffMs / 1000 / 60);
}

/**
 * @private
 * @param {number} number
 * @return {string}
 */
function pad4(number) {
  if (number < 0) {
    return '-00' + pad4(-number);
  } else if (number < 10) {
    return '000' + number;
  } else if (number < 100) {
    return '00' + number;
  } else if (number < 1000) {
    return '0' + number;
  }
  return String(number);
}

function m(){zr().Temporal=Ar,Intl.DateTimeFormat=kr,Date.prototype.toTemporalInstant=Zr;}

m();

/**
 * @private
 * @param {number} number
 * @return {string}
 */
function pad2(number) {
  if (number < 10) {
    return '0' + number;
  }
  return String(number);
}

/**
 * @private
 * @param {Temporal.ZonedDateTime} zdt
 * @return {Date}
 */
function zdtToDate(zdt) {
  if (zdt === null) {
    return new Date(NaN);
  }
  const res = new Date(zdt.epochMilliseconds);
  res.setMilliseconds(0);
  return res;
}

/**
 * Calculate halachic times (zmanim / זְמַנִּים) for a given day and location.
 * Calculations are available for tzeit / tzais (nightfall),
 * shkiah (sunset) and more.
 *
 * Zmanim are estimated using an algorithm published by the US National Oceanic
 * and Atmospheric Administration. The NOAA solar calculator is based on equations
 * from _Astronomical Algorithms_ by Jean Meeus.
 *
 * The sunrise and sunset results are theoretically accurate to within a minute for
 * locations between +/- 72° latitude, and within 10 minutes outside of those latitudes.
 * However, due to variations in atmospheric composition, temperature, pressure and
 * conditions, observed values may vary from calculations.
 * https://gml.noaa.gov/grad/solcalc/calcdetails.html
 *
 * @example
 * const {GeoLocation, Zmanim} = require('@hebcal/core');
 * const latitude = 41.822232;
 * const longitude = -71.448292;
 * const tzid = 'America/New_York';
 * const friday = new Date(2023, 8, 8);
 * const gloc = new GeoLocation(null, latitude, longitude, 0, tzid);
 * const zmanim = new Zmanim(gloc, friday, false);
 * const candleLighting = zmanim.sunsetOffset(-18, true);
 * const timeStr = Zmanim.formatISOWithTimeZone(tzid, candleLighting);
 */
class Zmanim {
  /**
   * Initialize a Zmanim instance.
   * @param {GeoLocation} gloc GeoLocation including latitude, longitude, and timezone
   * @param {Date|HDate} date Regular or Hebrew Date. If `date` is a regular `Date`,
   *    hours, minutes, seconds and milliseconds are ignored.
   * @param {boolean} useElevation use elevation for calculations (default `false`).
   *    If `true`, use elevation to affect the calculation of all sunrise/sunset based
   *    zmanim. Note: there are some zmanim such as degree-based zmanim that are driven
   *    by the amount of light in the sky and are not impacted by elevation.
   *    These zmanim intentionally do not support elevation adjustment.
   */
  constructor(gloc, date, useElevation) {
    const dt = greg.isDate(date) ? date : HDate.isHDate(date) ? date.greg() : throwTypeError(`invalid date: ${date}`);
    this.date = dt;
    this.gloc = gloc;
    const plainDate = Temporal.PlainDate.from({
      year: dt.getFullYear(),
      month: dt.getMonth() + 1,
      day: dt.getDate()
    });
    this.noaa = new NOAACalculator(gloc, plainDate);
    this.useElevation = Boolean(useElevation);
  }
  /**
   * Convenience function to get the time when sun is above or below the horizon
   * for a certain angle (in degrees).
   * @param {number} angle
   * @param {boolean} rising
   * @return {Date}
   */
  timeAtAngle(angle, rising) {
    const offsetZenith = 90 + angle;
    const zdt = rising ? this.noaa.getSunriseOffsetByDegrees(offsetZenith) : this.noaa.getSunsetOffsetByDegrees(offsetZenith);
    return zdtToDate(zdt);
  }
  /**
   * Upper edge of the Sun appears over the eastern horizon in the morning (0.833° above horizon)
   * @return {Date}
   */
  sunrise() {
    const zdt = this.useElevation ? this.noaa.getSunrise() : this.noaa.getSeaLevelSunrise();
    return zdtToDate(zdt);
  }
  /**
   * Upper edge of the Sun appears over the eastern horizon in the morning (0.833° above horizon)
   * @return {Date}
   */
  seaLevelSunrise() {
    const zdt = this.noaa.getSeaLevelSunrise();
    return zdtToDate(zdt);
  }
  /**
   * When the upper edge of the Sun disappears below the horizon (0.833° below horizon)
   * @return {Date}
   */
  sunset() {
    const zdt = this.useElevation ? this.noaa.getSunset() : this.noaa.getSeaLevelSunset();
    return zdtToDate(zdt);
  }
  /**
   * When the upper edge of the Sun disappears below the horizon (0.833° below horizon)
   * @return {Date}
   */
  seaLevelSunset() {
    const zdt = this.noaa.getSeaLevelSunset();
    return zdtToDate(zdt);
  }
  /**
   * Civil dawn; Sun is 6° below the horizon in the morning
   * @return {Date}
   */
  dawn() {
    const zdt = this.noaa.getBeginCivilTwilight();
    return zdtToDate(zdt);
  }
  /**
   * Civil dusk; Sun is 6° below the horizon in the evening
   * @return {Date}
   */
  dusk() {
    const zdt = this.noaa.getEndCivilTwilight();
    return zdtToDate(zdt);
  }
  /** @return {Date} */
  gregEve() {
    const prev = new Date(this.date);
    prev.setDate(prev.getDate() - 1);
    const zman = new Zmanim(this.gloc, prev, this.useElevation);
    return zman.sunset();
  }
  /**
   * @private
   * @return {number}
   */
  nightHour() {
    return (this.sunrise() - this.gregEve()) / 12; // ms in hour
  }
  /**
   * Midday – Chatzot; Sunrise plus 6 halachic hours
   * @return {Date}
   */
  chatzot() {
    const zdt = this.noaa.getSunTransit();
    return zdtToDate(zdt);
  }
  /**
   * Midnight – Chatzot; Sunset plus 6 halachic hours
   * @return {Date}
   */
  chatzotNight() {
    return new Date(this.sunrise().getTime() - this.nightHour() * 6);
  }
  /**
   * Dawn – Alot haShachar; Sun is 16.1° below the horizon in the morning
   * @return {Date}
   */
  alotHaShachar() {
    return this.timeAtAngle(16.1, true);
  }
  /**
   * Earliest talis & tefillin – Misheyakir; Sun is 11.5° below the horizon in the morning
   * @return {Date}
   */
  misheyakir() {
    return this.timeAtAngle(11.5, true);
  }
  /**
   * Earliest talis & tefillin – Misheyakir Machmir; Sun is 10.2° below the horizon in the morning
   * @return {Date}
   */
  misheyakirMachmir() {
    return this.timeAtAngle(10.2, true);
  }
  /**
   * Utility method for using elevation-aware sunrise/sunset
   * @private
   * @param {number} hours
   * @return {Date}
   */
  getShaahZmanisBasedZman(hours) {
    const startOfDay = this.noaa.getSunrise();
    const endOfDay = this.noaa.getSunset();
    const temporalHour = this.noaa.getTemporalHour(startOfDay, endOfDay);
    const offset = Math.round(temporalHour * hours);
    const zdt = NOAACalculator.getTimeOffset(startOfDay, offset);
    return zdtToDate(zdt);
  }
  /**
   * Latest Shema (Gra); Sunrise plus 3 halachic hours, according to the Gra
   * @return {Date}
   */
  sofZmanShma() {
    // Gra
    return this.getShaahZmanisBasedZman(3);
  }
  /**
   * Latest Shacharit (Gra); Sunrise plus 4 halachic hours, according to the Gra
   * @return {Date}
   */
  sofZmanTfilla() {
    // Gra
    return this.getShaahZmanisBasedZman(4);
  }
  /**
   * Returns an array with alot (Date) and ms in hour (number)
   * @private
   * @return {any[]}
   */
  getTemporalHour72() {
    const alot72 = this.sunriseOffset(-72, false, true);
    const tzeit72 = this.sunsetOffset(72, false, true);
    const temporalHour = (tzeit72 - alot72) / 12;
    return [alot72, temporalHour];
  }
  /**
   * Returns an array with alot (Date) and ms in hour (number)
   * @private
   * @return {any[]}
   */
  getTemporalHour16Point1() {
    const alot16one = this.alotHaShachar();
    const tzeit16one = this.tzeit(16.1);
    const temporalHour = (tzeit16one - alot16one) / 12;
    return [alot16one, temporalHour];
  }
  /**
   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham.
   * Based on the opinion of the MGA that the day is calculated from
   * dawn being fixed 72 minutes before sea-level sunrise, and nightfall is fixed
   * 72 minutes after sea-level sunset.
   * @return {Date}
   */
  sofZmanShmaMGA() {
    // Magen Avraham
    const [alot72, temporalHour] = this.getTemporalHour72();
    return new Date(alot72.getTime() + 3 * temporalHour);
  }
  /**
   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham.
   * Based on the opinion of the MGA that the day is calculated from
   * dawn to nightfall with both being 16.1° below the horizon.
   * @return {Date}
   */
  sofZmanShmaMGA16Point1() {
    const [alot, temporalHour] = this.getTemporalHour16Point1();
    return new Date(alot.getTime() + 3 * temporalHour);
  }
  /**
   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham
   * @return {Date}
   */
  sofZmanTfillaMGA() {
    // Magen Avraham
    const [alot72, temporalHour] = this.getTemporalHour72();
    return new Date(alot72.getTime() + 4 * temporalHour);
  }
  /**
   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham.
   * Based on the opinion of the MGA that the day is calculated from
   * dawn to nightfall with both being 16.1° below the horizon.
   * @return {Date}
   */
  sofZmanTfillaMGA16Point1() {
    const [alot, temporalHour] = this.getTemporalHour16Point1();
    return new Date(alot.getTime() + 4 * temporalHour);
  }
  /**
   * Earliest Mincha – Mincha Gedola; Sunrise plus 6.5 halachic hours
   * @return {Date}
   */
  minchaGedola() {
    return this.getShaahZmanisBasedZman(6.5);
  }
  /**
   * Preferable earliest time to recite Minchah – Mincha Ketana; Sunrise plus 9.5 halachic hours
   * @return {Date}
   */
  minchaKetana() {
    return this.getShaahZmanisBasedZman(9.5);
  }
  /**
   * Plag haMincha; Sunrise plus 10.75 halachic hours
   * @return {Date}
   */
  plagHaMincha() {
    return this.getShaahZmanisBasedZman(10.75);
  }
  /**
   * @param {number} [angle=8.5] optional time for solar depression.
   *   Default is 8.5 degrees for 3 small stars, use 7.083 degrees for 3 medium-sized stars.
   * @return {Date}
   */
  tzeit(angle = 8.5) {
    return this.timeAtAngle(angle, false);
  }
  /**
   * Alias for sunrise
   * @return {Date}
   */
  neitzHaChama() {
    return this.sunrise();
  }
  /**
   * Alias for sunset
   * @return {Date}
   */
  shkiah() {
    return this.sunset();
  }

  /**
   * Uses timeFormat to return a date like '20:34'
   * @param {Date} dt
   * @param {Intl.DateTimeFormat} timeFormat
   * @return {string}
   */
  static formatTime(dt, timeFormat) {
    const time = timeFormat.format(dt);
    const hm = time.split(':');
    if (hm[0] === '24') {
      return '00:' + hm[1];
    }
    return time;
  }

  /**
   * Discards seconds, rounding to nearest minute.
   * @param {Date} dt
   * @return {Date}
   */
  static roundTime(dt) {
    const millis = dt.getTime();
    if (isNaN(millis)) {
      return dt;
    }
    // Round up to next minute if needed
    const millisOnly = dt.getMilliseconds();
    const seconds = dt.getSeconds();
    if (seconds === 0 && millisOnly === 0) {
      return dt;
    }
    const secAndMillis = seconds * 1000 + millisOnly;
    const delta = secAndMillis >= 30000 ? 60000 - secAndMillis : -1 * secAndMillis;
    return new Date(millis + delta);
  }

  /**
   * Get offset string (like "+05:00" or "-08:00") from tzid (like "Europe/Moscow")
   * @param {string} tzid
   * @param {Date} date
   * @return {string}
   */
  static timeZoneOffset(tzid, date) {
    const offset = getTimezoneOffset(tzid, date);
    const offsetAbs = Math.abs(offset);
    const hours = Math.floor(offsetAbs / 60);
    const minutes = offsetAbs % 60;
    return (offset < 0 ? '+' : '-') + pad2(hours) + ':' + pad2(minutes);
  }

  /**
   * Returns a string like "2022-04-01T13:06:00-11:00"
   * @param {string} tzid
   * @param {Date} date
   * @return {string}
   */
  static formatISOWithTimeZone(tzid, date) {
    if (isNaN(date.getTime())) {
      return null;
    }
    return getPseudoISO(tzid, date).substring(0, 19) + Zmanim.timeZoneOffset(tzid, date);
  }

  /**
   * Returns sunrise + `offset` minutes (either positive or negative).
   * @param {number} offset minutes
   * @param {boolean} roundMinute round time to nearest minute (default true)
   * @param {boolean} forceSeaLevel use sea-level sunrise (default false)
   * @return {Date}
   */
  sunriseOffset(offset, roundMinute = true, forceSeaLevel = false) {
    const sunrise = forceSeaLevel ? this.seaLevelSunrise() : this.sunrise();
    if (isNaN(sunrise.getTime())) {
      return sunrise;
    }
    if (roundMinute) {
      // For positive offsets only, round up to next minute if needed
      if (offset > 0 && sunrise.getSeconds() >= 30) {
        offset++;
      }
      sunrise.setSeconds(0, 0);
    }
    return new Date(sunrise.getTime() + offset * 60 * 1000);
  }

  /**
   * Returns sunset + `offset` minutes (either positive or negative).
   * @param {number} offset minutes
   * @param {boolean} roundMinute round time to nearest minute (default true)
   * @param {boolean} forceSeaLevel use sea-level sunset (default false)
   * @return {Date}
   */
  sunsetOffset(offset, roundMinute = true, forceSeaLevel = false) {
    const sunset = forceSeaLevel ? this.seaLevelSunset() : this.sunset();
    if (isNaN(sunset.getTime())) {
      return sunset;
    }
    if (roundMinute) {
      // For Havdalah only, round up to next minute if needed
      if (offset > 0 && sunset.getSeconds() >= 30) {
        offset++;
      }
      sunset.setSeconds(0, 0);
    }
    return new Date(sunset.getTime() + offset * 60 * 1000);
  }
}

const hour12cc = {
  US: 1,
  CA: 1,
  BR: 1,
  AU: 1,
  NZ: 1,
  DO: 1,
  PR: 1,
  GR: 1,
  IN: 1,
  KR: 1,
  NP: 1,
  ZA: 1
};

/**
 * @private
 * @param {string} timeStr - original time like "20:30"
 * @param {string} suffix - "p" or "pm" or " P.M.". Add leading space if you want it
 * @param {CalOptions} options
 * @return {string}
 */
function reformatTimeStr(timeStr, suffix, options) {
  var _options$location;
  if (typeof timeStr !== 'string') throw new TypeError(`Bad timeStr: ${timeStr}`);
  const cc = (options === null || options === void 0 || (_options$location = options.location) === null || _options$location === void 0 ? void 0 : _options$location.cc) || (options !== null && options !== void 0 && options.il ? 'IL' : 'US');
  const hour12 = options === null || options === void 0 ? void 0 : options.hour12;
  if (typeof hour12 !== 'undefined' && !hour12) {
    return timeStr;
  }
  if (!hour12 && typeof hour12cc[cc] === 'undefined') {
    return timeStr;
  }
  const hm = timeStr.split(':');
  let hour = parseInt(hm[0], 10);
  if (hour < 12 && suffix) {
    suffix = suffix.replace('p', 'a').replace('P', 'A');
    if (hour === 0) {
      hour = 12;
    }
  } else if (hour > 12) {
    hour = hour % 12;
  } else if (hour === 0) {
    hour = '00';
  }
  return `${hour}:${hm[1]}${suffix}`;
}

/* eslint-disable max-len */

/**
 * @private
 * @param {Event} e
 * @param {HDate} hd
 * @param {CalOptions} options
 * @param {boolean} isFriday
 * @param {boolean} isSaturday
 * @return {Event}
 */
function makeCandleEvent(e, hd, options, isFriday, isSaturday) {
  let havdalahTitle = false;
  let useHavdalahOffset = isSaturday;
  let mask = e ? e.getFlags() : flags.LIGHT_CANDLES;
  if (typeof e !== 'undefined') {
    // if linked event && dow == FRI, use Candle lighting time & title
    if (!isFriday) {
      if (mask & (flags.LIGHT_CANDLES_TZEIS | flags.CHANUKAH_CANDLES)) {
        useHavdalahOffset = true;
      } else if (mask & flags.YOM_TOV_ENDS) {
        havdalahTitle = true;
        useHavdalahOffset = true;
      }
    }
  } else if (isSaturday) {
    havdalahTitle = true;
    mask = flags.LIGHT_CANDLES_TZEIS;
  }
  // if offset is 0 or undefined, we'll use tzeit time
  const offset = useHavdalahOffset ? options.havdalahMins : options.candleLightingMins;
  const location = options.location;
  const zmanim = new Zmanim(location, hd, options.useElevation);
  const time = offset ? zmanim.sunsetOffset(offset, true) : zmanim.tzeit(options.havdalahDeg);
  if (isNaN(time.getTime())) {
    return null; // no sunset
  }
  if (havdalahTitle) {
    return new HavdalahEvent(hd, mask, time, location, options.havdalahMins, e, options);
  } else {
    return new CandleLightingEvent(hd, mask, time, location, e, options);
  }
}

/** An event that has an `eventTime` and `eventTimeStr` */
class TimedEvent extends Event {
  /**
   * @param {HDate} date
   * @param {string} desc Description (not translated)
   * @param {number} mask
   * @param {Date} eventTime
   * @param {Location} location
   * @param {Event} linkedEvent
   * @param {CalOptions} options
   */
  constructor(date, desc, mask, eventTime, location, linkedEvent, options) {
    super(date, desc, mask);
    this.eventTime = Zmanim.roundTime(eventTime);
    this.location = location;
    const timeFormat = location.getTimeFormatter();
    this.eventTimeStr = Zmanim.formatTime(this.eventTime, timeFormat);
    const opts = Object.assign({
      location
    }, options);
    this.fmtTime = reformatTimeStr(this.eventTimeStr, 'pm', opts);
    if (typeof linkedEvent !== 'undefined') {
      this.linkedEvent = linkedEvent;
    }
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    return Locale.gettext(this.getDesc(), locale) + ': ' + this.fmtTime;
  }
  /**
   * Returns translation of "Candle lighting" without the time.
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    return Locale.gettext(this.getDesc(), locale);
  }
  /** @return {string[]} */
  getCategories() {
    const desc = this.getDesc();
    switch (desc) {
      // LIGHT_CANDLES or LIGHT_CANDLES_TZEIS
      case 'Candle lighting':
        return ['candles'];
      // YOM_TOV_ENDS
      case 'Havdalah':
        return ['havdalah'];
      // flags.MINOR_FAST or flags.MAJOR_FAST
      case 'Fast begins':
      case 'Fast ends':
        return ['zmanim', 'fast'];
    }
  }
}

/** Havdalah after Shabbat or holiday */
class HavdalahEvent extends TimedEvent {
  /**
   * @param {HDate} date
   * @param {number} mask
   * @param {Date} eventTime
   * @param {Location} location
   * @param {number} havdalahMins
   * @param {Event} linkedEvent
   * @param {CalOptions} options
   */
  constructor(date, mask, eventTime, location, havdalahMins, linkedEvent, options) {
    super(date, 'Havdalah', mask, eventTime, location, linkedEvent, options);
    if (havdalahMins) {
      this.havdalahMins = havdalahMins;
    }
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    return this.renderBrief(locale) + ': ' + this.fmtTime;
  }
  /**
   * Returns translation of "Havdalah" without the time.
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    let str = Locale.gettext(this.getDesc(), locale);
    if (this.havdalahMins) {
      const min = Locale.gettext('min', locale);
      str += ` (${this.havdalahMins} ${min})`;
    }
    return str;
  }
  /** @return {string} */
  getEmoji() {
    return '✨';
  }
}

/** Candle lighting before Shabbat or holiday */
class CandleLightingEvent extends TimedEvent {
  /**
   * @param {HDate} date
   * @param {number} mask
   * @param {Date} eventTime
   * @param {Location} location
   * @param {Event} linkedEvent
   * @param {CalOptions} options
   */
  constructor(date, mask, eventTime, location, linkedEvent, options) {
    super(date, 'Candle lighting', mask, eventTime, location, linkedEvent, options);
  }
  /** @return {string} */
  getEmoji() {
    return '🕯️';
  }
}

/**
 * Makes a pair of events representing fast start and end times
 * @private
 * @param {Event} ev
 * @param {CalOptions} options
 * @return {Event}
 */
function makeFastStartEnd(ev, options) {
  const desc = ev.getDesc();
  if (desc === 'Yom Kippur') {
    return ev;
  }
  ev = ev.clone();
  const hd = ev.getDate();
  const dt = hd.greg();
  const location = options.location;
  const fastEndDeg = options.fastEndDeg;
  const zmanim = new Zmanim(location, dt, options.useElevation);
  if (desc === 'Erev Tish\'a B\'Av') {
    const sunset = zmanim.sunset();
    ev.startEvent = makeTimedEvent(hd, sunset, 'Fast begins', ev, options);
  } else if (desc.startsWith('Tish\'a B\'Av')) {
    ev.endEvent = makeTimedEvent(hd, zmanim.tzeit(fastEndDeg), 'Fast ends', ev, options);
  } else {
    const dawn = zmanim.alotHaShachar();
    ev.startEvent = makeTimedEvent(hd, dawn, 'Fast begins', ev, options);
    if (dt.getDay() !== 5 && !(hd.getDate() === 14 && hd.getMonth() === months.NISAN)) {
      ev.endEvent = makeTimedEvent(hd, zmanim.tzeit(fastEndDeg), 'Fast ends', ev, options);
    }
  }
  return ev;
}

/**
 * @private
 * @param {HDate} hd
 * @param {Date} time
 * @param {string} desc
 * @param {Event} ev
 * @param {CalOptions} options
 * @return {TimedEvent}
 */
function makeTimedEvent(hd, time, desc, ev, options) {
  if (isNaN(time.getTime())) {
    return null;
  }
  const location = options.location;
  return new TimedEvent(hd, desc, ev.getFlags(), time, location, ev, options);
}

/**
 * Makes a candle-lighting event for Chankah (not on Friday/Saturday)
 * @private
 * @param {Event} ev
 * @param {HDate} hd
 * @param {CalOptions} options
 * @return {TimedEvent}
 */
function makeWeekdayChanukahCandleLighting(ev, hd, options) {
  const location = options.location;
  const zmanim = new Zmanim(location, hd.greg(), options.useElevation);
  const candleLightingTime = zmanim.dusk();
  // const candleLightingTime = zmanim.tzeit(4.6667);
  return makeTimedEvent(hd, candleLightingTime, ev.getDesc(), ev, options);
}

/* eslint-disable camelcase */
const shortDayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
const heDayNames = ['רִאשׁוֹן', 'שֵׁנִי', 'שְׁלִישִׁי', 'רְבִיעִי', 'חֲמִישִׁי', 'שִׁישִּׁי', 'שַׁבָּת'];
const night = 'בַּלַּ֥יְלָה';
const morning = 'בַּבֹּקֶר';
const afternoon = 'בַּצׇּהֳרַיִים';
const evening = 'בָּעֶרֶב';

/**
 * Represents a molad, the moment when the new moon is "born"
 */
class Molad {
  /**
   * Calculates the molad for a Hebrew month
   * @param {number} year
   * @param {number} month
   */
  constructor(year, month) {
    let m_adj = month - 7;
    if (m_adj < 0) {
      m_adj += HDate.monthsInYear(year);
    }
    const m_elapsed = 235 * Math.floor((year - 1) / 19) +
    // Months in complete 19 year lunar (Metonic) cycles so far
    12 * ((year - 1) % 19) +
    // Regular months in this cycle
    Math.floor((7 * ((year - 1) % 19) + 1) / 19) +
    // Leap months this cycle
    m_adj; // add elapsed months till the start of the molad of the month

    const p_elapsed = 204 + Math.floor(793 * (m_elapsed % 1080));
    const h_elapsed = 5 + 12 * m_elapsed + 793 * Math.floor(m_elapsed / 1080) + Math.floor(p_elapsed / 1080) - 6;
    const parts = p_elapsed % 1080 + 1080 * (h_elapsed % 24);
    const chalakim = parts % 1080;
    const day = 1 + 29 * m_elapsed + Math.floor(h_elapsed / 24);
    const dow = day % 7;
    this.year = year;
    this.month = month;
    this.dow = dow;
    this.hour = h_elapsed % 24;
    this.minutes = Math.floor(chalakim / 18);
    this.chalakim = chalakim % 18;
  }
  /**
   * @return {number}
   */
  getYear() {
    return this.year;
  }
  /**
   * @return {number}
   */
  getMonth() {
    return this.month;
  }
  /**
   * @return {string}
   */
  getMonthName() {
    return HDate.getMonthName(this.month, this.year);
  }
  /**
   * @return {number} Day of Week (0=Sunday, 6=Saturday)
   */
  getDow() {
    return this.dow;
  }
  /**
   * @return {number} hour of day (0-23)
   */
  getHour() {
    return this.hour;
  }
  /**
   * @return {number} minutes past hour (0-59)
   */
  getMinutes() {
    return this.minutes;
  }
  /**
   * @return {number} parts of a minute (0-17)
   */
  getChalakim() {
    return this.chalakim;
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale)
   * @param {CalOptions} options
   * @return {string}
   */
  render(locale, options) {
    locale = locale || Locale.getLocaleName();
    if (typeof locale === 'string') {
      locale = locale.toLowerCase();
    }
    const isHebrewLocale = locale === 'he' || locale === 'he-x-nonikud' || locale === 'h';
    const monthName = Locale.gettext(this.getMonthName(), locale);
    const dayNames = isHebrewLocale ? heDayNames : shortDayNames;
    const dow = dayNames[this.getDow()];
    const minutes = this.getMinutes();
    const hour = this.getHour();
    const chalakim = this.getChalakim();
    const moladStr = Locale.gettext('Molad', locale);
    const minutesStr = Locale.lookupTranslation('min', locale) || 'minutes';
    const chalakimStr = Locale.gettext('chalakim', locale);
    if (isHebrewLocale) {
      const ampm = hour < 5 ? night : hour < 12 ? morning : hour < 17 ? afternoon : hour < 21 ? evening : night;
      const result = `${moladStr} ${monthName} יִהְיֶה בַּיּוֹם ${dow} בשָׁבוּעַ, ` + `בְּשָׁעָה ${hour} ${ampm}, ` + `ו-${minutes} ${minutesStr} ` + `ו-${chalakim} ${chalakimStr}`;
      if (locale === 'he-x-nonikud') {
        return Locale.hebrewStripNikkud(result);
      }
      return result;
    }
    const fmtTime = reformatTimeStr(`${hour}:00`, 'pm', options);
    const month = monthName.replace(/'/g, '’');
    return `${moladStr} ${month}: ${dow}, ${minutes} ${minutesStr} and ${chalakim} ${chalakimStr} after ${fmtTime}`;
  }
}

/** Represents a Molad announcement on Shabbat Mevarchim */
class MoladEvent extends Event {
  /**
   * @param {HDate} date Hebrew date event occurs
   * @param {number} hyear molad year
   * @param {number} hmonth molad month
   * @param {CalOptions} options
   */
  constructor(date, hyear, hmonth, options) {
    const m = new Molad(hyear, hmonth);
    const monthName = m.getMonthName();
    super(date, `Molad ${monthName} ${hyear}`, flags.MOLAD);
    this.molad = m;
    this.options = options;
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    return this.molad.render(locale, this.options);
  }
}

const sefirot = [null, 'Lovingkindness', 'Might', 'Beauty', 'Eternity', 'Splendor', 'Foundation', 'Majesty'];
const sefirotTranslit = [null, 'Chesed', 'Gevurah', 'Tiferet', 'Netzach', 'Hod', 'Yesod', 'Malkhut'];

/** Represents a day 1-49 of counting the Omer from Pesach to Shavuot */
class OmerEvent extends Event {
  /**
   * @param {HDate} date
   * @param {number} omerDay
   */
  constructor(date, omerDay) {
    super(date, `Omer ${omerDay}`, flags.OMER_COUNT);
    if (omerDay < 1 || omerDay > 49) {
      throw new RangeError(`Invalid Omer day ${omerDay}`);
    }
    this.weekNumber = Math.floor((omerDay - 1) / 7) + 1;
    this.daysWithinWeeks = omerDay % 7 || 7;
    this.omer = omerDay;
  }
  /**
   * @param {string} lang
   * @return {string}
   */
  sefira(lang = 'en') {
    if (lang === 'he') {
      return this.sefiraHe();
    } else if (lang === 'translit') {
      return this.sefiraTranslit();
    } else {
      const week = sefirot[this.weekNumber];
      const dayWithinWeek = sefirot[this.daysWithinWeeks];
      return `${dayWithinWeek} within ${week}`;
    }
  }
  /**
   * @private
   * @return {string}
   */
  sefiraTranslit() {
    const weekNum = this.weekNumber;
    const translitWeek = sefirotTranslit[weekNum];
    const translitDayWithinWeek = sefirotTranslit[this.daysWithinWeeks];
    const translitPrefix = weekNum === 2 || weekNum === 6 ? 'shebi' : `sheb'`;
    return `${translitDayWithinWeek} ${translitPrefix}${translitWeek}`;
  }
  /**
   * @private
   * @return {string}
   */
  sefiraHe() {
    const weekNum = this.weekNumber;
    const week = sefirot[weekNum];
    const dayWithinWeek = sefirot[this.daysWithinWeeks];
    const heWeek = Locale.gettext(week, 'he');
    const heDayWithinWeek = Locale.gettext(dayWithinWeek, 'he');
    const hePrefix = weekNum === 2 || weekNum === 6 ? 'שֶׁבִּ' : 'שֶׁבְּ';
    return `${heDayWithinWeek} ${hePrefix}${heWeek}`.normalize();
  }
  /**
   * @todo use gettext()
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    locale = locale || Locale.getLocaleName();
    const omer = this.omer;
    const nth = locale == 'he' ? gematriya(omer) : Locale.ordinal(omer, locale);
    return nth + ' ' + Locale.gettext('day of the Omer', locale);
  }
  /**
   * Returns translation of "Omer day 22" without ordinal numbers.
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    return Locale.gettext('Omer', locale) + ' ' + Locale.gettext('day', locale) + ' ' + this.omer;
  }
  /** @return {string} */
  getEmoji() {
    if (typeof this.emoji === 'string') return this.emoji;
    const number = this.omer;
    if (number <= 20) {
      return String.fromCodePoint(9312 + number - 1);
    } else if (number <= 35) {
      // between 21 and 35 inclusive
      return String.fromCodePoint(12881 + number - 21);
    } else {
      // between 36 and 49 inclusive
      return String.fromCodePoint(12977 + number - 36);
    }
  }
  /** @return {number} */
  getWeeks() {
    const day7 = this.daysWithinWeeks === 7;
    return day7 ? this.weekNumber : this.weekNumber - 1;
  }
  /** @return {number} */
  getDaysWithinWeeks() {
    return this.daysWithinWeeks;
  }
  /**
   * @param {string} locale
   * @return {string}
   */
  getTodayIs(locale) {
    locale = locale || Locale.getLocaleName();
    if (typeof locale === 'string') {
      locale = locale.toLowerCase();
    }
    if (locale === 'he') {
      return getTodayIsHe(this.omer);
    } else if (locale === 'he-x-nonikud') {
      return Locale.hebrewStripNikkud(getTodayIsHe(this.omer));
    }
    const totalDaysStr = this.omer === 1 ? 'day' : 'days';
    let str = `Today is ${this.omer} ${totalDaysStr}`;
    if (this.weekNumber > 1 || this.omer === 7) {
      const day7 = this.daysWithinWeeks === 7;
      const numWeeks = day7 ? this.weekNumber : this.weekNumber - 1;
      const weeksStr = numWeeks === 1 ? 'week' : 'weeks';
      str += `, which is ${numWeeks} ${weeksStr}`;
      if (!day7) {
        const daysStr = this.daysWithinWeeks === 1 ? 'day' : 'days';
        str += ` and ${this.daysWithinWeeks} ${daysStr}`;
      }
    }
    return str + ' of the Omer';
  }
  /** @return {string} */
  url() {
    return `https://www.hebcal.com/omer/${this.getDate().getFullYear()}/${this.omer}`;
  }
}

// adapted from pip hdate package (GPL)
// https://github.com/py-libhdate/py-libhdate/blob/master/hdate/date.py

const tens = ['', 'עֲשָׂרָה', 'עֶשְׂרִים', 'שְׁלוֹשִׁים', 'אַרְבָּעִים'];
const ones = ['', 'אֶחָד', 'שְׁנַיִם', 'שְׁלוֹשָׁה', 'אַרְבָּעָה', 'חֲמִשָׁה', 'שִׁשָׁה', 'שִׁבְעָה', 'שְׁמוֹנָה', 'תִּשְׁעָה'];
const shnei = 'שְׁנֵי';
const yamim = 'יָמִים';
const shneiYamim = shnei + ' ' + yamim;
const shavuot = 'שָׁבוּעוֹת';
const yom = 'יוֹם';
const yomEchad = yom + ' ' + ones[1];

/**
 * @private
 * @param {number} omer
 * @return {string}
 */
function getTodayIsHe(omer) {
  const ten = Math.floor(omer / 10);
  const one = omer % 10;
  let str = 'הַיוֹם ';
  if (10 < omer && omer < 20) {
    str += ones[one] + ' עָשָׂר';
  } else if (omer > 9) {
    str += ones[one];
    if (one) {
      str += ' וְ';
    }
  }
  if (omer > 2) {
    if (omer > 20 || omer === 10 || omer === 20) {
      str += tens[ten];
    }
    if (omer < 11) {
      str += ones[one] + ' ' + yamim + ' ';
    } else {
      str += ' ' + yom + ' ';
    }
  } else if (omer === 1) {
    str += yomEchad + ' ';
  } else {
    // omer == 2
    str += shneiYamim + ' ';
  }
  if (omer > 6) {
    str = str.trim(); // remove trailing space before comma
    str += ', שְׁהֵם ';
    const weeks = Math.floor(omer / 7);
    const days = omer % 7;
    if (weeks > 2) {
      str += ones[weeks] + ' ' + shavuot + ' ';
    } else if (weeks == 1) {
      str += 'שָׁבוּעַ' + ' ' + ones[1] + ' ';
    } else {
      // weeks == 2
      str += shnei + ' ' + shavuot + ' ';
    }
    if (days) {
      str += 'וְ';
      if (days > 2) {
        str += ones[days] + ' ' + yamim + ' ';
      } else if (days == 1) {
        str += yomEchad + ' ';
      } else {
        // days == 2
        str += shneiYamim + ' ';
      }
    }
  }
  str += 'לָעוֹמֶר';
  return str.normalize();
}

class QuickLRU extends Map {
	#size = 0;
	#cache = new Map();
	#oldCache = new Map();
	#maxSize;
	#maxAge;
	#onEviction;

	constructor(options = {}) {
		super();

		if (!(options.maxSize && options.maxSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		if (typeof options.maxAge === 'number' && options.maxAge === 0) {
			throw new TypeError('`maxAge` must be a number greater than 0');
		}

		this.#maxSize = options.maxSize;
		this.#maxAge = options.maxAge || Number.POSITIVE_INFINITY;
		this.#onEviction = options.onEviction;
	}

	// For tests.
	get __oldCache() {
		return this.#oldCache;
	}

	#emitEvictions(cache) {
		if (typeof this.#onEviction !== 'function') {
			return;
		}

		for (const [key, item] of cache) {
			this.#onEviction(key, item.value);
		}
	}

	#deleteIfExpired(key, item) {
		if (typeof item.expiry === 'number' && item.expiry <= Date.now()) {
			if (typeof this.#onEviction === 'function') {
				this.#onEviction(key, item.value);
			}

			return this.delete(key);
		}

		return false;
	}

	#getOrDeleteIfExpired(key, item) {
		const deleted = this.#deleteIfExpired(key, item);
		if (deleted === false) {
			return item.value;
		}
	}

	#getItemValue(key, item) {
		return item.expiry ? this.#getOrDeleteIfExpired(key, item) : item.value;
	}

	#peek(key, cache) {
		const item = cache.get(key);

		return this.#getItemValue(key, item);
	}

	#set(key, value) {
		this.#cache.set(key, value);
		this.#size++;

		if (this.#size >= this.#maxSize) {
			this.#size = 0;
			this.#emitEvictions(this.#oldCache);
			this.#oldCache = this.#cache;
			this.#cache = new Map();
		}
	}

	#moveToRecent(key, item) {
		this.#oldCache.delete(key);
		this.#set(key, item);
	}

	* #entriesAscending() {
		for (const item of this.#oldCache) {
			const [key, value] = item;
			if (!this.#cache.has(key)) {
				const deleted = this.#deleteIfExpired(key, value);
				if (deleted === false) {
					yield item;
				}
			}
		}

		for (const item of this.#cache) {
			const [key, value] = item;
			const deleted = this.#deleteIfExpired(key, value);
			if (deleted === false) {
				yield item;
			}
		}
	}

	get(key) {
		if (this.#cache.has(key)) {
			const item = this.#cache.get(key);
			return this.#getItemValue(key, item);
		}

		if (this.#oldCache.has(key)) {
			const item = this.#oldCache.get(key);
			if (this.#deleteIfExpired(key, item) === false) {
				this.#moveToRecent(key, item);
				return item.value;
			}
		}
	}

	set(key, value, {maxAge = this.#maxAge} = {}) {
		const expiry = typeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY
			? (Date.now() + maxAge)
			: undefined;

		if (this.#cache.has(key)) {
			this.#cache.set(key, {
				value,
				expiry,
			});
		} else {
			this.#set(key, {value, expiry});
		}

		return this;
	}

	has(key) {
		if (this.#cache.has(key)) {
			return !this.#deleteIfExpired(key, this.#cache.get(key));
		}

		if (this.#oldCache.has(key)) {
			return !this.#deleteIfExpired(key, this.#oldCache.get(key));
		}

		return false;
	}

	peek(key) {
		if (this.#cache.has(key)) {
			return this.#peek(key, this.#cache);
		}

		if (this.#oldCache.has(key)) {
			return this.#peek(key, this.#oldCache);
		}
	}

	delete(key) {
		const deleted = this.#cache.delete(key);
		if (deleted) {
			this.#size--;
		}

		return this.#oldCache.delete(key) || deleted;
	}

	clear() {
		this.#cache.clear();
		this.#oldCache.clear();
		this.#size = 0;
	}

	resize(newSize) {
		if (!(newSize && newSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		const items = [...this.#entriesAscending()];
		const removeCount = items.length - newSize;
		if (removeCount < 0) {
			this.#cache = new Map(items);
			this.#oldCache = new Map();
			this.#size = items.length;
		} else {
			if (removeCount > 0) {
				this.#emitEvictions(items.slice(0, removeCount));
			}

			this.#oldCache = new Map(items.slice(removeCount));
			this.#cache = new Map();
			this.#size = 0;
		}

		this.#maxSize = newSize;
	}

	* keys() {
		for (const [key] of this) {
			yield key;
		}
	}

	* values() {
		for (const [, value] of this) {
			yield value;
		}
	}

	* [Symbol.iterator]() {
		for (const item of this.#cache) {
			const [key, value] = item;
			const deleted = this.#deleteIfExpired(key, value);
			if (deleted === false) {
				yield [key, value.value];
			}
		}

		for (const item of this.#oldCache) {
			const [key, value] = item;
			if (!this.#cache.has(key)) {
				const deleted = this.#deleteIfExpired(key, value);
				if (deleted === false) {
					yield [key, value.value];
				}
			}
		}
	}

	* entriesDescending() {
		let items = [...this.#cache];
		for (let i = items.length - 1; i >= 0; --i) {
			const item = items[i];
			const [key, value] = item;
			const deleted = this.#deleteIfExpired(key, value);
			if (deleted === false) {
				yield [key, value.value];
			}
		}

		items = [...this.#oldCache];
		for (let i = items.length - 1; i >= 0; --i) {
			const item = items[i];
			const [key, value] = item;
			if (!this.#cache.has(key)) {
				const deleted = this.#deleteIfExpired(key, value);
				if (deleted === false) {
					yield [key, value.value];
				}
			}
		}
	}

	* entriesAscending() {
		for (const [key, value] of this.#entriesAscending()) {
			yield [key, value.value];
		}
	}

	get size() {
		if (!this.#size) {
			return this.#oldCache.size;
		}

		let oldCacheSize = 0;
		for (const key of this.#oldCache.keys()) {
			if (!this.#cache.has(key)) {
				oldCacheSize++;
			}
		}

		return Math.min(this.#size + oldCacheSize, this.#maxSize);
	}

	get maxSize() {
		return this.#maxSize;
	}

	entries() {
		return this.entriesAscending();
	}

	forEach(callbackFunction, thisArgument = this) {
		for (const [key, value] of this.entriesAscending()) {
			callbackFunction.call(thisArgument, value, key, this);
		}
	}

	get [Symbol.toStringTag]() {
		return JSON.stringify([...this.entriesAscending()]);
	}
}

/* eslint-disable new-cap */
/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

const INCOMPLETE = 0;
const REGULAR = 1;
const COMPLETE = 2;

// eslint-disable-next-line require-jsdoc
function throwError(errorMessage) {
  throw new TypeError(errorMessage);
}

/**
 * Result of Sedra.lookup
 * @typedef {Object} SedraResult
 * @property {string[]} parsha Name of the parsha (or parshiyot) read on
 *     Hebrew date, e.g. `['Noach']` or `['Matot', 'Masei']`
 * @property {boolean} chag True if this is a regular parasha HaShavua
 *     Torah reading, false if it's a special holiday reading
 * @property {number|number[]} num the parsha number (or numbers) using 1-indexing.
 *     A `number` for a regular (single) parsha, and a `number[]` for a doubled parsha.
 *     For Parashat *Bereshit*, `num` would be equal to `1`, and for
 *     *Matot-Masei* it would be `[42, 43]`
 */

/**
 * Represents Parashah HaShavua for an entire Hebrew year
 */
class Sedra {
  /**
   * Caculates the Parashah HaShavua for an entire Hebrew year
   * @param {number} hebYr - Hebrew year (e.g. 5749)
   * @param {boolean} il - Use Israel sedra schedule (false for Diaspora)
   */
  constructor(hebYr, il) {
    // the Hebrew year
    hebYr = +hebYr;
    const longC = HDate.longCheshvan(hebYr);
    const shortK = HDate.shortKislev(hebYr);
    const type = this.type = longC && !shortK ? COMPLETE : !longC && shortK ? INCOMPLETE : REGULAR;
    this.year = hebYr;
    const rh0 = new HDate(1, months.TISHREI, hebYr);
    const rh = rh0.abs();
    const rhDay = this.roshHashanaDay = rh0.getDay() + 1;

    // find the first Saturday on or after Rosh Hashana
    this.firstSaturday = HDate.dayOnOrBefore(6, rh + 6);
    const leap = this.leap = +HDate.isLeapYear(hebYr);
    this.il = Boolean(il);
    const key = `${leap}${rhDay}${type}`;
    if (types[key]) {
      this.key = key;
      this.theSedraArray = types[key];
    } else {
      const key2 = this.key = key + +this.il; // cast to num, then concat
      this.theSedraArray = types[key2];
    }
    if (!this.theSedraArray) {
      throw new Error(`improper sedra year type ${this.key} calculated for ${hebYr}`);
    }
  }

  /**
   * Returns the parsha (or parshiyot) read on Hebrew date
   * @param {HDate|number} hDate Hebrew date or R.D. days
   * @return {string[]}
   */
  get(hDate) {
    return this.lookup(hDate).parsha;
  }

  /**
   * Looks up parsha for the date, then returns a translated or transliterated string
   * @param {HDate|number} hDate Hebrew date or R.D. days
   * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale
   * @return {string}
   */
  getString(hDate, locale) {
    const parsha = this.get(hDate);
    const locale0 = locale || Locale.getLocaleName();
    let name = Locale.gettext(parsha[0], locale0);
    if (parsha.length == 2) {
      const hyphen = locale0 == 'he' ? '־' : '-';
      name += hyphen + Locale.gettext(parsha[1], locale0);
    }
    name = name.replace(/'/g, '’');
    return Locale.gettext('Parashat', locale0) + ' ' + name;
  }

  /**
   * Checks to see if this day would be a regular parasha HaShavua
   * Torah reading or special holiday reading
   * @param {HDate|number} hDate Hebrew date or R.D. days
   * @return {boolean}
   */
  isParsha(hDate) {
    return !this.lookup(hDate).chag;
  }

  /**
   * Returns the date that a parsha occurs
   * @param {number|string|string[]} parsha
   * @return {HDate}
   */
  find(parsha) {
    if (typeof parsha === 'number') {
      if (parsha > 53 || parsha < 0 && !isValidDouble(parsha)) {
        throw new RangeError(`Invalid parsha number: ${parsha}`);
      }
      const idx = this.theSedraArray.indexOf(parsha);
      if (idx === -1) {
        return null; // doesn't occur this year
      }
      return new HDate(this.firstSaturday + idx * 7);
    } else if (typeof parsha === 'string') {
      const num = parsha2id.get(parsha);
      if (typeof num === 'number') {
        return this.find(num);
      } else if (parsha.indexOf('-') !== -1) {
        return this.find(parsha.split('-'));
      } else {
        // try to find Saturday holiday like 'Yom Kippur'
        const idx = this.theSedraArray.indexOf(parsha);
        if (idx === -1) {
          return null; // doesn't occur this year
        }
        return new HDate(this.firstSaturday + idx * 7);
      }
    } else if (Array.isArray(parsha) && parsha.length === 1 && typeof parsha[0] === 'string') {
      return this.find(parsha[0]);
    } else if (Array.isArray(parsha) && parsha.length === 2 && typeof parsha[0] === 'string' && typeof parsha[1] === 'string') {
      const p1 = parsha[0];
      const p2 = parsha[1];
      const num1 = parsha2id.get(p1);
      const num2 = parsha2id.get(p2);
      if (num2 === num1 + 1) {
        return this.find(-num1);
      } else {
        throw new RangeError(`Unrecognized parsha name: ${p1}-${p2}`);
      }
    } else {
      throw new TypeError(`Invalid parsha argument: ${parsha}`);
    }
  }

  /**
   * @return {Object[]}
   */
  getSedraArray() {
    return this.theSedraArray;
  }

  /**
   * R.D. date of the first Saturday on or after Rosh Hashana
   * @return {number}
   */
  getFirstSaturday() {
    return this.firstSaturday;
  }

  /** @return {number} */
  getYear() {
    return this.year;
  }

  /**
   * Returns an object describing the parsha on the first Saturday on or after absdate
   * @param {HDate|number} hDate Hebrew date or R.D. days
   * @return {SedraResult}
   */
  lookup(hDate) {
    const absDate = typeof hDate === 'number' ? hDate : HDate.isHDate(hDate) ? hDate.abs() : throwError(`Bad date argument: ${hDate}`);

    // find the first saturday on or after today's date
    const saturday = HDate.dayOnOrBefore(6, absDate + 6);
    const weekNum = (saturday - this.firstSaturday) / 7;
    const index = this.theSedraArray[weekNum];
    if (typeof index === 'undefined') {
      const sedra = getSedra_(this.year + 1, this.il);
      return sedra.lookup(saturday); // must be next year
    }
    if (typeof index === 'string') {
      // Shabbat has a chag. Return a description
      return {
        parsha: [index],
        chag: true
      };
    }
    if (index >= 0) {
      return {
        parsha: [parshiot[index]],
        chag: false,
        num: index + 1
      };
    }
    const p1 = D(index); // undouble the parsha
    return {
      parsha: [parshiot[p1], parshiot[p1 + 1]],
      chag: false,
      num: [p1 + 1, p1 + 2]
    };
  }
}

/**
 * The 54 parshiyot of the Torah as transilterated strings
 * parshiot[0] == 'Bereshit', parshiot[1] == 'Noach', parshiot[53] == "Ha'azinu".
 * @readonly
 * @type {string[]}
 */
const parshiot = ['Bereshit', 'Noach', 'Lech-Lecha', 'Vayera', 'Chayei Sara', 'Toldot', 'Vayetzei', 'Vayishlach', 'Vayeshev', 'Miketz', 'Vayigash', 'Vayechi', 'Shemot', 'Vaera', 'Bo', 'Beshalach', 'Yitro', 'Mishpatim', 'Terumah', 'Tetzaveh', 'Ki Tisa', 'Vayakhel', 'Pekudei', 'Vayikra', 'Tzav', 'Shmini', 'Tazria', 'Metzora', 'Achrei Mot', 'Kedoshim', 'Emor', 'Behar', 'Bechukotai', 'Bamidbar', 'Nasso', 'Beha\'alotcha', 'Sh\'lach', 'Korach', 'Chukat', 'Balak', 'Pinchas', 'Matot', 'Masei', 'Devarim', 'Vaetchanan', 'Eikev', 'Re\'eh', 'Shoftim', 'Ki Teitzei', 'Ki Tavo', 'Nitzavim', 'Vayeilech', 'Ha\'azinu'];
const parsha2id = new Map();
for (let id = 0; id < parshiot.length; id++) {
  const name = parshiot[id];
  parsha2id.set(name, id);
}

/**
 * @private
 * @param {number} id
 * @return {boolean}
 */
function isValidDouble(id) {
  switch (id) {
    case -21: // Vayakhel-Pekudei
    case -26: // Tazria-Metzora
    case -28: // Achrei Mot-Kedoshim
    case -31: // Behar-Bechukotai
    case -38: // Chukat-Balak
    case -41: // Matot-Masei
    case -50:
      // Nitzavim-Vayeilech
      return true;
  }
  return false;
}

/**
 * @private
 * @param {number} p
 * @return {number}
 */
function D(p) {
  // parsha doubler/undoubler
  return -p;
}
const RH = 'Rosh Hashana'; // 0
const YK = 'Yom Kippur'; // 1

const SUKKOT = 'Sukkot'; // 0
const CHMSUKOT = 'Sukkot Shabbat Chol ha-Moed'; // 0
const SHMINI = 'Shmini Atzeret'; // 0
const EOY = CHMSUKOT; // always Sukkot day 3, 5 or 6

const PESACH = 'Pesach'; // 25
const PESACH1 = 'Pesach I';
const CHMPESACH = 'Pesach Shabbat Chol ha-Moed'; // 25
const PESACH7 = 'Pesach VII'; // 25
const PESACH8 = 'Pesach VIII';
const SHAVUOT = 'Shavuot'; // 33

/**
 * Returns an array from start to end
 * @private
 * @param {number} start beginning number, inclusive
 * @param {number} stop ending number, inclusive
 * @return {number[]}
 */
function range$1(start, stop) {
  return Array.from({
    length: stop - start + 1
  }, (v, k) => k + start);
}

/**
 * The ordinary year types (keviot)
 * names are leap/nonleap - day - incomplete/regular/complete - diaspora/Israel
 * @private
 * @readonly
 * @type {Object.<string, Object[]>}
 */
const types = {
  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and
     * Kislev each have 29 days), and has Passover start on Tuesday. */
  // e.g. 5753
  '020': [51, 52].concat(EOY, range$1(0, 20), D(21), 23, 24, PESACH, 25, D(26), D(28), 30, D(31), range$1(33, 40), D(41), range$1(43, 49), D(50)),
  /* Hebrew year that starts on Monday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Thursday. */
  // e.g. 5756
  '0220': [51, 52].concat(EOY, range$1(0, 20), D(21), 23, 24, PESACH, 25, D(26), D(28), 30, D(31), 33, SHAVUOT, range$1(34, 37), D(38), 40, D(41), range$1(43, 49), D(50)),
  /* Hebrew year that starts on Thursday, is `regular' (Heshvan has 29
     * days and Kislev has 30 days), and has Passover start on Saturday. */
  // e.g. 5701
  '0510': [52].concat(YK, EOY, range$1(0, 20), D(21), 23, 24, PESACH1, PESACH8, 25, D(26), D(28), 30, D(31), range$1(33, 40), D(41), range$1(43, 50)),
  /* Hebrew year that starts on Thursday, is `regular' (Heshvan has 29
     * days and Kislev has 30 days), and has Passover start on Saturday. */
  // e.g. 5745
  '0511': [52].concat(YK, EOY, range$1(0, 20), D(21), 23, 24, PESACH, 25, D(26), D(28), range$1(30, 40), D(41), range$1(43, 50)),
  /* Hebrew year that starts on Thursday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Sunday. */
  // e.g. 5754
  '052': [52].concat(YK, CHMSUKOT, range$1(0, 24), PESACH7, 25, D(26), D(28), 30, D(31), range$1(33, 40), D(41), range$1(43, 50)),
  /* Hebrew year that starts on Saturday, is `incomplete' (Heshvan and Kislev
     * each have 29 days), and has Passover start on Sunday. */
  // e.g. 5761
  '070': [].concat(RH, 52, SUKKOT, SHMINI, range$1(0, 20), D(21), 23, 24, PESACH7, 25, D(26), D(28), 30, D(31), range$1(33, 40), D(41), range$1(43, 50)),
  /* Hebrew year that starts on Saturday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Tuesday. */
  // e.g. 5716
  '072': [].concat(RH, 52, SUKKOT, SHMINI, range$1(0, 20), D(21), 23, 24, CHMPESACH, 25, D(26), D(28), 30, D(31), range$1(33, 40), D(41), range$1(43, 49), D(50)),
  /* --  The leap year types (keviot) -- */
  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and
     * Kislev each have 29 days), and has Passover start on Thursday. */
  // e.g. 5746
  '1200': [51, 52].concat(CHMSUKOT, range$1(0, 27), CHMPESACH, range$1(28, 33), SHAVUOT, range$1(34, 37), D(38), 40, D(41), range$1(43, 49), D(50)),
  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and
     * Kislev each have 29 days), and has Passover start on Thursday. */
  // e.g. 5746
  '1201': [51, 52].concat(CHMSUKOT, range$1(0, 27), CHMPESACH, range$1(28, 40), D(41), range$1(43, 49), D(50)),
  /* Hebrew year that starts on Monday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Saturday. */
  // e.g.5752
  '1220': [51, 52].concat(CHMSUKOT, range$1(0, 27), PESACH1, PESACH8, range$1(28, 40), D(41), range$1(43, 50)),
  /* Hebrew year that starts on Monday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Saturday. */
  // e.g.5752
  '1221': [51, 52].concat(CHMSUKOT, range$1(0, 27), PESACH, range$1(28, 50)),
  /* Hebrew year that starts on Thursday, is `incomplete' (Heshvan and
     * Kislev both have 29 days), and has Passover start on Sunday. */
  // e.g. 5768
  '150': [52].concat(YK, CHMSUKOT, range$1(0, 28), PESACH7, range$1(29, 50)),
  /* Hebrew year that starts on Thursday, is `complete' (Heshvan and
     * Kislev both have 30 days), and has Passover start on Tuesday. */
  // eg. 5771
  '152': [52].concat(YK, CHMSUKOT, range$1(0, 28), CHMPESACH, range$1(29, 49), D(50)),
  /* Hebrew year that starts on Saturday, is `incomplete' (Heshvan and
     * Kislev each have 29 days), and has Passover start on Tuesday. */
  // e.g.5757
  '170': [].concat(RH, 52, SUKKOT, SHMINI, range$1(0, 27), CHMPESACH, range$1(28, 40), D(41), range$1(43, 49), D(50)),
  /* Hebrew year that starts on Saturday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Thursday. */
  '1720': [].concat(RH, 52, SUKKOT, SHMINI, range$1(0, 27), CHMPESACH, range$1(28, 33), SHAVUOT, range$1(34, 37), D(38), 40, D(41), range$1(43, 49), D(50))
};

/* Hebrew year that starts on Monday, is `complete' (Heshvan and
 * Kislev each have 30 days), and has Passover start on Thursday. */
types['0221'] = types['020'];

/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29
 * days and Kislev has 30 days), and has Passover start on Thursday. */
// e.g. 5715
types['0310'] = types['0220'];

/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29
 * days and Kislev has 30 days), and has Passover start on Thursday. */
types['0311'] = types['020'];

/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29
 * days and Kislev has 30 days), and has Passover start on Saturday. */
// e.g. 5715
types['1310'] = types['1220'];
/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29
 * days and Kislev has 30 days), and has Passover start on Saturday. */
types['1311'] = types['1221'];

/* Hebrew year that starts on Saturday, is `complete' (Heshvan and
 * Kislev each have 30 days), and has Passover start on Thursday. */
types['1721'] = types['170'];
const sedraCache = new QuickLRU({
  maxSize: 400
});

/**
 * @private
 * @param {number} hyear
 * @param {boolean} il
 * @return {Sedra}
 */
function getSedra_(hyear, il) {
  const cacheKey = `${hyear}-${il ? 1 : 0}`;
  let sedra = sedraCache.get(cacheKey);
  if (!sedra) {
    sedra = new Sedra(hyear, il);
    sedraCache.set(cacheKey, sedra);
  }
  return sedra;
}

/**
 * Represents one of 54 weekly Torah portions, always on a Saturday
 */
class ParshaEvent extends Event {
  /**
   * @param {HDate} date
   * @param {string[]} parsha - untranslated name of single or double parsha,
   *   such as ['Bereshit'] or ['Achrei Mot', 'Kedoshim']
   * @param {boolean} il
   * @param {number|number[]} num
   */
  constructor(date, parsha, il, num) {
    if (!Array.isArray(parsha) || parsha.length === 0 || parsha.length > 2) {
      throw new TypeError('Bad parsha argument');
    }
    const desc = 'Parashat ' + parsha.join('-');
    super(date, desc, flags.PARSHA_HASHAVUA);
    this.parsha = parsha;
    this.il = Boolean(il);
    this.num = num || -1;
  }
  /**
   * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   * @return {string}
   */
  render(locale) {
    const locale0 = locale || Locale.getLocaleName();
    const parsha = this.parsha;
    let name = Locale.gettext(parsha[0], locale);
    if (parsha.length == 2) {
      const hyphen = locale0 == 'he' ? '־' : '-';
      name += hyphen + Locale.gettext(parsha[1], locale);
    }
    name = name.replace(/'/g, '’');
    const str = Locale.gettext('Parashat', locale) + ' ' + name;
    return str.normalize();
  }
  /** @return {string} */
  basename() {
    return this.parsha.join('-');
  }
  /** @return {string} */
  url() {
    const year = this.getDate().greg().getFullYear();
    if (year < 100) {
      return undefined;
    }
    const dt = this.urlDateSuffix();
    const url = 'https://www.hebcal.com/sedrot/' + this.basename().toLowerCase().replace(/'/g, '').replace(/ /g, '-') + '-' + dt;
    return this.il ? url + '?i=on' : url;
  }

  /** @return {string} */
  urlDateSuffix() {
    const isoDateTime = this.getDate().greg().toISOString();
    const isoDate = isoDateTime.substring(0, isoDateTime.indexOf('T'));
    return isoDate.replace(/-/g, '');
  }
}

const SUN$1 = 0;
const TUE$1 = 2;
const FRI$2 = 5;
const SAT$2 = 6;
const NISAN$2 = months.NISAN;
const IYYAR = months.IYYAR;

/**
 * Yom HaShoah first observed in 1951.
 * When the actual date of Yom Hashoah falls on a Friday, the
 * state of Israel observes Yom Hashoah on the preceding
 * Thursday. When it falls on a Sunday, Yom Hashoah is observed
 * on the following Monday.
 * http://www.ushmm.org/remembrance/dor/calendar/
 * @private
 * @param {number} year
 * @return {HDate|null}
 */
function dateYomHaShoah(year) {
  if (year < 5711) {
    return null;
  }
  let nisan27dt = new HDate(27, NISAN$2, year);
  if (nisan27dt.getDay() === FRI$2) {
    nisan27dt = new HDate(26, NISAN$2, year);
  } else if (nisan27dt.getDay() === SUN$1) {
    nisan27dt = new HDate(28, NISAN$2, year);
  }
  return nisan27dt;
}

/**
 * Yom HaAtzma'ut only celebrated after 1948
 * @private
 * @param {number} year
 * @return {HDate|null}
 */
function dateYomHaZikaron(year) {
  if (year < 5708) {
    return null;
  }
  let day;
  const pesach = new HDate(15, NISAN$2, year);
  const pdow = pesach.getDay();
  if (pdow === SUN$1) {
    day = 2;
  } else if (pdow === SAT$2) {
    day = 3;
  } else if (year < 5764) {
    day = 4;
  } else if (pdow === TUE$1) {
    day = 5;
  } else {
    day = 4;
  }
  return new HDate(day, IYYAR, year);
}

const Nisan = months.NISAN;
const Iyyar = months.IYYAR;
const Sivan = months.SIVAN;
const Tamuz = months.TAMUZ;
const Av = months.AV;
const Elul = months.ELUL;
const Tishrei = months.TISHREI;
const Cheshvan = months.CHESHVAN;
const Kislev = months.KISLEV;
const Shvat = months.SHVAT;
const Adar2 = months.ADAR_II;
const CHAG$1 = flags.CHAG;
const LIGHT_CANDLES$1 = flags.LIGHT_CANDLES;
const YOM_TOV_ENDS$1 = flags.YOM_TOV_ENDS;
const CHUL_ONLY$1 = flags.CHUL_ONLY;
const IL_ONLY$2 = flags.IL_ONLY;
const LIGHT_CANDLES_TZEIS$2 = flags.LIGHT_CANDLES_TZEIS;
const CHANUKAH_CANDLES$2 = flags.CHANUKAH_CANDLES;
const MAJOR_FAST$2 = flags.MAJOR_FAST;
const MINOR_HOLIDAY$2 = flags.MINOR_HOLIDAY;
const EREV$2 = flags.EREV;
const CHOL_HAMOED$1 = flags.CHOL_HAMOED;
const emojiPesach = '🫓';
const emojiSukkot = '🌿🍋';
const staticHolidays = [{
  mm: Tishrei,
  dd: 2,
  desc: 'Rosh Hashana II',
  flags: CHAG$1 | YOM_TOV_ENDS$1,
  emoji: '🍏🍯'
}, {
  mm: Tishrei,
  dd: 9,
  desc: 'Erev Yom Kippur',
  flags: EREV$2 | LIGHT_CANDLES$1
}, {
  mm: Tishrei,
  dd: 10,
  desc: 'Yom Kippur',
  flags: CHAG$1 | MAJOR_FAST$2 | YOM_TOV_ENDS$1
}, {
  mm: Tishrei,
  dd: 14,
  desc: 'Erev Sukkot',
  flags: CHUL_ONLY$1 | EREV$2 | LIGHT_CANDLES$1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 15,
  desc: 'Sukkot I',
  flags: CHUL_ONLY$1 | CHAG$1 | LIGHT_CANDLES_TZEIS$2,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 16,
  desc: 'Sukkot II',
  flags: CHUL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 17,
  desc: 'Sukkot III (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 18,
  desc: 'Sukkot IV (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 2,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 19,
  desc: 'Sukkot V (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 3,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 20,
  desc: 'Sukkot VI (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 4,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 22,
  desc: 'Shmini Atzeret',
  flags: CHUL_ONLY$1 | CHAG$1 | LIGHT_CANDLES_TZEIS$2
}, {
  mm: Tishrei,
  dd: 23,
  desc: 'Simchat Torah',
  flags: CHUL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1
}, {
  mm: Tishrei,
  dd: 14,
  desc: 'Erev Sukkot',
  flags: IL_ONLY$2 | EREV$2 | LIGHT_CANDLES$1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 15,
  desc: 'Sukkot I',
  flags: IL_ONLY$2 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 16,
  desc: 'Sukkot II (CH\'\'M)',
  flags: IL_ONLY$2 | CHOL_HAMOED$1,
  chmDay: 1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 17,
  desc: 'Sukkot III (CH\'\'M)',
  flags: IL_ONLY$2 | CHOL_HAMOED$1,
  chmDay: 2,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 18,
  desc: 'Sukkot IV (CH\'\'M)',
  flags: IL_ONLY$2 | CHOL_HAMOED$1,
  chmDay: 3,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 19,
  desc: 'Sukkot V (CH\'\'M)',
  flags: IL_ONLY$2 | CHOL_HAMOED$1,
  chmDay: 4,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 20,
  desc: 'Sukkot VI (CH\'\'M)',
  flags: IL_ONLY$2 | CHOL_HAMOED$1,
  chmDay: 5,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 22,
  desc: 'Shmini Atzeret',
  flags: IL_ONLY$2 | CHAG$1 | YOM_TOV_ENDS$1
}, {
  mm: Tishrei,
  dd: 21,
  desc: 'Sukkot VII (Hoshana Raba)',
  flags: LIGHT_CANDLES$1 | CHOL_HAMOED$1,
  chmDay: -1,
  emoji: emojiSukkot
}, {
  mm: Kislev,
  dd: 24,
  desc: 'Chanukah: 1 Candle',
  flags: EREV$2 | MINOR_HOLIDAY$2 | CHANUKAH_CANDLES$2,
  emoji: '🕎1️⃣'
}, {
  mm: Shvat,
  dd: 15,
  desc: 'Tu BiShvat',
  flags: MINOR_HOLIDAY$2,
  emoji: '🌳'
}, {
  mm: Adar2,
  dd: 13,
  desc: 'Erev Purim',
  flags: EREV$2 | MINOR_HOLIDAY$2,
  emoji: '🎭️📜'
}, {
  mm: Adar2,
  dd: 14,
  desc: 'Purim',
  flags: MINOR_HOLIDAY$2,
  emoji: '🎭️📜'
}, {
  mm: Adar2,
  dd: 15,
  desc: 'Shushan Purim',
  flags: MINOR_HOLIDAY$2,
  emoji: '🎭️📜'
},
// Pesach Israel
{
  mm: Nisan,
  dd: 14,
  desc: 'Erev Pesach',
  flags: IL_ONLY$2 | EREV$2 | LIGHT_CANDLES$1,
  emoji: '🫓🍷'
}, {
  mm: Nisan,
  dd: 15,
  desc: 'Pesach I',
  flags: IL_ONLY$2 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 16,
  desc: 'Pesach II (CH\'\'M)',
  flags: IL_ONLY$2 | CHOL_HAMOED$1,
  chmDay: 1,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 17,
  desc: 'Pesach III (CH\'\'M)',
  flags: IL_ONLY$2 | CHOL_HAMOED$1,
  chmDay: 2,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 18,
  desc: 'Pesach IV (CH\'\'M)',
  flags: IL_ONLY$2 | CHOL_HAMOED$1,
  chmDay: 3,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 19,
  desc: 'Pesach V (CH\'\'M)',
  flags: IL_ONLY$2 | CHOL_HAMOED$1,
  chmDay: 4,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 20,
  desc: 'Pesach VI (CH\'\'M)',
  flags: IL_ONLY$2 | CHOL_HAMOED$1 | LIGHT_CANDLES$1,
  chmDay: 5,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 21,
  desc: 'Pesach VII',
  flags: IL_ONLY$2 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiPesach
},
// Pesach chutz l'aretz
{
  mm: Nisan,
  dd: 14,
  desc: 'Erev Pesach',
  flags: CHUL_ONLY$1 | EREV$2 | LIGHT_CANDLES$1,
  emoji: '🫓🍷'
}, {
  mm: Nisan,
  dd: 15,
  desc: 'Pesach I',
  flags: CHUL_ONLY$1 | CHAG$1 | LIGHT_CANDLES_TZEIS$2,
  emoji: '🫓🍷'
}, {
  mm: Nisan,
  dd: 16,
  desc: 'Pesach II',
  flags: CHUL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 17,
  desc: 'Pesach III (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 1,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 18,
  desc: 'Pesach IV (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 2,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 19,
  desc: 'Pesach V (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 3,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 20,
  desc: 'Pesach VI (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1 | LIGHT_CANDLES$1,
  chmDay: 4,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 21,
  desc: 'Pesach VII',
  flags: CHUL_ONLY$1 | CHAG$1 | LIGHT_CANDLES_TZEIS$2,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 22,
  desc: 'Pesach VIII',
  flags: CHUL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiPesach
}, {
  mm: Iyyar,
  dd: 14,
  desc: 'Pesach Sheni',
  flags: MINOR_HOLIDAY$2
}, {
  mm: Iyyar,
  dd: 18,
  desc: 'Lag BaOmer',
  flags: MINOR_HOLIDAY$2,
  emoji: '🔥'
}, {
  mm: Sivan,
  dd: 5,
  desc: 'Erev Shavuot',
  flags: EREV$2 | LIGHT_CANDLES$1,
  emoji: '⛰️🌸'
}, {
  mm: Sivan,
  dd: 6,
  desc: 'Shavuot',
  flags: IL_ONLY$2 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: '⛰️🌸'
}, {
  mm: Sivan,
  dd: 6,
  desc: 'Shavuot I',
  flags: CHUL_ONLY$1 | CHAG$1 | LIGHT_CANDLES_TZEIS$2,
  emoji: '⛰️🌸'
}, {
  mm: Sivan,
  dd: 7,
  desc: 'Shavuot II',
  flags: CHUL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: '⛰️🌸'
}, {
  mm: Av,
  dd: 15,
  desc: 'Tu B\'Av',
  flags: MINOR_HOLIDAY$2,
  emoji: '❤️'
}, {
  mm: Elul,
  dd: 1,
  desc: 'Rosh Hashana LaBehemot',
  flags: MINOR_HOLIDAY$2,
  emoji: '🐑'
}, {
  mm: Elul,
  dd: 29,
  desc: 'Erev Rosh Hashana',
  flags: EREV$2 | LIGHT_CANDLES$1,
  emoji: '🍏🍯'
}];
const staticModernHolidays = [{
  firstYear: 5727,
  mm: Iyyar,
  dd: 28,
  desc: 'Yom Yerushalayim',
  chul: true
}, {
  firstYear: 5737,
  mm: Kislev,
  dd: 6,
  desc: 'Ben-Gurion Day',
  satPostponeToSun: true,
  friPostponeToSun: true
}, {
  firstYear: 5750,
  mm: Shvat,
  dd: 30,
  desc: 'Family Day'
}, {
  firstYear: 5758,
  mm: Cheshvan,
  dd: 12,
  desc: 'Yitzhak Rabin Memorial Day',
  friSatMovetoThu: true
}, {
  firstYear: 5764,
  mm: Iyyar,
  dd: 10,
  desc: 'Herzl Day',
  satPostponeToSun: true
}, {
  firstYear: 5765,
  mm: Tamuz,
  dd: 29,
  desc: 'Jabotinsky Day',
  satPostponeToSun: true
}, {
  firstYear: 5769,
  mm: Cheshvan,
  dd: 29,
  desc: 'Sigd',
  chul: true,
  suppressEmoji: true
}, {
  firstYear: 5777,
  mm: Nisan,
  dd: 10,
  desc: 'Yom HaAliyah',
  chul: true
}, {
  firstYear: 5777,
  mm: Cheshvan,
  dd: 7,
  desc: 'Yom HaAliyah School Observance'
}];

/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
const CHAG = flags.CHAG;
const IL_ONLY$1 = flags.IL_ONLY;
const LIGHT_CANDLES_TZEIS$1 = flags.LIGHT_CANDLES_TZEIS;
const CHANUKAH_CANDLES$1 = flags.CHANUKAH_CANDLES;
const MINOR_FAST$1 = flags.MINOR_FAST;
const SPECIAL_SHABBAT$1 = flags.SPECIAL_SHABBAT;
const MODERN_HOLIDAY$1 = flags.MODERN_HOLIDAY;
const MAJOR_FAST$1 = flags.MAJOR_FAST;
const MINOR_HOLIDAY$1 = flags.MINOR_HOLIDAY;
const EREV$1 = flags.EREV;

/** Represents a built-in holiday like Pesach, Purim or Tu BiShvat */
class HolidayEvent extends Event {
  /** @return {string} */
  basename() {
    return this.getDesc().replace(/ \d{4}$/, '').replace(/ \(CH''M\)$/, '').replace(/ \(observed\)$/, '').replace(/ \(Hoshana Raba\)$/, '').replace(/ [IV]+$/, '').replace(/: \d Candles?$/, '').replace(/: 8th Day$/, '').replace(/^Erev /, '');
  }
  /** @return {string} */
  url() {
    const year = this.getDate().greg().getFullYear();
    if (year < 100) {
      return undefined;
    }
    const url = 'https://www.hebcal.com/holidays/' + this.basename().toLowerCase().replace(/'/g, '').replace(/ /g, '-') + '-' + this.urlDateSuffix();
    return this.getFlags() & IL_ONLY$1 ? url + '?i=on' : url;
  }
  /** @return {string} */
  urlDateSuffix() {
    const year = this.getDate().greg().getFullYear();
    return year;
  }
  /** @return {string} */
  getEmoji() {
    if (this.emoji) {
      return this.emoji;
    } else if (this.getFlags() & SPECIAL_SHABBAT$1) {
      return '🕍';
    } else {
      return '✡️';
    }
  }
  /** @return {string[]} */
  getCategories() {
    if (this.cholHaMoedDay) {
      return ['holiday', 'major', 'cholhamoed'];
    }
    const cats = super.getCategories();
    if (cats[0] !== 'unknown') {
      return cats;
    }
    const desc = this.getDesc();
    // Don't depend on flags.MINOR_HOLIDAY always being set
    switch (desc) {
      case 'Lag BaOmer':
      case 'Leil Selichot':
      case 'Pesach Sheni':
      case 'Erev Purim':
      case 'Purim Katan':
      case 'Shushan Purim':
      case 'Tu B\'Av':
      case 'Tu BiShvat':
      case 'Rosh Hashana LaBehemot':
        return ['holiday', 'minor'];
      default:
        return ['holiday', 'major'];
    }
  }
  /**
   * Returns (translated) description of this event
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    const str = super.render(locale);
    return str.replace(/'/g, '’');
  }
  /**
   * Returns a brief (translated) description of this event.
   * For most events, this is the same as render(). For some events, it procudes
   * a shorter text (e.g. without a time or added description).
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    const str = super.renderBrief(locale);
    return str.replace(/'/g, '’');
  }
}
const roshChodeshStr = 'Rosh Chodesh';

/** Represents Rosh Chodesh, the beginning of a new month */
class RoshChodeshEvent extends HolidayEvent {
  /**
   * Constructs Rosh Chodesh event
   * @param {HDate} date Hebrew date event occurs
   * @param {string} monthName Hebrew month name (not translated)
   */
  constructor(date, monthName) {
    super(date, `${roshChodeshStr} ${monthName}`, flags.ROSH_CHODESH);
  }
  /**
   * Returns (translated) description of this event
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    const monthName = this.getDesc().substring(roshChodeshStr.length + 1);
    const monthName0 = Locale.gettext(monthName, locale);
    const monthName1 = monthName0.replace(/'/g, '’');
    return Locale.gettext(roshChodeshStr, locale) + ' ' + monthName1;
  }
  /** @return {string} */
  basename() {
    return this.getDesc();
  }
  /** @return {string} */
  getEmoji() {
    return this.emoji || '🌒';
  }
}

/**
 * Because Asara B'Tevet often occurs twice in the same Gregorian year,
 * we subclass HolidayEvent to override the `url()` method.
 */
class AsaraBTevetEvent extends HolidayEvent {
  /** @return {string} */
  urlDateSuffix() {
    const isoDateTime = this.getDate().greg().toISOString();
    const isoDate = isoDateTime.substring(0, isoDateTime.indexOf('T'));
    return isoDate.replace(/-/g, '');
  }
}
const mevarchimChodeshStr = 'Shabbat Mevarchim Chodesh';

/** Represents Mevarchim haChodesh, the announcement of the new month */
class MevarchimChodeshEvent extends Event {
  /**
   * Constructs Mevarchim haChodesh event
   * @param {HDate} date Hebrew date event occurs
   * @param {string} monthName Hebrew month name (not translated)
   * @param {string} [memo]
   */
  constructor(date, monthName, memo) {
    super(date, `${mevarchimChodeshStr} ${monthName}`, flags.SHABBAT_MEVARCHIM);
    this.monthName = monthName;
    if (memo) {
      this.memo = memo;
    } else {
      const hyear = date.getFullYear();
      const hmonth = date.getMonth();
      const monNext = hmonth == HDate.monthsInYear(hyear) ? NISAN$1 : hmonth + 1;
      const molad = new Molad(hyear, monNext);
      this.memo = molad.render('en', {
        hour12: false
      });
    }
  }
  /** @return {string} */
  basename() {
    return this.getDesc();
  }
  /**
   * Returns (translated) description of this event
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    const monthName0 = Locale.gettext(this.monthName, locale);
    const monthName = monthName0.replace(/'/g, '’');
    return Locale.gettext(mevarchimChodeshStr, locale) + ' ' + monthName;
  }
  /**
   * Returns (translated) description of this event
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    const str = this.render(locale);
    const space = str.indexOf(' ');
    return str.substring(space + 1);
  }
}

/** Represents Rosh Hashana, the Jewish New Year */
class RoshHashanaEvent extends HolidayEvent {
  /**
   * @private
   * @param {HDate} date Hebrew date event occurs
   * @param {number} hyear Hebrew year
   * @param {number} mask optional holiday flags
   */
  constructor(date, hyear, mask) {
    super(date, `Rosh Hashana ${hyear}`, mask);
    this.hyear = hyear;
  }
  /**
   * Returns (translated) description of this event
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    return Locale.gettext('Rosh Hashana', locale) + ' ' + this.hyear;
  }
  /** @return {string} */
  getEmoji() {
    return '🍏🍯';
  }
}
const ykk = 'Yom Kippur Katan';

/** YKK is minor day of atonement on the day preceeding each Rosh Chodesh */
class YomKippurKatanEvent extends HolidayEvent {
  /**
   * @private
   * @param {HDate} date Hebrew date event occurs
   * @param {string} nextMonthName name of the upcoming month
   */
  constructor(date, nextMonthName) {
    super(date, `${ykk} ${nextMonthName}`, flags.MINOR_FAST | flags.YOM_KIPPUR_KATAN);
    this.nextMonthName = nextMonthName;
    this.memo = `Minor Day of Atonement on the day preceeding Rosh Chodesh ${nextMonthName}`;
  }
  /** @return {string} */
  basename() {
    return this.getDesc();
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    const monthName0 = Locale.gettext(this.nextMonthName, locale);
    const monthName = monthName0.replace(/'/g, '’');
    return Locale.gettext(ykk, locale) + ' ' + monthName;
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    return Locale.gettext(ykk, locale);
  }
  /** @return {string} */
  url() {
    return undefined;
  }
}
const SUN = 0;
const TUE = 2;
const THU = 4;
const FRI$1 = 5;
const SAT$1 = 6;
const NISAN$1 = months.NISAN;
const TAMUZ = months.TAMUZ;
const AV = months.AV;
const TISHREI$1 = months.TISHREI;
const KISLEV = months.KISLEV;
const TEVET = months.TEVET;
const ADAR_I = months.ADAR_I;
const ADAR_II = months.ADAR_II;
const emojiIsraelFlag = {
  emoji: '🇮🇱'
};
const chanukahEmoji = '🕎';
const yearCache = new QuickLRU({
  maxSize: 400
});
const KEYCAP_DIGITS = ['0️⃣', '1️⃣', '2️⃣', '3️⃣', '4️⃣', '5️⃣', '6️⃣', '7️⃣', '8️⃣', '9️⃣'];

/**
 * Lower-level holidays interface, which returns a `Map` of `Event`s indexed by
 * `HDate.toString()`. These events must filtered especially for `flags.IL_ONLY`
 * or `flags.CHUL_ONLY` depending on Israel vs. Diaspora holiday scheme.
 * @private
 * @param {number} year Hebrew year
 * @return {Map<string,Event[]>}
 */
function getHolidaysForYear_(year) {
  if (typeof year !== 'number') {
    throw new TypeError(`bad Hebrew year: ${year}`);
  } else if (year < 1 || year > 32658) {
    throw new RangeError(`Hebrew year ${year} out of range 1-32658`);
  }
  const cached = yearCache.get(year);
  if (cached) {
    return cached;
  }
  const RH = new HDate(1, TISHREI$1, year);
  const pesach = new HDate(15, NISAN$1, year);
  const map = new Map();
  // eslint-disable-next-line require-jsdoc
  function add(...events) {
    for (const ev of events) {
      const key = ev.date.toString();
      const arr = map.get(key);
      if (typeof arr === 'object') {
        if (arr[0].getFlags() & EREV$1) {
          arr.unshift(ev);
        } else {
          arr.push(ev);
        }
      } else {
        map.set(key, [ev]);
      }
    }
  }
  for (const h of staticHolidays) {
    const hd = new HDate(h.dd, h.mm, year);
    const ev = new HolidayEvent(hd, h.desc, h.flags);
    if (h.emoji) ev.emoji = h.emoji;
    if (h.chmDay) ev.cholHaMoedDay = h.chmDay;
    add(ev);
  }

  // standard holidays that don't shift based on year
  add(new RoshHashanaEvent(RH, year, CHAG | LIGHT_CANDLES_TZEIS$1));

  // Variable date holidays
  add(new HolidayEvent(new HDate(3 + (RH.getDay() == THU), TISHREI$1, year), 'Tzom Gedaliah', MINOR_FAST$1));
  // first SAT after RH
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, 7 + RH.abs())), 'Shabbat Shuva', SPECIAL_SHABBAT$1));
  const rchTevet = HDate.shortKislev(year) ? new HDate(1, TEVET, year) : new HDate(30, KISLEV, year);
  add(new HolidayEvent(rchTevet, 'Chag HaBanot', MINOR_HOLIDAY$1));
  // yes, we know Kislev 30-32 are wrong
  // HDate() corrects the month automatically
  for (let candles = 2; candles <= 8; candles++) {
    const hd = new HDate(23 + candles, KISLEV, year);
    add(new HolidayEvent(hd, `Chanukah: ${candles} Candles`, MINOR_HOLIDAY$1 | CHANUKAH_CANDLES$1, {
      chanukahDay: candles - 1,
      emoji: chanukahEmoji + KEYCAP_DIGITS[candles]
    }));
  }
  add(new HolidayEvent(new HDate(32, KISLEV, year), 'Chanukah: 8th Day', MINOR_HOLIDAY$1, {
    chanukahDay: 8,
    emoji: chanukahEmoji
  }));
  add(new AsaraBTevetEvent(new HDate(10, TEVET, year), 'Asara B\'Tevet', MINOR_FAST$1));
  const pesachAbs = pesach.abs();
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, pesachAbs - 43)), 'Shabbat Shekalim', SPECIAL_SHABBAT$1), new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, pesachAbs - 30)), 'Shabbat Zachor', SPECIAL_SHABBAT$1), new HolidayEvent(new HDate(pesachAbs - (pesach.getDay() == TUE ? 33 : 31)), 'Ta\'anit Esther', MINOR_FAST$1));
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, pesachAbs - 14) - 7), 'Shabbat Parah', SPECIAL_SHABBAT$1), new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, pesachAbs - 14)), 'Shabbat HaChodesh', SPECIAL_SHABBAT$1), new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, pesachAbs - 1)), 'Shabbat HaGadol', SPECIAL_SHABBAT$1), new HolidayEvent(
  // if the fast falls on Shabbat, move to Thursday
  pesach.prev().getDay() == SAT$1 ? pesach.onOrBefore(THU) : new HDate(14, NISAN$1, year), 'Ta\'anit Bechorot', MINOR_FAST$1));
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, new HDate(1, TISHREI$1, year + 1).abs() - 4)), 'Leil Selichot', MINOR_HOLIDAY$1, {
    emoji: '🕍'
  }));
  if (pesach.getDay() == SUN) {
    add(new HolidayEvent(new HDate(16, ADAR_II, year), 'Purim Meshulash', MINOR_HOLIDAY$1));
  }
  if (HDate.isLeapYear(year)) {
    add(new HolidayEvent(new HDate(14, ADAR_I, year), 'Purim Katan', MINOR_HOLIDAY$1, {
      emoji: '🎭️'
    }));
    add(new HolidayEvent(new HDate(15, ADAR_I, year), 'Shushan Purim Katan', MINOR_HOLIDAY$1, {
      emoji: '🎭️'
    }));
  }
  const nisan27dt = dateYomHaShoah(year);
  if (nisan27dt) {
    add(new HolidayEvent(nisan27dt, 'Yom HaShoah', MODERN_HOLIDAY$1));
  }
  const yomHaZikaronDt = dateYomHaZikaron(year);
  if (yomHaZikaronDt) {
    add(new HolidayEvent(yomHaZikaronDt, 'Yom HaZikaron', MODERN_HOLIDAY$1, emojiIsraelFlag), new HolidayEvent(yomHaZikaronDt.next(), 'Yom HaAtzma\'ut', MODERN_HOLIDAY$1, emojiIsraelFlag));
  }
  for (const h of staticModernHolidays) {
    if (year >= h.firstYear) {
      let hd = new HDate(h.dd, h.mm, year);
      const dow = hd.getDay();
      if (h.friSatMovetoThu && (dow === FRI$1 || dow === SAT$1)) {
        hd = hd.onOrBefore(THU);
      } else if (h.friPostponeToSun && dow === FRI$1) {
        hd = new HDate(hd.abs() + 2);
      } else if (h.satPostponeToSun && dow === SAT$1) {
        hd = hd.next();
      }
      const mask = h.chul ? MODERN_HOLIDAY$1 : MODERN_HOLIDAY$1 | IL_ONLY$1;
      const ev = new HolidayEvent(hd, h.desc, mask);
      if (!h.suppressEmoji) {
        ev.emoji = '🇮🇱';
      }
      add(ev);
    }
  }
  let tamuz17 = new HDate(17, TAMUZ, year);
  let tamuz17attrs;
  if (tamuz17.getDay() == SAT$1) {
    tamuz17 = new HDate(18, TAMUZ, year);
    tamuz17attrs = {
      observed: true
    };
  }
  add(new HolidayEvent(tamuz17, 'Tzom Tammuz', MINOR_FAST$1, tamuz17attrs));
  let av9dt = new HDate(9, AV, year);
  let av9title = 'Tish\'a B\'Av';
  let av9attrs;
  if (av9dt.getDay() == SAT$1) {
    av9dt = av9dt.next();
    av9attrs = {
      observed: true
    };
    av9title += ' (observed)';
  }
  const av9abs = av9dt.abs();
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, av9abs)), 'Shabbat Chazon', SPECIAL_SHABBAT$1), new HolidayEvent(av9dt.prev(), 'Erev Tish\'a B\'Av', EREV$1 | MAJOR_FAST$1, av9attrs), new HolidayEvent(av9dt, av9title, MAJOR_FAST$1, av9attrs), new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, av9abs + 7)), 'Shabbat Nachamu', SPECIAL_SHABBAT$1));
  const monthsInYear = HDate.monthsInYear(year);
  for (let month = 1; month <= monthsInYear; month++) {
    const monthName = HDate.getMonthName(month, year);
    if ((month == NISAN$1 ? HDate.daysInMonth(HDate.monthsInYear(year - 1), year - 1) : HDate.daysInMonth(month - 1, year)) == 30) {
      add(new RoshChodeshEvent(new HDate(1, month, year), monthName));
      add(new RoshChodeshEvent(new HDate(30, month - 1, year), monthName));
    } else if (month !== TISHREI$1) {
      add(new RoshChodeshEvent(new HDate(1, month, year), monthName));
    }
  }

  // Begin: Yom Kippur Katan
  // start at Iyyar because one may not fast during Nisan
  for (let month = months.IYYAR; month <= monthsInYear; month++) {
    const nextMonth = month + 1;
    // Yom Kippur Katan is not observed on the day before Rosh Hashanah.
    // Not observed prior to Rosh Chodesh Cheshvan because Yom Kippur has just passed.
    // Not observed before Rosh Chodesh Tevet, because that day is Hanukkah.
    if (nextMonth === TISHREI$1 || nextMonth === months.CHESHVAN || nextMonth === TEVET) {
      continue;
    }
    let ykk = new HDate(29, month, year);
    const dow = ykk.getDay();
    if (dow === FRI$1 || dow === SAT$1) {
      ykk = ykk.onOrBefore(THU);
    }
    const nextMonthName = HDate.getMonthName(nextMonth, year);
    const ev = new YomKippurKatanEvent(ykk, nextMonthName);
    add(ev);
  }
  const sedra = getSedra_(year, false);
  const beshalachHd = sedra.find(15);
  add(new HolidayEvent(beshalachHd, 'Shabbat Shirah', SPECIAL_SHABBAT$1));

  // Birkat Hachamah appears only once every 28 years
  const birkatHaChama = getBirkatHaChama(year);
  if (birkatHaChama) {
    const hd = new HDate(birkatHaChama);
    add(new HolidayEvent(hd, 'Birkat Hachamah', MINOR_HOLIDAY$1, {
      emoji: '☀️'
    }));
  }
  yearCache.set(year, map);
  return map;
}

/**
 * Birkat Hachamah appears only once every 28 years.
 * Although almost always in Nisan, it can occur in Adar II.
 *   - 27 Adar II 5461 (Gregorian year 1701)
 *   - 29 Adar II 5993 (Gregorian year 2233)
 *
 * Due to drift, this will eventually slip into Iyyar
 *   - 2 Iyyar 7141 (Gregorian year 3381)
 * @private
 * @param {number} year
 * @return {number}
 */
function getBirkatHaChama(year) {
  const leap = HDate.isLeapYear(year);
  const startMonth = leap ? ADAR_II : NISAN$1;
  const startDay = leap ? 20 : 1;
  const baseRd = HDate.hebrew2abs(year, startMonth, startDay);
  for (let day = 0; day <= 40; day++) {
    const abs = baseRd + day;
    const elapsed = abs + 1373429;
    if (elapsed % 10227 == 172) {
      return abs;
    }
  }
  return 0;
}

/** @private */
const cals = new Map();

/**
 * Plug-ins for daily learning calendars such as Daf Yomi, Mishna Yomi, Nach Yomi, etc.
 *
 * Learning schedules are provided by the `@hebcal/learning` package.
 */
class DailyLearning {
  /**
   * Register a new learning calendar.
   * @param {string} name
   * @param {Function} calendar
   */
  static addCalendar(name, calendar) {
    if (typeof calendar !== 'function') {
      throw new TypeError(`Invalid calendar function: ${calendar}`);
    }
    cals.set(name, calendar);
  }

  /**
   * Returns an event from daily calendar for a given date. Returns `null` if there
   * is no learning from this calendar on this date.
   * @param {string} name
   * @param {HDate} hd
   * @return {Event}
   */
  static lookup(name, hd) {
    const fn = cals.get(name);
    if (typeof fn === 'function') {
      return fn(hd);
    }
    return null;
  }
}

// DO NOT EDIT THIS AUTO-GENERATED FILE!
const version = '5.1.0';

const NONE$1 = 0;
const HALF = 1;
const WHOLE = 2;

/**
 * @private
 * @param {Event[]} events
 * @param {HDate} hdate
 * @return {number}
 */
function hallel_(events, hdate) {
  const whole = events.filter(ev => {
    /** @type {string} */
    const desc = ev.getDesc();
    /** @type {HDate} */
    const hd = ev.getDate();
    const month = hd.getMonth();
    const mday = hd.getDate();
    return desc.startsWith('Chanukah') || desc.startsWith('Shavuot') || desc.startsWith('Sukkot') || month === months.NISAN && (mday === 15 || mday === 16) && ev.getFlags() & flags.CHAG ||
    // Pesach
    desc === 'Yom HaAtzma\'ut' || desc === 'Yom Yerushalayim';
  }).map(ev => {
    return ev.getDate().abs();
  });
  const abs = hdate.abs();
  if (whole.includes(abs)) {
    return WHOLE;
  }
  const half = events.filter(ev => {
    const desc = ev.getDesc();
    return ev.getFlags() & flags.ROSH_CHODESH || desc.startsWith('Pesach') && desc !== 'Pesach I' && desc !== 'Pesach II';
  }).map(ev => {
    return ev.getDate().abs();
  });
  if (half.includes(abs)) {
    return HALF;
  }
  return NONE$1;
}

var poAshkenazi = {
  "headers": {
    "plural-forms": "nplurals=2; plural=(n > 1);"
  },
  "contexts": {
    "": {
      "Shabbat": ["Shabbos"],
      "Achrei Mot": ["Achrei Mos"],
      "Bechukotai": ["Bechukosai"],
      "Beha'alotcha": ["Beha’aloscha"],
      "Bereshit": ["Bereshis"],
      "Chukat": ["Chukas"],
      "Erev Shavuot": ["Erev Shavuos"],
      "Erev Sukkot": ["Erev Sukkos"],
      "Ki Tavo": ["Ki Savo"],
      "Ki Teitzei": ["Ki Seitzei"],
      "Ki Tisa": ["Ki Sisa"],
      "Matot": ["Matos"],
      "Purim Katan": ["Purim Koton"],
      "Shabbat Chazon": ["Shabbos Chazon"],
      "Shabbat HaChodesh": ["Shabbos HaChodesh"],
      "Shabbat HaGadol": ["Shabbos HaGadol"],
      "Shabbat Nachamu": ["Shabbos Nachamu"],
      "Shabbat Parah": ["Shabbos Parah"],
      "Shabbat Shekalim": ["Shabbos Shekalim"],
      "Shabbat Shuva": ["Shabbos Shuvah"],
      "Shabbat Zachor": ["Shabbos Zachor"],
      "Shavuot": ["Shavuos"],
      "Shavuot I": ["Shavuos I"],
      "Shavuot II": ["Shavuos II"],
      "Shemot": ["Shemos"],
      "Shmini Atzeret": ["Shmini Atzeres"],
      "Simchat Torah": ["Simchas Torah"],
      "Sukkot": ["Sukkos"],
      "Sukkot I": ["Sukkos I"],
      "Sukkot II": ["Sukkos II"],
      "Sukkot II (CH''M)": ["Sukkos II (CH’’M)"],
      "Sukkot III (CH''M)": ["Sukkos III (CH’’M)"],
      "Sukkot IV (CH''M)": ["Sukkos IV (CH’’M)"],
      "Sukkot V (CH''M)": ["Sukkos V (CH’’M)"],
      "Sukkot VI (CH''M)": ["Sukkos VI (CH’’M)"],
      "Sukkot VII (Hoshana Raba)": ["Sukkos VII (Hoshana Raba)"],
      "Ta'anit Bechorot": ["Ta’anis Bechoros"],
      "Ta'anit Esther": ["Ta’anis Esther"],
      "Toldot": ["Toldos"],
      "Vaetchanan": ["Vaeschanan"],
      "Yitro": ["Yisro"],
      "Vezot Haberakhah": ["Vezos Haberakhah"],
      "Parashat": ["Parshas"],
      "Leil Selichot": ["Leil Selichos"],
      "Shabbat Mevarchim Chodesh": ["Shabbos Mevorchim Chodesh"],
      "Shabbat Shirah": ["Shabbos Shirah"],
      "Tevet": ["Teves"],
      "Asara B'Tevet": ["Asara B’Teves"],
      "Alot HaShachar": ["Alos HaShachar"],
      "Kriat Shema, sof zeman": ["Krias Shema, sof zman"],
      "Tefilah, sof zeman": ["Tefilah, sof zman"],
      "Kriat Shema, sof zeman (MGA)": ["Krias Shema, sof zman (MGA)"],
      "Tefilah, sof zeman (MGA)": ["Tefilah, sof zman (MGA)"],
      "Chatzot HaLailah": ["Chatzos HaLailah"],
      "Chatzot hayom": ["Chatzos"],
      "Tzeit HaKochavim": ["Tzeis HaKochavim"],
      "Birkat Hachamah": ["Birkas Hachamah"],
      "Shushan Purim Katan": ["Shushan Purim Koton"]
    }
  }
};

Locale.addLocale('ashkenazi', poAshkenazi);
Locale.addLocale('a', poAshkenazi);

var poHe = {
  "headers": {
    "plural-forms": "nplurals=2; plural=(n > 1);"
  },
  "contexts": {
    "": {
      "Shabbat": ["שַׁבָּת"],
      "Daf Yomi": ["דַף יוֹמִי"],
      "Parashat": ["פָּרָשַׁת"],
      "Achrei Mot": ["אַחֲרֵי מוֹת"],
      "Balak": ["בָּלָק"],
      "Bamidbar": ["בְּמִדְבַּר"],
      "Bechukotai": ["בְּחֻקֹּתַי"],
      "Beha'alotcha": ["בְּהַעֲלֹתְךָ"],
      "Behar": ["בְּהַר"],
      "Bereshit": ["בְּרֵאשִׁית"],
      "Beshalach": ["בְּשַׁלַּח"],
      "Bo": ["בֹּא"],
      "Chayei Sara": ["חַיֵּי שָֹרָה"],
      "Chukat": ["חֻקַּת"],
      "Devarim": ["דְּבָרִים"],
      "Eikev": ["עֵקֶב"],
      "Emor": ["אֱמוֹר"],
      "Ha'azinu": ["הַאֲזִינוּ"],
      "Kedoshim": ["קְדשִׁים"],
      "Ki Tavo": ["כִּי־תָבוֹא"],
      "Ki Teitzei": ["כִּי־תֵצֵא"],
      "Ki Tisa": ["כִּי תִשָּׂא"],
      "Korach": ["קוֹרַח"],
      "Lech-Lecha": ["לֶךְ־לְךָ"],
      "Masei": ["מַסְעֵי"],
      "Matot": ["מַּטּוֹת"],
      "Metzora": ["מְּצֹרָע"],
      "Miketz": ["מִקֵּץ"],
      "Mishpatim": ["מִּשְׁפָּטִים"],
      "Nasso": ["נָשׂא"],
      "Nitzavim": ["נִצָּבִים"],
      "Noach": ["נֹחַ"],
      "Pekudei": ["פְקוּדֵי"],
      "Pinchas": ["פִּינְחָס"],
      "Re'eh": ["רְאֵה"],
      "Sh'lach": ["שְׁלַח־לְךָ"],
      "Shemot": ["שְׁמוֹת"],
      "Shmini": ["שְּׁמִינִי"],
      "Shoftim": ["שׁוֹפְטִים"],
      "Tazria": ["תַזְרִיעַ"],
      "Terumah": ["תְּרוּמָה"],
      "Tetzaveh": ["תְּצַוֶּה"],
      "Toldot": ["תּוֹלְדוֹת"],
      "Tzav": ["צַו"],
      "Vaera": ["וָאֵרָא"],
      "Vaetchanan": ["וָאֶתְחַנַּן"],
      "Vayakhel": ["וַיַּקְהֵל"],
      "Vayechi": ["וַיְחִי"],
      "Vayeilech": ["וַיֵּלֶךְ"],
      "Vayera": ["וַיֵּרָא"],
      "Vayeshev": ["וַיֵּשֶׁב"],
      "Vayetzei": ["וַיֵּצֵא"],
      "Vayigash": ["וַיִּגַּשׁ"],
      "Vayikra": ["וַיִּקְרָא"],
      "Vayishlach": ["וַיִּשְׁלַח"],
      "Vezot Haberakhah": ["וְזֹאת הַבְּרָכָה"],
      "Yitro": ["יִתְרוֹ"],
      "Asara B'Tevet": ["עֲשָׂרָה בְּטֵבֵת"],
      "Candle lighting": ["הַדְלָקַת נֵרוֹת"],
      "Chanukah": ["חֲנוּכָּה"],
      "Chanukah: 1 Candle": ["חֲנוּכָּה: א׳ נֵר"],
      "Chanukah: 2 Candles": ["חֲנוּכָּה: ב׳ נֵרוֹת"],
      "Chanukah: 3 Candles": ["חֲנוּכָּה: ג׳ נֵרוֹת"],
      "Chanukah: 4 Candles": ["חֲנוּכָּה: ד׳ נֵרוֹת"],
      "Chanukah: 5 Candles": ["חֲנוּכָּה: ה׳ נֵרוֹת"],
      "Chanukah: 6 Candles": ["חֲנוּכָּה: ו׳ נֵרוֹת"],
      "Chanukah: 7 Candles": ["חֲנוּכָּה: ז׳ נֵרוֹת"],
      "Chanukah: 8 Candles": ["חֲנוּכָּה: ח׳ נֵרוֹת"],
      "Chanukah: 8th Day": ["חֲנוּכָּה: יוֹם ח׳"],
      "Days of the Omer": ["סְפִירַת הָעוֹמֶר"],
      "Omer": ["עוֹמֶר"],
      "day of the Omer": ["בָּעוֹמֶר"],
      "Erev Pesach": ["עֶרֶב פֶּסַח"],
      "Erev Purim": ["עֶרֶב פּוּרִים"],
      "Erev Rosh Hashana": ["עֶרֶב רֹאשׁ הַשָּׁנָה"],
      "Erev Shavuot": ["עֶרֶב שָׁבוּעוֹת"],
      "Erev Simchat Torah": ["עֶרֶב שִׂמְחַת תּוֹרָה"],
      "Erev Sukkot": ["עֶרֶב סוּכּוֹת"],
      "Erev Tish'a B'Av": ["עֶרֶב תִּשְׁעָה בְּאָב"],
      "Erev Yom Kippur": ["עֶרֶב יוֹם כִּפּוּר"],
      "Havdalah": ["הַבְדָּלָה"],
      "Lag BaOmer": ["ל״ג בָּעוֹמֶר"],
      "Leil Selichot": ["סליחות"],
      "Pesach": ["פֶּסַח"],
      "Pesach I": ["פֶּסַח א׳"],
      "Pesach II": ["פֶּסַח ב׳"],
      "Pesach II (CH''M)": ["פֶּסַח ב׳ (חוה״מ)"],
      "Pesach III (CH''M)": ["פֶּסַח ג׳ (חוה״מ)"],
      "Pesach IV (CH''M)": ["פֶּסַח ד׳ (חוה״מ)"],
      "Pesach Sheni": ["פֶּסַח שני"],
      "Pesach V (CH''M)": ["פֶּסַח ה׳ (חוה״מ)"],
      "Pesach VI (CH''M)": ["פֶּסַח ו׳ (חוה״מ)"],
      "Pesach VII": ["פֶּסַח ז׳"],
      "Pesach VIII": ["פֶּסַח ח׳"],
      "Purim": ["פּוּרִים"],
      "Purim Katan": ["פּוּרִים קָטָן"],
      "Rosh Chodesh %s": ["רֹאשׁ חוֹדֶשׁ %s"],
      "Rosh Chodesh": ["רֹאשׁ חוֹדֶשׁ"],
      "Adar": ["אַדָר"],
      "Adar I": ["אַדָר א׳"],
      "Adar II": ["אַדָר ב׳"],
      "Av": ["אָב"],
      "Cheshvan": ["חֶשְׁוָן"],
      "Elul": ["אֱלוּל"],
      "Iyyar": ["אִיָיר"],
      "Kislev": ["כִּסְלֵו"],
      "Nisan": ["נִיסָן"],
      "Sh'vat": ["שְׁבָט"],
      "Sivan": ["סִיוָן"],
      "Tamuz": ["תַּמּוּז"],
      "Tevet": ["טֵבֵת"],
      "Tishrei": ["תִּשְׁרֵי"],
      "Rosh Hashana": ["רֹאשׁ הַשָּׁנָה"],
      "Rosh Hashana I": ["רֹאשׁ הַשָּׁנָה א׳"],
      "Rosh Hashana II": ["רֹאשׁ הַשָּׁנָה ב׳"],
      "Shabbat Chazon": ["שַׁבָּת חֲזוֹן"],
      "Shabbat HaChodesh": ["שַׁבָּת הַחֹדֶשׁ"],
      "Shabbat HaGadol": ["שַׁבָּת הַגָּדוֹל"],
      "Shabbat Machar Chodesh": ["שַׁבָּת מָחָר חוֹדֶשׁ"],
      "Shabbat Nachamu": ["שַׁבָּת נַחֲמוּ"],
      "Shabbat Parah": ["שַׁבָּת פּרה"],
      "Shabbat Rosh Chodesh": ["שַׁבָּת רֹאשׁ חוֹדֶשׁ"],
      "Shabbat Shekalim": ["שַׁבָּת שְׁקָלִים"],
      "Shabbat Shuva": ["שַׁבָּת שׁוּבָה"],
      "Shabbat Zachor": ["שַׁבָּת זָכוֹר"],
      "Shavuot": ["שָׁבוּעוֹת"],
      "Shavuot I": ["שָׁבוּעוֹת א׳"],
      "Shavuot II": ["שָׁבוּעוֹת ב׳"],
      "Shmini Atzeret": ["שְׁמִינִי עֲצֶרֶת"],
      "Shushan Purim": ["שׁוּשָׁן פּוּרִים"],
      "Sigd": ["סיגד"],
      "Simchat Torah": ["שִׂמְחַת תּוֹרָה"],
      "Sukkot": ["סוּכּוֹת"],
      "Sukkot I": ["סוּכּוֹת א׳"],
      "Sukkot II": ["סוּכּוֹת ב׳"],
      "Sukkot II (CH''M)": ["סוּכּוֹת ב׳ (חוה״מ)"],
      "Sukkot III (CH''M)": ["סוּכּוֹת ג׳ (חוה״מ)"],
      "Sukkot IV (CH''M)": ["סוּכּוֹת ד׳ (חוה״מ)"],
      "Sukkot V (CH''M)": ["סוּכּוֹת ה׳ (חוה״מ)"],
      "Sukkot VI (CH''M)": ["סוּכּוֹת ו׳ (חוה״מ)"],
      "Sukkot VII (Hoshana Raba)": ["סוּכּוֹת ז׳ (הוֹשַׁעְנָא רַבָּה)"],
      "Ta'anit Bechorot": ["תַּעֲנִית בְּכוֹרוֹת"],
      "Ta'anit Esther": ["תַּעֲנִית אֶסְתֵּר"],
      "Tish'a B'Av": ["תִּשְׁעָה בְּאָב"],
      "Tu B'Av": ["טוּ בְּאָב"],
      "Tu BiShvat": ["טוּ בִּשְׁבָט"],
      "Tu B'Shvat": ["טוּ בִּשְׁבָט"],
      "Tzom Gedaliah": ["צוֹם גְּדַלְיָה"],
      "Tzom Tammuz": ["צוֹם תָּמוּז"],
      "Yom HaAtzma'ut": ["יוֹם הָעַצְמָאוּת"],
      "Yom HaShoah": ["יוֹם הַשּׁוֹאָה"],
      "Yom HaZikaron": ["יוֹם הַזִּכָּרוֹן"],
      "Yom Kippur": ["יוֹם כִּפּוּר"],
      "Yom Yerushalayim": ["יוֹם יְרוּשָׁלַיִם"],
      "Yom HaAliyah": ["יוֹם הַעֲלִיָּה"],
      "Yom HaAliyah School Observance": ["שְׁמִירָת בֵּית הַסֵפֶר לְיוֹם הַעֲלִיָּה"],
      "Pesach I (on Shabbat)": ["פֶּסַח יוֹם א׳ (בְּשַׁבָּת)"],
      "Pesach Chol ha-Moed Day 1": ["פֶּסַח חוֹל הַמּוֹעֵד יוֹם א׳"],
      "Pesach Chol ha-Moed Day 2": ["פֶּסַח חוֹל הַמּוֹעֵד יוֹם ב׳"],
      "Pesach Chol ha-Moed Day 3": ["פֶּסַח חוֹל הַמּוֹעֵד יוֹם ג׳"],
      "Pesach Chol ha-Moed Day 4": ["פֶּסַח חוֹל הַמּוֹעֵד יוֹם ד׳"],
      "Pesach Chol ha-Moed Day 5": ["פֶּסַח חוֹל הַמּוֹעֵד יוֹם ה׳"],
      "Pesach Shabbat Chol ha-Moed": ["פֶּסַח שַׁבָּת חוֹל הַמּוֹעֵד"],
      "Shavuot II (on Shabbat)": ["שָׁבוּעוֹת יוֹם ב׳ (בְּשַׁבָּת)"],
      "Rosh Hashana I (on Shabbat)": ["רֹאשׁ הַשָּׁנָה יוֹם א׳ (בְּשַׁבָּת)"],
      "Yom Kippur (on Shabbat)": ["יוֹם כִּפּוּר (בְּשַׁבָּת)"],
      "Yom Kippur (Mincha, Traditional)": ["יוֹם כִּפּוּר מִנחָה"],
      "Yom Kippur (Mincha, Alternate)": ["יוֹם כִּפּוּר מִנחָה"],
      "Sukkot I (on Shabbat)": ["סוּכּוֹת יוֹם א׳ (בְּשַׁבָּת)"],
      "Sukkot Chol ha-Moed Day 1": ["סוּכּוֹת חוֹל הַמּוֹעֵד יוֹם א׳"],
      "Sukkot Chol ha-Moed Day 2": ["סוּכּוֹת חוֹל הַמּוֹעֵד יוֹם ב׳"],
      "Sukkot Chol ha-Moed Day 3": ["סוּכּוֹת חוֹל הַמּוֹעֵד יוֹם ג׳"],
      "Sukkot Chol ha-Moed Day 4": ["סוּכּוֹת חוֹל הַמּוֹעֵד יוֹם ד׳"],
      "Sukkot Chol ha-Moed Day 5": ["סוּכּוֹת חוֹל הַמּוֹעֵד יוֹם ה׳"],
      "Sukkot Shabbat Chol ha-Moed": ["סוּכּוֹת שַׁבָּת חוֹל הַמּוֹעֵד"],
      "Sukkot Final Day (Hoshana Raba)": ["סוּכּוֹת ז׳ (הוֹשַׁעְנָא רַבָּה)"],
      "Rosh Chodesh Adar": ["רֹאשׁ חוֹדֶשׁ אַדָר"],
      "Rosh Chodesh Adar I": ["רֹאשׁ חוֹדֶשׁ אַדָר א׳"],
      "Rosh Chodesh Adar II": ["רֹאשׁ חוֹדֶשׁ אַדָר ב׳"],
      "Rosh Chodesh Av": ["רֹאשׁ חוֹדֶשׁ אָב"],
      "Rosh Chodesh Cheshvan": ["רֹאשׁ חוֹדֶשׁ חֶשְׁוָן"],
      "Rosh Chodesh Elul": ["רֹאשׁ חוֹדֶשׁ אֱלוּל"],
      "Rosh Chodesh Iyyar": ["רֹאשׁ חוֹדֶשׁ אִיָיר"],
      "Rosh Chodesh Kislev": ["רֹאשׁ חוֹדֶשׁ כִּסְלֵו"],
      "Rosh Chodesh Nisan": ["רֹאשׁ חוֹדֶשׁ נִיסָן"],
      "Rosh Chodesh Sh'vat": ["רֹאשׁ חוֹדֶשׁ שְׁבָט"],
      "Rosh Chodesh Sivan": ["רֹאשׁ חוֹדֶשׁ סִיוָן"],
      "Rosh Chodesh Tamuz": ["רֹאשׁ חוֹדֶשׁ תָּמוּז"],
      "Rosh Chodesh Tevet": ["רֹאשׁ חוֹדֶשׁ טֵבֵת"],
      "min": ["דַּקּוֹת"],
      "Fast begins": ["תחילת הַצוֹם"],
      "Fast ends": ["סִיּוּם הַצוֹם"],
      "Rosh Hashana LaBehemot": ["רֹאשׁ הַשָּׁנָה לְמַעְשַׂר בְּהֵמָה"],
      "Tish'a B'Av (observed)": ["תִּשְׁעָה בְּאָב נִדחֶה"],
      "Shabbat Mevarchim Chodesh": ["שַׁבָּת מְבָרְכִים חוֹדֶשׁ"],
      "Shabbat Shirah": ["שַׁבָּת שִׁירָה"],
      "Chatzot HaLailah": ["חֲצוֹת הַלַיְלָה"],
      "Alot haShachar": ["עֲלוֹת הַשַּׁחַר"],
      "Misheyakir": ["מִשֶּׁיַּכִּיר"],
      "Misheyakir Machmir": ["מִשֶּׁיַּכִּיר מַחמִיר"],
      "Dawn": ["דִּימְדּוּמֵי בּוֹקֵר"],
      "Sunrise": ["הַנֵץ הַחַמָּה"],
      "Kriat Shema, sof zeman": ["סוֹף זְמַן קְרִיאַת שְׁמַע גר״א"],
      "Tefilah, sof zeman": ["סוֹף זְמַן תְּפִלָּה גר״א"],
      "Kriat Shema, sof zeman (MGA)": ["סוֹף זְמַן קְרִיאַת שְׁמַע מג״א"],
      "Tefilah, sof zeman (MGA)": ["סוֹף זְמַן תְּפִלָּה מג״א"],
      "Chatzot hayom": ["חֲצוֹת הַיּוֹם"],
      "Mincha Gedolah": ["מִנְחָה גְּדוֹלָה"],
      "Mincha Ketanah": ["מִנְחָה קְטַנָּה"],
      "Plag HaMincha": ["פְּלַג הַמִּנְחָה"],
      "Dusk": ["דִּימְדּוּמֵי עֶרֶב"],
      "Sunset": ["שְׁקִיעָה"],
      "Nightfall - End of ordained fasts": ["לַיְלָה - גמר תעניות דרבנן"],
      "Tzeit HaKochavim": ["צֵאת הַכּוֹכָבִים"],
      "Lovingkindness": ["חֶֽסֶד"],
      "Might": ["גְבוּרָה"],
      "Beauty": ["תִּפאֶרֶת"],
      "Eternity": ["נֶּֽצַח"],
      "Splendor": ["הוֹד"],
      "Foundation": ["יְּסוֹד"],
      "Majesty": ["מַּלְכוּת"],
      "day": ["יוֹם"],
      "Chanukah Day 1": ["חֲנוּכָּה יוֹם א׳"],
      "Chanukah Day 2": ["חֲנוּכָּה יוֹם ב׳"],
      "Chanukah Day 3": ["חֲנוּכָּה יוֹם ג׳"],
      "Chanukah Day 4": ["חֲנוּכָּה יוֹם ד׳"],
      "Chanukah Day 5": ["חֲנוּכָּה יוֹם ה׳"],
      "Chanukah Day 6": ["חֲנוּכָּה יוֹם ו׳"],
      "Chanukah Day 7": ["חֲנוּכָּה יוֹם ז׳"],
      "Chanukah Day 7 (on Rosh Chodesh)": ["חֲנוּכָּה יוֹם ז׳ (רֹאשׁ חוֹדֶשׁ)"],
      "Chanukah Day 8": ["חֲנוּכָּה יוֹם ח׳"],
      "Chanukah Day 1 (on Shabbat)": ["חֲנוּכָּה יוֹם א׳ (בְּשַׁבָּת)"],
      "Chanukah Day 2 (on Shabbat)": ["חֲנוּכָּה יוֹם ב׳ (בְּשַׁבָּת)"],
      "Chanukah Day 3 (on Shabbat)": ["חֲנוּכָּה יוֹם ג׳ (בְּשַׁבָּת)"],
      "Chanukah Day 4 (on Shabbat)": ["חֲנוּכָּה יוֹם ד׳ (בְּשַׁבָּת)"],
      "Chanukah Day 5 (on Shabbat)": ["חֲנוּכָּה יוֹם ה׳ (בְּשַׁבָּת)"],
      "Chanukah Day 7 (on Shabbat)": ["חֲנוּכָּה יוֹם ז׳ (בְּשַׁבָּת)"],
      "Chanukah Day 8 (on Shabbat)": ["חֲנוּכָּה יוֹם ח׳ (בְּשַׁבָּת)"],
      "Shabbat Rosh Chodesh Chanukah": ["שַׁבָּת רֹאשׁ חוֹדֶשׁ חֲנוּכָּה"],
      "Yom Kippur Katan": ["יוֹם כִּפּוּר קָטָן"],
      "Family Day": ["יוֹם הַמִּשׁפָּחָה"],
      "Yitzhak Rabin Memorial Day": ["יוֹם הַזִּכָּרוֹן ליצחק רבין"],
      "Jabotinsky Day": ["יוֹם ז׳בוטינסקי"],
      "Herzl Day": ["יוֹם הרצל"],
      "Ben-Gurion Day": ["יוֹם בן־גוריון"],
      "Birkat Hachamah": ["בִרְכַּת הַחַמָּה"],
      "Shushan Purim Katan": ["שׁוּשָׁן פּוּרִים קָטָן"],
      "Purim Meshulash": ["פּוּרִים מְשׁוּלָּשׁ"],
      "after sunset": ["אחרי השקיעה"],
      "Yerushalmi": ["יְרוּשַׁלְמִי"],
      "Chag HaBanot": ["חַג הַבָּנוֹת"],
      "Joshua": ["יְהוֹשׁוּעַ"],
      "Judges": ["שׁוֹפְטִים"],
      "I Samuel": ["שְׁמוּאֵל רִאשׁוֹן"],
      "II Samuel": ["שְׁמוּאֵל שֵׁנִי"],
      "I Kings": ["מְלָכִים רִאשׁוֹן"],
      "II Kings": ["מְלָכִים שֵׁנִי"],
      "Isaiah": ["יְשַׁעְיָהוּ"],
      "Jeremiah": ["יִרְמְיָהוּ"],
      "Ezekiel": ["יְחֶזְקֵאל"],
      "Hosea": ["הוֹשֵׁעַ"],
      "Joel": ["יוֹאֵל"],
      "Amos": ["עָמוּס"],
      "Obadiah": ["עוֹבַדְיָה"],
      "Jonah": ["יוֹנָה"],
      "Micah": ["מִיכָה"],
      "Nachum": ["נַחוּם"],
      "Habakkuk": ["חֲבַקּוּק"],
      "Zephaniah": ["צְפַנְיָה"],
      "Haggai": ["חַגַּי"],
      "Zechariah": ["זְכַרְיָה"],
      "Malachi": ["מַלְאָכִי"],
      "Psalms": ["תְּהִלִּים"],
      "Proverbs": ["מִשְׁלֵי"],
      "Job": ["אִיּוֹב"],
      "Song of Songs": ["שִׁיר הַשִּׁירִים"],
      "Ruth": ["רוּת"],
      "Lamentations": ["אֵיכָה"],
      "Ecclesiastes": ["קֹהֶלֶת"],
      "Esther": ["אֶסְתֵּר"],
      "Daniel": ["דָּנִיֵּאל"],
      "Ezra": ["עֶזְרָא"],
      "Nehemiah": ["נְחֶמְיָה"],
      "I Chronicles": ["דִברֵי הַיָמִים רִאשׁוֹן"],
      "II Chronicles": ["דִברֵי הַיָמִים שֵׁנִי"],
      "Yom Kippur (Mincha)": ["יוֹם כִּפּוּר מִנחָה"],
      "Tish'a B'Av (Mincha)": ["תִּשְׁעָה בְּאָב מִנחָה"],
      "Asara B'Tevet (Mincha)": ["עֲשָׂרָה בְּטֵבֵת מִנחָה"],
      "Ta'anit Bechorot (Mincha)": ["תַּעֲנִית בְּכוֹרוֹת מִנחָה"],
      "Ta'anit Esther (Mincha)": ["תַּעֲנִית אֶסְתֵּר מִנחָה"],
      "Tzom Gedaliah (Mincha)": ["צוֹם גְּדַלְיָה מִנחָה"],
      "Tzom Tammuz (Mincha)": ["צוֹם תָּמוּז מִנחָה"],
      "Molad": ["מוֹלָד הָלְּבָנָה"],
      "chalakim": ["חֲלָקִים"]
    }
  }
};

Locale.addLocale('he', poHe);
Locale.addLocale('h', poHe);
const heStrs = poHe.contexts[''];
const heNoNikud = {};
for (const [key, val] of Object.entries(heStrs)) {
  heNoNikud[key] = [Locale.hebrewStripNikkud(val[0])];
}
const poHeNoNikud = {
  headers: poHe.headers,
  contexts: {
    '': heNoNikud
  }
};
Locale.addLocale('he-x-NoNikud', poHeNoNikud);

/**
 * @private
 * @param {number} start
 * @param {number} end
 * @return {number[]}
 */
function range(start, end) {
  const arr = [];
  for (let i = start; i <= end; i++) {
    arr.push(i);
  }
  return arr;
}
const NONE = {
  shacharit: false,
  mincha: false,
  allCongs: false
};

/**
 * @private
 * @param {HDate} hdate
 * @param {boolean} il
 * @return {TachanunResult}
 */
function tachanun_(hdate, il) {
  return tachanun0(hdate, il, true);
}

/**
 * @private
 * @param {HDate} hdate
 * @param {boolean} il
 * @param {boolean} checkNext
 * @return {TachanunResult}
 */
function tachanun0(hdate, il, checkNext) {
  const year = hdate.getFullYear();
  const dates = tachanunYear(year, il);
  const abs = hdate.abs();
  if (dates.none.indexOf(abs) > -1) {
    return NONE;
  }
  const dow = hdate.getDay();
  const ret = {
    shacharit: false,
    mincha: false,
    allCongs: false
  };
  if (dates.some.indexOf(abs) === -1) {
    ret.allCongs = true;
  }
  if (dow !== 6) {
    ret.shacharit = true;
  }
  const tomorrow = abs + 1;
  if (checkNext && dates.yesPrev.indexOf(tomorrow) === -1) {
    const tmp = tachanun0(new HDate(tomorrow), il, false);
    ret.mincha = tmp.shacharit;
  } else {
    ret.mincha = dow !== 5;
  }
  if (ret.allCongs && !ret.mincha && !ret.shacharit) {
    return NONE;
  }
  return ret;
}

/**
 * @private
 * @param {number} year
 * @param {boolean} il
 * @return {*}
 */
function tachanunYear(year, il) {
  const leap = HDate.isLeapYear(year);
  const monthsInYear = 12 + leap;
  let av9dt = new HDate(9, months.AV, year);
  if (av9dt.getDay() === 6) {
    av9dt = av9dt.next();
  }
  let shushPurim = new HDate(15, months.ADAR_II, year);
  if (shushPurim.getDay() === 6) {
    shushPurim = shushPurim.next();
  }
  const none = [].concat(
  // Rosh Chodesh - 1st of every month. Also includes RH day 1 (1 Tishrei)
  range(1, monthsInYear).map(month => new HDate(1, month, year)),
  // Rosh Chodesh - 30th of months that have one
  range(1, monthsInYear).filter(month => HDate.daysInMonth(month, year) === 30).map(month => new HDate(30, month, year)), new HDate(2, months.TISHREI, year),
  // Rosh Hashana II
  // entire month of Nisan
  range(1, HDate.daysInMonth(months.NISAN, year)).map(mday => new HDate(mday, months.NISAN, year)), new HDate(18, months.IYYAR, year),
  // Lag BaOmer
  // Rosh Chodesh Sivan thru Isru Chag
  range(1, 8 - (il ? 1 : 0)).map(mday => new HDate(mday, months.SIVAN, year)), av9dt,
  // Tisha B'Av
  new HDate(15, months.AV, year),
  // Tu B'Av
  new HDate(29, months.ELUL, year),
  // Erev Rosh Hashanah
  // Erev Yom Kippur thru Isru Chag
  range(9, 24 - (il ? 1 : 0)).map(mday => new HDate(mday, months.TISHREI, year)),
  // Chanukah
  range(25, 33).map(mday => new HDate(mday, months.KISLEV, year)), new HDate(15, months.SHVAT, year),
  // Tu BiShvat
  new HDate(14, months.ADAR_II, year),
  // Purim
  shushPurim, leap ? new HDate(14, months.ADAR_I, year) : [] // Purim Katan
  );
  const some = [].concat(
  // Until 14 Sivan
  range(1, 13).map(mday => new HDate(mday, months.SIVAN, year)),
  // Until after Rosh Chodesh Cheshvan
  range(20, 31).map(mday => new HDate(mday, months.TISHREI, year)), new HDate(14, months.IYYAR, year),
  // Pesach Sheini
  // Yom HaAtzma'ut, which changes based on day of week
  year >= 5708 ? dateYomHaZikaron(year).next() : [],
  // Yom Yerushalayim
  year >= 5727 ? new HDate(28, months.IYYAR, year) : []);
  const yesPrev = [].concat(new HDate(29, months.ELUL, year - 1),
  // Erev Rosh Hashanah
  new HDate(9, months.TISHREI, year),
  // Erev Yom Kippur
  new HDate(14, months.IYYAR, year) // Pesach Sheini
  );
  return {
    none: none.map(hd => hd.abs()).sort((a, b) => a - b),
    some: some.map(hd => hd.abs()).sort((a, b) => a - b),
    yesPrev: yesPrev.map(hd => hd.abs()).sort((a, b) => a - b)
  };
}

/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
const FRI = 5;
const SAT = 6;
const NISAN = months.NISAN;
const SIVAN = months.SIVAN;
const ELUL = months.ELUL;
const TISHREI = months.TISHREI;
const LIGHT_CANDLES = flags.LIGHT_CANDLES;
const YOM_TOV_ENDS = flags.YOM_TOV_ENDS;
const CHUL_ONLY = flags.CHUL_ONLY;
const IL_ONLY = flags.IL_ONLY;
const LIGHT_CANDLES_TZEIS = flags.LIGHT_CANDLES_TZEIS;
const CHANUKAH_CANDLES = flags.CHANUKAH_CANDLES;
const MINOR_FAST = flags.MINOR_FAST;
const SPECIAL_SHABBAT = flags.SPECIAL_SHABBAT;
const MODERN_HOLIDAY = flags.MODERN_HOLIDAY;
const MAJOR_FAST = flags.MAJOR_FAST;
const ROSH_CHODESH = flags.ROSH_CHODESH;
const PARSHA_HASHAVUA = flags.PARSHA_HASHAVUA;
const DAF_YOMI = flags.DAF_YOMI;
const MISHNA_YOMI = flags.MISHNA_YOMI;
const NACH_YOMI = flags.NACH_YOMI;
const YERUSHALMI_YOMI = flags.YERUSHALMI_YOMI;
const OMER_COUNT = flags.OMER_COUNT;
const SHABBAT_MEVARCHIM = flags.SHABBAT_MEVARCHIM;
const MINOR_HOLIDAY = flags.MINOR_HOLIDAY;
const EREV = flags.EREV;
const CHOL_HAMOED = flags.CHOL_HAMOED;
const YOM_KIPPUR_KATAN = flags.YOM_KIPPUR_KATAN;
const unrecognizedAlreadyWarned = new Set();
const RECOGNIZED_OPTIONS = {
  location: 1,
  year: 1,
  isHebrewYear: 1,
  month: 1,
  numYears: 1,
  start: 1,
  end: 1,
  candlelighting: 1,
  candleLightingMins: 1,
  havdalahMins: 1,
  havdalahDeg: 1,
  fastEndDeg: 1,
  sedrot: 1,
  il: 1,
  noMinorFast: 1,
  noModern: 1,
  shabbatMevarchim: 1,
  noRoshChodesh: 1,
  noSpecialShabbat: 1,
  noHolidays: 1,
  omer: 1,
  molad: 1,
  ashkenazi: 1,
  locale: 1,
  addHebrewDates: 1,
  addHebrewDatesForEvents: 1,
  appendHebrewToSubject: 1,
  mask: 1,
  userMask: 1,
  yomKippurKatan: 1,
  hour12: 1,
  dailyLearning: 1,
  useElevation: 1
};

/**
 * @private
 * @param {CalOptions} options
 */
function warnUnrecognizedOptions(options) {
  for (const k of Object.keys(options)) {
    if (typeof RECOGNIZED_OPTIONS[k] === 'undefined' && !unrecognizedAlreadyWarned.has(k)) {
      console.warn(`Ignoring unrecognized HebrewCalendar option: ${k}`);
      unrecognizedAlreadyWarned.add(k);
    }
  }
}
const israelCityOffset = {
  'Jerusalem': 40,
  'Haifa': 30,
  'Zikhron Ya\'aqov': 30,
  'Zikhron Ya\'akov': 30,
  'Zikhron Yaakov': 30,
  'Zichron Ya\'akov': 30,
  'Zichron Yaakov': 30
};
const geoIdCandleOffset = {
  '281184': 40,
  // Jerusalem
  '294801': 30,
  // Haifa
  '293067': 30 // Zikhron Yaakov
};

/**
 * @private
 * @constant
 * This calculation is based on the position of the sun 36 minutes after sunset in Jerusalem
 * around the equinox / equilux, which is 8.5° below geometric zenith.
 * The Ohr Meir considers this the time that 3 small stars are visible,
 * which is later than the required 3 medium stars.
 * @see {https://kosherjava.com/zmanim/docs/api/com/kosherjava/zmanim/ZmanimCalendar.html#ZENITH_8_POINT_5}
 */
const TZEIT_3SMALL_STARS = 8.5;

/**
 * @private
 * @constant
 * This calculation is based on observation of 3 medium sized stars by Dr. Baruch Cohen
 * in his calendar published in in 1899 in Strasbourg, France.
 * This calculates to 7.0833333° below geometric zenith.
 * @see {https://kosherjava.com/zmanim/docs/api/com/kosherjava/zmanim/ComplexZmanimCalendar.html#ZENITH_7_POINT_083}
 */
const TZEIT_3MEDIUM_STARS = 7.0833333;

/**
 * Modifies options in-place
 * @private
 * @param {CalOptions} options
 */
function checkCandleOptions(options) {
  if (!options.candlelighting) {
    return;
  }
  const location = options.location;
  if (typeof location === 'undefined' || !(location instanceof Location)) {
    throw new TypeError('options.candlelighting requires valid options.location');
  }
  if (typeof options.havdalahMins === 'number' && typeof options.havdalahDeg === 'number') {
    throw new TypeError('options.havdalahMins and options.havdalahDeg are mutually exclusive');
  }
  let min = parseInt(options.candleLightingMins, 10) || 18;
  if (location.getIsrael() && Math.abs(min) === 18) {
    const geoid = location.getGeoId();
    const offset0 = geoIdCandleOffset[geoid];
    if (typeof offset0 === 'number') {
      min = offset0;
    }
    const offset = israelCityOffset[location.getShortName()];
    if (typeof offset === 'number') {
      min = offset;
    }
  }
  options.candleLightingMins = -1 * Math.abs(min);
  if (typeof options.havdalahMins === 'number') {
    options.havdalahMins = Math.abs(options.havdalahMins);
  } else if (typeof options.havdalahDeg === 'number') {
    options.havdalahDeg = Math.abs(options.havdalahDeg);
  } else {
    options.havdalahDeg = TZEIT_3SMALL_STARS;
  }
  if (typeof options.fastEndDeg !== 'number') {
    options.fastEndDeg = TZEIT_3MEDIUM_STARS;
  }
}

/**
 * Options to configure which events are returned
 * @typedef {Object} CalOptions
 * @property {Location} location - latitude/longitude/tzid used for candle-lighting
 * @property {number} year - Gregorian or Hebrew year
 * @property {boolean} isHebrewYear - to interpret year as Hebrew year
 * @property {number} month - Gregorian or Hebrew month (to filter results to a single month)
 * @property {number} numYears - generate calendar for multiple years (default 1)
 * @property {Date|HDate|number} start - use specific start date (requires end date)
 * @property {Date|HDate|number} end - use specific end date (requires start date)
 * @property {boolean} candlelighting - calculate candle-lighting and havdalah times
 * @property {number} candleLightingMins - minutes before sundown to light candles (default 18)
 * @property {number} havdalahMins - minutes after sundown for Havdalah (typical values are 42, 50, or 72).
 *      If `undefined` (the default), calculate Havdalah according to Tzeit Hakochavim -
 *      Nightfall (the point when 3 small stars are observable in the night time sky with
 *      the naked eye). If `0`, Havdalah times are suppressed.
 * @property {number} havdalahDeg - degrees for solar depression for Havdalah.
 *      Default is 8.5 degrees for 3 small stars. use 7.083 degrees for 3 medium-sized stars
 *      (observed by Dr. Baruch (Berthold) Cohn in his luach published in France in 1899).
 *      If `0`, Havdalah times are suppressed.
 * @property {number} fastEndDeg - degrees for solar depression for end of fast days.
 *      Default is 7.083 degrees for 3 medium-sized stars. Other commonly-used values include
 *      6.45 degrees, as calculated by Rabbi Yechiel Michel Tucazinsky.
 * @property {boolean} useElevation - use elevation for calculations (default `false`).
 *      If `true`, use elevation to affect the calculation of all sunrise/sunset based zmanim.
 *      Note: there are some zmanim such as degree-based zmanim that are driven by the amount
 *      of light in the sky and are not impacted by elevation.
 *      These zmanim intentionally do not support elevation adjustment.
 * @property {boolean} sedrot - calculate parashah hashavua on Saturdays
 * @property {boolean} il - Israeli holiday and sedra schedule
 * @property {boolean} noMinorFast - suppress minor fasts
 * @property {boolean} noModern - suppress modern holidays
 * @property {boolean} noRoshChodesh - suppress Rosh Chodesh
 * @property {boolean} shabbatMevarchim - add Shabbat Mevarchim
 * @property {boolean} noSpecialShabbat - suppress Special Shabbat
 * @property {boolean} noHolidays - suppress regular holidays
 * @property {boolean} omer - include Days of the Omer
 * @property {boolean} molad - include event announcing the molad
 * @property {boolean} ashkenazi - use Ashkenazi transliterations for event titles (default Sephardi transliterations)
 * @property {string} locale - translate event titles according to a locale
 *      Default value is `en`, also built-in are `he` and `ashkenazi`.
 *      Additional locales (such as `ru` or `fr`) are provided by the
 *      {@link https://github.com/hebcal/hebcal-locales @hebcal/locales} package
 * @property {boolean} addHebrewDates - print the Hebrew date for the entire date range
 * @property {boolean} addHebrewDatesForEvents - print the Hebrew date for dates with some events
 * @property {number} mask - use bitmask from `flags` to filter events
 * @property {boolean} yomKippurKatan - include Yom Kippur Katan (default `false`).
 *      יוֹם כִּפּוּר קָטָן is a minor day of atonement occurring monthly on the day preceeding each Rosh Chodesh.
 *      Yom Kippur Katan is omitted in Elul (on the day before Rosh Hashanah),
 *      Tishrei (Yom Kippur has just passed), Kislev (due to Chanukah)
 *      and Nisan (fasting not permitted during Nisan).
 *      When Rosh Chodesh occurs on Shabbat or Sunday, Yom Kippur Katan is observed on the preceding Thursday.
 *      See {@link https://en.wikipedia.org/wiki/Yom_Kippur_Katan#Practices Wikipedia Yom Kippur Katan practices}
 * @property {boolean} hour12 - Whether to use 12-hour time (as opposed to 24-hour time).
 *      Possible values are `true` and `false`; the default is locale dependent.
 * @property {Object<string,any>} dailyLearning - map of options to enable daily study calendars
 *      such as `dafYomi`, `mishnaYomi`, `nachYomi` with value `true`. For `yerushalmi`
 *      the value should be a `number` for edition (`1` for Vilna, `2` for Schottenstein).
 */

/**
 * @typedef {Object} TachanunResult
 * @property {boolean} shacharit Tachanun is said at Shacharit
 * @property {boolean} mincha Tachanun is said at Mincha
 * @property {boolean} allCongs All congregations say Tachanun on the day
 */

/**
 * Gets the R.D. days for a number, Date, or HDate
 * @private
 * @param {Date|HDate|number} d
 * @return {number}
 */
function getAbs(d) {
  if (typeof d == 'number') return d;
  if (greg.isDate(d)) return greg.greg2abs(d);
  if (HDate.isHDate(d)) return d.abs();
  throw new TypeError(`Invalid date type: ${d}`);
}

/**
 * Parse options object to determine start & end days
 * @private
 * @param {CalOptions} options
 * @return {number[]}
 */
function getStartAndEnd(options) {
  if (options.start && !options.end || options.end && !options.start) {
    throw new TypeError('Both options.start and options.end are required');
  } else if (options.start && options.end) {
    return [getAbs(options.start), getAbs(options.end)];
  }
  const isHebrewYear = Boolean(options.isHebrewYear);
  const theYear = typeof options.year !== 'undefined' ? parseInt(options.year, 10) : isHebrewYear ? new HDate().getFullYear() : new Date().getFullYear();
  if (isNaN(theYear)) {
    throw new RangeError(`Invalid year ${options.year}`);
  } else if (isHebrewYear && theYear < 1) {
    throw new RangeError(`Invalid Hebrew year ${theYear}`);
  }
  let theMonth = NaN;
  if (options.month) {
    if (isHebrewYear) {
      theMonth = HDate.monthNum(options.month);
    } else {
      theMonth = options.month;
    }
  }
  const numYears = parseInt(options.numYears, 10) || 1;
  if (isHebrewYear) {
    const startDate = new HDate(1, theMonth || TISHREI, theYear);
    let startAbs = startDate.abs();
    const endAbs = options.month ? startAbs + startDate.daysInMonth() : new HDate(1, TISHREI, theYear + numYears).abs() - 1;
    // for full Hebrew year, start on Erev Rosh Hashana which
    // is technically in the previous Hebrew year
    // (but conveniently lets us get candle-lighting time for Erev)
    if (!theMonth && theYear > 1) {
      startAbs--;
    }
    return [startAbs, endAbs];
  } else {
    const gregMonth = options.month ? theMonth - 1 : 0;
    const startGreg = new Date(theYear, gregMonth, 1);
    if (theYear < 100) {
      startGreg.setFullYear(theYear);
    }
    const startAbs = greg.greg2abs(startGreg);
    let endAbs;
    if (options.month) {
      endAbs = startAbs + greg.daysInMonth(theMonth, theYear) - 1;
    } else {
      const endYear = theYear + numYears;
      const endGreg = new Date(endYear, 0, 1);
      if (endYear < 100) {
        endGreg.setFullYear(endYear);
      }
      endAbs = greg.greg2abs(endGreg) - 1;
    }
    return [startAbs, endAbs];
  }
}

/**
 * Mask to filter Holiday array
 * @private
 * @param {CalOptions} options
 * @return {number}
 */
function getMaskFromOptions(options) {
  var _options$location;
  if (typeof options.mask === 'number') {
    return setOptionsFromMask(options);
  }
  const il = options.il || ((_options$location = options.location) === null || _options$location === void 0 ? void 0 : _options$location.il) || false;
  let mask = 0;

  // default options
  if (!options.noHolidays) {
    mask |= ROSH_CHODESH | YOM_TOV_ENDS | MINOR_FAST | SPECIAL_SHABBAT | MODERN_HOLIDAY | MAJOR_FAST | MINOR_HOLIDAY | EREV | CHOL_HAMOED | LIGHT_CANDLES | LIGHT_CANDLES_TZEIS | CHANUKAH_CANDLES;
  }
  if (options.candlelighting) {
    mask |= LIGHT_CANDLES | LIGHT_CANDLES_TZEIS | YOM_TOV_ENDS;
  }
  // suppression of defaults
  if (options.noRoshChodesh) {
    mask &= ~ROSH_CHODESH;
  }
  if (options.noModern) {
    mask &= ~MODERN_HOLIDAY;
  }
  if (options.noMinorFast) {
    mask &= ~MINOR_FAST;
  }
  if (options.noSpecialShabbat) {
    mask &= ~SPECIAL_SHABBAT;
    mask &= ~SHABBAT_MEVARCHIM;
  }
  if (il) {
    mask |= IL_ONLY;
  } else {
    mask |= CHUL_ONLY;
  }
  // non-default options
  if (options.sedrot) {
    mask |= PARSHA_HASHAVUA;
  }
  if (options.omer) {
    mask |= OMER_COUNT;
  }
  if (options.shabbatMevarchim) {
    mask |= SHABBAT_MEVARCHIM;
  }
  if (options.yomKippurKatan) {
    mask |= YOM_KIPPUR_KATAN;
  }
  if (options.dailyLearning) {
    const dailyLearning = options.dailyLearning;
    if (dailyLearning.dafYomi) {
      mask |= DAF_YOMI;
    }
    if (dailyLearning.mishnaYomi) {
      mask |= MISHNA_YOMI;
    }
    if (dailyLearning.nachYomi) {
      mask |= NACH_YOMI;
    }
    if (dailyLearning.yerushalmi) {
      mask |= YERUSHALMI_YOMI;
    }
  }
  return mask;
}
const MASK_LIGHT_CANDLES = LIGHT_CANDLES | LIGHT_CANDLES_TZEIS | CHANUKAH_CANDLES | YOM_TOV_ENDS;
const defaultLocation = new Location(0, 0, false, 'UTC');

/**
 * @private
 * @param {CalOptions} options
 * @return {number}
 */
function setOptionsFromMask(options) {
  const m = options.mask;
  if (m & ROSH_CHODESH) delete options.noRoshChodesh;
  if (m & MODERN_HOLIDAY) delete options.noModern;
  if (m & MINOR_FAST) delete options.noMinorFast;
  if (m & SPECIAL_SHABBAT) delete options.noSpecialShabbat;
  if (m & PARSHA_HASHAVUA) options.sedrot = true;
  if (m & (DAF_YOMI | MISHNA_YOMI | NACH_YOMI | YERUSHALMI_YOMI)) {
    options.dailyLearning = options.dailyLearning || {};
    if (m & DAF_YOMI) {
      options.dailyLearning.dafYomi = true;
    }
    if (m & MISHNA_YOMI) {
      options.dailyLearning.mishnaYomi = true;
    }
    if (m & NACH_YOMI) {
      options.dailyLearning.nachYomi = true;
    }
    if (m & YERUSHALMI_YOMI) {
      options.dailyLearning.yerushalmi = 1;
    }
  }
  if (m & OMER_COUNT) options.omer = true;
  if (m & SHABBAT_MEVARCHIM) options.shabbatMevarchim = true;
  if (m & YOM_KIPPUR_KATAN) options.yomKippurKatan = true;
  options.userMask = true;
  return m;
}

/**
 * @private
 * @param {Event} ev
 * @return {boolean}
 */
function observedInIsrael(ev) {
  return ev.observedInIsrael();
}

/**
 * @private
 * @param {Event} ev
 * @return {boolean}
 */
function observedInDiaspora(ev) {
  return ev.observedInDiaspora();
}

/**
 * HebrewCalendar is the main interface to the `@hebcal/core` library.
 * This namespace is used to calculate holidays, rosh chodesh, candle lighting & havdalah times,
 * Parashat HaShavua, Daf Yomi, days of the omer, and the molad.
 * Event names can be rendered in several languges using the `locale` option.
 */
class HebrewCalendar {
  /**
   * Calculates holidays and other Hebrew calendar events based on {@link CalOptions}.
   *
   * Each holiday is represented by an {@link Event} object which includes a date,
   * a description, flags and optional attributes.
   * If given no options, returns holidays for the Diaspora for the current Gregorian year.
   *
   * The date range returned by this function can be controlled by:
   * * `options.year` - Gregorian (e.g. 1993) or Hebrew year (e.g. 5749)
   * * `options.isHebrewYear` - to interpret `year` as Hebrew year
   * * `options.numYears` - generate calendar for multiple years (default 1)
   * * `options.month` - Gregorian or Hebrew month (to filter results to a single month)
   *
   * Alternatively, specify start and end days with `Date` or {@link HDate} instances:
   * * `options.start` - use specific start date (requires `end` date)
   * * `options.end` - use specific end date (requires `start` date)
   *
   * Unless `options.noHolidays == true`, default holidays include:
   * * Major holidays - Rosh Hashana, Yom Kippur, Pesach, Sukkot, etc.
   * * Minor holidays - Purim, Chanukah, Tu BiShvat, Lag BaOmer, etc.
   * * Minor fasts - Ta'anit Esther, Tzom Gedaliah, etc. (unless `options.noMinorFast`)
   * * Special Shabbatot - Shabbat Shekalim, Zachor, etc. (unless `options.noSpecialShabbat`)
   * * Modern Holidays - Yom HaShoah, Yom HaAtzma'ut, etc. (unless `options.noModern`)
   * * Rosh Chodesh (unless `options.noRoshChodesh`)
   *
   * Holiday and Torah reading schedules differ between Israel and the Disapora.
   * Set `options.il=true` to use the Israeli schedule.
   *
   * Additional non-default event types can be specified:
   * * Parashat HaShavua - weekly Torah Reading on Saturdays (`options.sedrot`)
   * * Counting of the Omer (`options.omer`)
   * * Shabbat Mevarchim HaChodesh on Saturday before Rosh Chodesh (`options.shabbatMevarchim`)
   * * Molad announcement on Saturday before Rosh Chodesh (`options.molad`)
   * * Yom Kippur Katan (`options.yomKippurKatan`)
   *
   * Daily Study of texts are supported by the
   * {@link https://github.com/hebcal/hebcal-learning @hebcal/learning} package,
   * for example:
   * * Babylonian Talmud Daf Yomi (`options.dailyLearning.dafYomi`)
   * * Jerusalem Talmud (Yerushalmi) Yomi (`options.dailyLearning.yerushalmi`)
   * * Mishna Yomi (`options.dailyLearning.mishnaYomi`)
   * * Nach Yomi (`options.dailyLearning.nachYomi`)
   *
   * Candle-lighting and Havdalah times are approximated using latitude and longitude
   * specified by the {@link Location} class. The `Location` class contains a small
   * database of cities with their associated geographic information and time-zone information.
   * If you ever have any doubts about Hebcal's times, consult your local halachic authority.
   * If you enter geographic coordinates above the arctic circle or antarctic circle,
   * the times are guaranteed to be wrong.
   *
   * To add candle-lighting options, set `options.candlelighting=true` and set
   * `options.location` to an instance of `Location`. By default, candle lighting
   * time is 18 minutes before sundown (40 minutes for Jerusalem,
   * 30 minutes for Haifa and Zikhron Ya'akov) and Havdalah is
   * calculated according to Tzeit Hakochavim - Nightfall (the point when 3 small stars
   * are observable in the night time sky with the naked eye). The default Havdalah
   * option (Tzeit Hakochavim) is calculated when the sun is 8.5° below the horizon.
   * These defaults can be changed using these options:
   * * `options.candleLightingMins` - minutes before sundown to light candles
   * * `options.havdalahMins` - minutes after sundown for Havdalah (typical values are 42, 50, or 72).
   *    Havdalah times are suppressed when `options.havdalahMins=0`.
   * * `options.havdalahDeg` - degrees for solar depression for Havdalah.
   *    Default is 8.5 degrees for 3 small stars. Use 7.083 degrees for 3 medium-sized stars.
   *    Havdalah times are suppressed when `options.havdalahDeg=0`.
   *
   * If both `options.candlelighting=true` and `options.location` is specified,
   * Chanukah candle-lighting times and minor fast start/end times will also be generated.
   * Chanukah candle-lighting is at dusk (when the sun is 6.0° below the horizon in the evening)
   * on weekdays, at regular candle-lighting time on Fridays, and at regular Havdalah time on
   * Saturday night (see above).
   *
   * Minor fasts begin at Alot HaShachar (sun is 16.1° below the horizon in the morning) and
   * end when 3 medium-sized stars are observable in the night sky (sun is 7.083° below the horizon
   * in the evening).
   *
   * Two options also exist for generating an Event with the Hebrew date:
   * * `options.addHebrewDates` - print the Hebrew date for the entire date range
   * * `options.addHebrewDatesForEvents` - print the Hebrew date for dates with some events
   *
   * Lastly, translation and transliteration of event titles is controlled by
   * `options.locale` and the {@link Locale} API.
   * `@hebcal/core` supports three locales by default:
   * * `en` - default, Sephardic transliterations (e.g. "Shabbat")
   * * `ashkenazi` - Ashkenazi transliterations (e.g. "Shabbos")
   * * `he` - Hebrew (e.g. "שַׁבָּת")
   *
   * Additional locales (such as `ru` or `fr`) are supported by the
   * {@link https://github.com/hebcal/hebcal-locales @hebcal/locales} package
   *
   * @example
   * import {HebrewCalendar, HDate, Location, Event} from '@hebcal/core';
   * const options = {
   *   year: 1981,
   *   isHebrewYear: false,
   *   candlelighting: true,
   *   location: Location.lookup('San Francisco'),
   *   sedrot: true,
   *   omer: true,
   * };
   * const events = HebrewCalendar.calendar(options);
   * for (const ev of events) {
   *   const hd = ev.getDate();
   *   const date = hd.greg();
   *   console.log(date.toLocaleDateString(), ev.render('en'), hd.toString());
   * }
   * @param {CalOptions} [options={}]
   * @return {Event[]}
   */
  static calendar(options = {}) {
    options = Object.assign({}, options); // so we can modify freely
    checkCandleOptions(options);
    const location = options.location = options.location || defaultLocation;
    const il = options.il = options.il || location.il || false;
    options.mask = getMaskFromOptions(options);
    if (options.ashkenazi || options.locale) {
      if (options.locale && typeof options.locale !== 'string') {
        throw new TypeError(`Invalid options.locale: ${options.locale}`);
      }
      const locale = options.ashkenazi ? 'ashkenazi' : options.locale;
      const translationObj = Locale.useLocale(locale);
      if (!translationObj) {
        throw new TypeError(`Locale '${locale}' not found; did you forget to import @hebcal/locales?`);
      }
    } else {
      Locale.useLocale('en');
    }
    const evts = [];
    let sedra;
    let holidaysYear;
    let beginOmer;
    let endOmer;
    let currentYear = -1;
    const startAndEnd = getStartAndEnd(options);
    warnUnrecognizedOptions(options);
    const startAbs = startAndEnd[0];
    const endAbs = startAndEnd[1];
    const startGreg = greg.abs2greg(startAbs);
    if (startGreg.getFullYear() < 100) {
      options.candlelighting = false;
    }
    for (let abs = startAbs; abs <= endAbs; abs++) {
      const hd = new HDate(abs);
      const hyear = hd.getFullYear();
      if (hyear != currentYear) {
        currentYear = hyear;
        holidaysYear = getHolidaysForYear_(currentYear);
        if (options.sedrot) {
          sedra = getSedra_(currentYear, il);
        }
        if (options.omer) {
          beginOmer = HDate.hebrew2abs(currentYear, NISAN, 16);
          endOmer = HDate.hebrew2abs(currentYear, SIVAN, 5);
        }
      }
      const prevEventsLength = evts.length;
      const dow = hd.getDay();
      const isFriday = dow === FRI;
      const isSaturday = dow === SAT;
      let candlesEv;
      const ev = holidaysYear.get(hd.toString()) || [];
      for (const e of ev) {
        candlesEv = appendHolidayAndRelated(candlesEv, evts, e, options, isFriday, isSaturday);
      }
      if (options.sedrot && isSaturday) {
        const parsha0 = sedra.lookup(abs);
        if (!parsha0.chag) {
          evts.push(new ParshaEvent(hd, parsha0.parsha, il, parsha0.num));
        }
      }
      const dailyLearning = options.dailyLearning;
      if (typeof dailyLearning === 'object') {
        for (const [key, val] of Object.entries(dailyLearning)) {
          if (val) {
            const name = key === 'yerushalmi' ? val === 2 ? 'yerushalmi-schottenstein' : 'yerushalmi-vilna' : key;
            const learningEv = DailyLearning.lookup(name, hd);
            if (learningEv) {
              evts.push(learningEv);
            }
          }
        }
      }
      if (options.omer && abs >= beginOmer && abs <= endOmer) {
        const omer = abs - beginOmer + 1;
        const omerEv = new OmerEvent(hd, omer);
        if (options.candlelighting) {
          const zmanim = new Zmanim(location, hd.prev());
          const tzeit = zmanim.tzeit(7.0833);
          if (!isNaN(tzeit.getTime())) {
            omerEv.alarm = tzeit;
          }
        }
        evts.push(omerEv);
      }
      const hmonth = hd.getMonth();
      const hdate = hd.getDate();
      if (isSaturday && (options.molad || options.shabbatMevarchim) && hmonth != ELUL && hdate >= 23 && hdate <= 29) {
        const monNext = hmonth == HDate.monthsInYear(hyear) ? NISAN : hmonth + 1;
        if (options.molad) {
          evts.push(new MoladEvent(hd, hyear, monNext, options));
        }
        if (options.shabbatMevarchim) {
          const nextMonthName = HDate.getMonthName(monNext, hyear);
          const molad = new Molad(hyear, monNext);
          const memo = molad.render(options.locale || 'en', options);
          evts.push(new MevarchimChodeshEvent(hd, nextMonthName, memo));
        }
      }
      if (!candlesEv && options.candlelighting && (isFriday || isSaturday)) {
        candlesEv = makeCandleEvent(undefined, hd, options, isFriday, isSaturday);
        if (isFriday && candlesEv && sedra) {
          candlesEv.memo = sedra.getString(abs, options.locale);
        }
      }
      // suppress Havdalah when options.havdalahMins=0 or options.havdalahDeg=0
      if (candlesEv instanceof HavdalahEvent && (options.havdalahMins === 0 || options.havdalahDeg === 0)) {
        candlesEv = null;
      }
      if (candlesEv) {
        evts.push(candlesEv);
      }
      if (options.addHebrewDates || options.addHebrewDatesForEvents && prevEventsLength != evts.length) {
        const e2 = new HebrewDateEvent(hd);
        if (prevEventsLength == evts.length) {
          evts.push(e2);
        } else {
          evts.splice(prevEventsLength, 0, e2);
        }
      }
    }
    return evts;
  }

  /**
   * Calculates a birthday or anniversary (non-yahrzeit).
   * `hyear` must be after original `gdate` of anniversary.
   * Returns `undefined` when requested year preceeds or is same as original year.
   *
   * Hebcal uses the algorithm defined in "Calendrical Calculations"
   * by Edward M. Reingold and Nachum Dershowitz.
   *
   * The birthday of someone born in Adar of an ordinary year or Adar II of
   * a leap year is also always in the last month of the year, be that Adar
   * or Adar II. The birthday in an ordinary year of someone born during the
   * first 29 days of Adar I in a leap year is on the corresponding day of Adar;
   * in a leap year, the birthday occurs in Adar I, as expected.
   *
   * Someone born on the thirtieth day of Marcheshvan, Kislev, or Adar I
   * has his birthday postponed until the first of the following month in
   * years where that day does not occur. [Calendrical Calculations p. 111]
   * @example
   * import {HebrewCalendar} from '@hebcal/core';
   * const dt = new Date(2014, 2, 2); // '2014-03-02' == '30 Adar I 5774'
   * const hd = HebrewCalendar.getBirthdayOrAnniversary(5780, dt); // '1 Nisan 5780'
   * console.log(hd.greg().toLocaleDateString('en-US')); // '3/26/2020'
   * @param {number} hyear Hebrew year
   * @param {Date|HDate} gdate Gregorian or Hebrew date of event
   * @return {HDate} anniversary occurring in `hyear`
   */
  static getBirthdayOrAnniversary(hyear, gdate) {
    const dt = getBirthdayHD(hyear, gdate);
    if (typeof dt === 'undefined') {
      return dt;
    }
    return new HDate(dt);
  }

  /**
   * Calculates yahrzeit.
   * `hyear` must be after original `gdate` of death.
   * Returns `undefined` when requested year preceeds or is same as original year.
   *
   * Hebcal uses the algorithm defined in "Calendrical Calculations"
   * by Edward M. Reingold and Nachum Dershowitz.
   *
   * The customary anniversary date of a death is more complicated and depends
   * also on the character of the year in which the first anniversary occurs.
   * There are several cases:
   *
   * * If the date of death is Marcheshvan 30, the anniversary in general depends
   *   on the first anniversary; if that first anniversary was not Marcheshvan 30,
   *   use the day before Kislev 1.
   * * If the date of death is Kislev 30, the anniversary in general again depends
   *   on the first anniversary — if that was not Kislev 30, use the day before
   *   Tevet 1.
   * * If the date of death is Adar II, the anniversary is the same day in the
   *   last month of the Hebrew year (Adar or Adar II).
   * * If the date of death is Adar I 30, the anniversary in a Hebrew year that
   *   is not a leap year (in which Adar only has 29 days) is the last day in
   *   Shevat.
   * * In all other cases, use the normal (that is, same month number) anniversary
   *   of the date of death. [Calendrical Calculations p. 113]
   * @example
   * import {HebrewCalendar} from '@hebcal/core';
   * const dt = new Date(2014, 2, 2); // '2014-03-02' == '30 Adar I 5774'
   * const hd = HebrewCalendar.getYahrzeit(5780, dt); // '30 Sh\'vat 5780'
   * console.log(hd.greg().toLocaleDateString('en-US')); // '2/25/2020'
   * @param {number} hyear Hebrew year
   * @param {Date|HDate} gdate Gregorian or Hebrew date of death
   * @return {HDate} anniversary occurring in hyear
   */
  static getYahrzeit(hyear, gdate) {
    const dt = getYahrzeitHD(hyear, gdate);
    if (typeof dt === 'undefined') {
      return dt;
    }
    return new HDate(dt);
  }

  /**
   * Lower-level holidays interface, which returns a `Map` of `Event`s indexed by
   * `HDate.toString()`. These events must filtered especially for `flags.IL_ONLY`
   * or `flags.CHUL_ONLY` depending on Israel vs. Diaspora holiday scheme.
   * @function
   * @param {number} year Hebrew year
   * @return {Map<string,Event[]>}
   */
  static getHolidaysForYear(year) {
    return getHolidaysForYear_(year);
  }

  /**
   * Returns an array of holidays for the year
   * @param {number} year Hebrew year
   * @param {boolean} il use the Israeli schedule for holidays
   * @return {Event[]}
   */
  static getHolidaysForYearArray(year, il) {
    const yearMap = getHolidaysForYear_(year);
    const startAbs = HDate.hebrew2abs(year, TISHREI, 1);
    const endAbs = HDate.hebrew2abs(year + 1, TISHREI, 1) - 1;
    let events = [];
    const myFilter = il ? observedInIsrael : observedInDiaspora;
    for (let absDt = startAbs; absDt <= endAbs; absDt++) {
      const hd = new HDate(absDt);
      const holidays = yearMap.get(hd.toString());
      if (holidays) {
        const filtered = holidays.filter(myFilter);
        events = events.concat(filtered);
      }
    }
    return events;
  }

  /**
   * Returns an array of Events on this date (or `undefined` if no events)
   * @param {HDate|Date|number} date Hebrew Date, Gregorian date, or absolute R.D. day number
   * @param {boolean} [il] use the Israeli schedule for holidays
   * @return {Event[]}
   */
  static getHolidaysOnDate(date, il) {
    const hd = HDate.isHDate(date) ? date : new HDate(date);
    const hdStr = hd.toString();
    const yearMap = getHolidaysForYear_(hd.getFullYear());
    const events = yearMap.get(hdStr);
    // if il isn't a boolean return both diaspora + IL for day
    if (typeof il === 'undefined' || typeof events === 'undefined') {
      return events;
    }
    const myFilter = il ? observedInIsrael : observedInDiaspora;
    const filtered = events.filter(myFilter);
    return filtered;
  }

  /**
   * Helper function to format a 23-hour (00:00-23:59) time in US format ("8:13pm") or
   * keep as "20:13" for any other locale/country. Uses {@link CalOptions} to determine
   * locale.
   * If `options.hour12` is `false`, locale is ignored and always returns 24-hour time.
   * If `options.hour12` is `true`, locale is ignored and always returns 12-hour time.
   * @param {string} timeStr - original time like "20:30"
   * @param {string} suffix - "p" or "pm" or " P.M.". Add leading space if you want it
   * @param {CalOptions} options
   * @return {string}
   */
  static reformatTimeStr(timeStr, suffix, options) {
    return reformatTimeStr(timeStr, suffix, options);
  }

  /** @return {string} */
  static version() {
    return version;
  }

  /**
   * Convenience function to create an instance of `Sedra` or reuse a previously
   * created and cached instance.
   * @function
   * @param {number} hyear
   * @param {boolean} il
   * @return {Sedra}
   */
  static getSedra(hyear, il) {
    return getSedra_(hyear, il);
  }

  /**
   * Return a number containing information on what Hallel is said on that day.
   *
   * Whole Hallel is said on Chanukah, the first Yom Tov of Pesach, Shavuot, Sukkot,
   * Yom Ha'atzmaut, and Yom Yerushalayim.
   *
   * Half Hallel is said on Rosh Chodesh (not Rosh Hashanah), and the last 6 days of Pesach.
   *
   * The number is one of the following values:
   *
   * 0 - No Hallel
   * 1 - Half Hallel
   * 2 - Whole Hallel
   *
   * @param {HDate} hdate
   * @param {boolean} il
   * @return {number}
   */
  static hallel(hdate, il) {
    const events = HebrewCalendar.getHolidaysForYearArray(hdate.getFullYear(), il);
    return hallel_(events, hdate);
  }

  /**
   * Return details on what Tachanun (or Tzidchatcha on Shabbat) is said on `hdate`.
   *
   * Tachanun is not said on Rosh Chodesh, the month of Nisan, Lag Baomer,
   * Rosh Chodesh Sivan until Isru Chag, Tisha B'av, 15 Av, Erev Rosh Hashanah,
   * Rosh Hashanah, Erev Yom Kippur until after Simchat Torah, Chanukah,
   * Tu B'shvat, Purim and Shushan Purim, and Purim and Shushan Purim Katan.
   *
   * In some congregations Tachanun is not said until from Rosh Chodesh Sivan
   * until 14th Sivan, Sukkot until after Rosh Chodesh Cheshvan, Pesach Sheini,
   * Yom Ha'atzmaut, and Yom Yerushalayim.
   *
   * Tachanun is not said at Mincha on days before it is not said at Shacharit.
   *
   * Tachanun is not said at Shacharit on Shabbat, but is at Mincha, usually.
   * @param {HDate} hdate
   * @param {boolean} il
   * @return {TachanunResult}
   */
  static tachanun(hdate, il) {
    return tachanun_(hdate, il);
  }
}

/**
 * Appends the Event `ev` to the `events` array. Also may add related
 * timed events like candle-lighting or fast start/end
 * @private
 * @param {Event} candlesEv
 * @param {Event[]} events
 * @param {Event} ev
 * @param {CalOptions} options
 * @param {boolean} isFriday
 * @param {boolean} isSaturday
 * @return {Event}
 */
function appendHolidayAndRelated(candlesEv, events, ev, options, isFriday, isSaturday) {
  const il = options.il;
  if (!ev.observedIn(il)) {
    return candlesEv; // holiday isn't observed here; bail out early
  }
  const eFlags = ev.getFlags();
  if (!options.yomKippurKatan && eFlags & YOM_KIPPUR_KATAN || options.noModern && eFlags & MODERN_HOLIDAY) {
    return candlesEv; // bail out early
  }
  const location = options.location;
  const isMajorFast = Boolean(eFlags & MAJOR_FAST);
  const isMinorFast = Boolean(eFlags & MINOR_FAST);
  if (options.candlelighting && (isMajorFast || isMinorFast)) {
    ev = makeFastStartEnd(ev, options);
    if (ev.startEvent && (isMajorFast || isMinorFast && !options.noMinorFast)) {
      events.push(ev.startEvent);
    }
  }
  if (eFlags & options.mask || !eFlags && !options.userMask) {
    if (options.candlelighting && eFlags & MASK_LIGHT_CANDLES) {
      const hd = ev.getDate();
      candlesEv = makeCandleEvent(ev, hd, options, isFriday, isSaturday);
      if (eFlags & CHANUKAH_CANDLES && candlesEv && !options.noHolidays) {
        const chanukahEv = isFriday || isSaturday ? candlesEv : makeWeekdayChanukahCandleLighting(ev, hd, options);
        const attrs = {
          eventTime: chanukahEv.eventTime,
          eventTimeStr: chanukahEv.eventTimeStr,
          location
        };
        if (ev.chanukahDay) attrs.chanukahDay = ev.chanukahDay;
        if (ev.emoji) attrs.emoji = ev.emoji;
        // Replace Chanukah event with a clone that includes candle lighting time.
        // For clarity, allow a "duplicate" candle lighting event to remain for Shabbat
        ev = new HolidayEvent(hd, ev.getDesc(), eFlags, attrs);
        candlesEv = undefined;
      }
    }
    if (!options.noHolidays || options.yomKippurKatan && eFlags & YOM_KIPPUR_KATAN) {
      events.push(ev); // the original event itself
    }
  }
  if (ev.endEvent && (isMajorFast || isMinorFast && !options.noMinorFast)) {
    events.push(ev.endEvent);
  }
  return candlesEv;
}

export { AsaraBTevetEvent, CandleLightingEvent, DailyLearning, Event, GeoLocation, HDate, HavdalahEvent, HebrewCalendar, HebrewDateEvent, HolidayEvent, Locale, Location, MevarchimChodeshEvent, Molad, MoladEvent, NOAACalculator, OmerEvent, ParshaEvent, RoshChodeshEvent, RoshHashanaEvent, Sedra, TimedEvent, Zmanim, flags, gematriya, gematriyaStrToNum, greg, months, parshiot, version };
